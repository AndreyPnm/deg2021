/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
"use strict";

var $protobuf = require("protobufjs/minimal");

// Common aliases
var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

$root.wavesenterprise = (function() {

    /**
     * Namespace wavesenterprise.
     * @exports wavesenterprise
     * @namespace
     */
    var wavesenterprise = {};

    wavesenterprise.BlockchainEventsService = (function() {

        /**
         * Constructs a new BlockchainEventsService service.
         * @memberof wavesenterprise
         * @classdesc Represents a BlockchainEventsService
         * @extends $protobuf.rpc.Service
         * @constructor
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         */
        function BlockchainEventsService(rpcImpl, requestDelimited, responseDelimited) {
            $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }

        (BlockchainEventsService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = BlockchainEventsService;

        /**
         * Creates new BlockchainEventsService service using the specified rpc implementation.
         * @function create
         * @memberof wavesenterprise.BlockchainEventsService
         * @static
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         * @returns {BlockchainEventsService} RPC service. Useful where requests and/or responses are streamed.
         */
        BlockchainEventsService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
            return new this(rpcImpl, requestDelimited, responseDelimited);
        };

        /**
         * Callback as used by {@link wavesenterprise.BlockchainEventsService#subscribeOn}.
         * @memberof wavesenterprise.BlockchainEventsService
         * @typedef SubscribeOnCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {wavesenterprise.BlockchainEvent} [response] BlockchainEvent
         */

        /**
         * Calls SubscribeOn.
         * @function subscribeOn
         * @memberof wavesenterprise.BlockchainEventsService
         * @instance
         * @param {wavesenterprise.ISubscribeOnRequest} request SubscribeOnRequest message or plain object
         * @param {wavesenterprise.BlockchainEventsService.SubscribeOnCallback} callback Node-style callback called with the error, if any, and BlockchainEvent
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(BlockchainEventsService.prototype.subscribeOn = function subscribeOn(request, callback) {
            return this.rpcCall(subscribeOn, $root.wavesenterprise.SubscribeOnRequest, $root.wavesenterprise.BlockchainEvent, request, callback);
        }, "name", { value: "SubscribeOn" });

        /**
         * Calls SubscribeOn.
         * @function subscribeOn
         * @memberof wavesenterprise.BlockchainEventsService
         * @instance
         * @param {wavesenterprise.ISubscribeOnRequest} request SubscribeOnRequest message or plain object
         * @returns {Promise<wavesenterprise.BlockchainEvent>} Promise
         * @variation 2
         */

        return BlockchainEventsService;
    })();

    wavesenterprise.BlockchainEvent = (function() {

        /**
         * Properties of a BlockchainEvent.
         * @memberof wavesenterprise
         * @interface IBlockchainEvent
         * @property {wavesenterprise.IMicroBlockAppended|null} [microBlockAppended] BlockchainEvent microBlockAppended
         * @property {wavesenterprise.IBlockAppended|null} [blockAppended] BlockchainEvent blockAppended
         * @property {wavesenterprise.IRollbackCompleted|null} [rollbackCompleted] BlockchainEvent rollbackCompleted
         * @property {wavesenterprise.IAppendedBlockHistory|null} [appendedBlockHistory] BlockchainEvent appendedBlockHistory
         */

        /**
         * Constructs a new BlockchainEvent.
         * @memberof wavesenterprise
         * @classdesc Represents a BlockchainEvent.
         * @implements IBlockchainEvent
         * @constructor
         * @param {wavesenterprise.IBlockchainEvent=} [properties] Properties to set
         */
        function BlockchainEvent(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BlockchainEvent microBlockAppended.
         * @member {wavesenterprise.IMicroBlockAppended|null|undefined} microBlockAppended
         * @memberof wavesenterprise.BlockchainEvent
         * @instance
         */
        BlockchainEvent.prototype.microBlockAppended = null;

        /**
         * BlockchainEvent blockAppended.
         * @member {wavesenterprise.IBlockAppended|null|undefined} blockAppended
         * @memberof wavesenterprise.BlockchainEvent
         * @instance
         */
        BlockchainEvent.prototype.blockAppended = null;

        /**
         * BlockchainEvent rollbackCompleted.
         * @member {wavesenterprise.IRollbackCompleted|null|undefined} rollbackCompleted
         * @memberof wavesenterprise.BlockchainEvent
         * @instance
         */
        BlockchainEvent.prototype.rollbackCompleted = null;

        /**
         * BlockchainEvent appendedBlockHistory.
         * @member {wavesenterprise.IAppendedBlockHistory|null|undefined} appendedBlockHistory
         * @memberof wavesenterprise.BlockchainEvent
         * @instance
         */
        BlockchainEvent.prototype.appendedBlockHistory = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * BlockchainEvent blockchainEvent.
         * @member {"microBlockAppended"|"blockAppended"|"rollbackCompleted"|"appendedBlockHistory"|undefined} blockchainEvent
         * @memberof wavesenterprise.BlockchainEvent
         * @instance
         */
        Object.defineProperty(BlockchainEvent.prototype, "blockchainEvent", {
            get: $util.oneOfGetter($oneOfFields = ["microBlockAppended", "blockAppended", "rollbackCompleted", "appendedBlockHistory"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new BlockchainEvent instance using the specified properties.
         * @function create
         * @memberof wavesenterprise.BlockchainEvent
         * @static
         * @param {wavesenterprise.IBlockchainEvent=} [properties] Properties to set
         * @returns {wavesenterprise.BlockchainEvent} BlockchainEvent instance
         */
        BlockchainEvent.create = function create(properties) {
            return new BlockchainEvent(properties);
        };

        /**
         * Encodes the specified BlockchainEvent message. Does not implicitly {@link wavesenterprise.BlockchainEvent.verify|verify} messages.
         * @function encode
         * @memberof wavesenterprise.BlockchainEvent
         * @static
         * @param {wavesenterprise.IBlockchainEvent} message BlockchainEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BlockchainEvent.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.microBlockAppended != null && Object.hasOwnProperty.call(message, "microBlockAppended"))
                $root.wavesenterprise.MicroBlockAppended.encode(message.microBlockAppended, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.blockAppended != null && Object.hasOwnProperty.call(message, "blockAppended"))
                $root.wavesenterprise.BlockAppended.encode(message.blockAppended, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.rollbackCompleted != null && Object.hasOwnProperty.call(message, "rollbackCompleted"))
                $root.wavesenterprise.RollbackCompleted.encode(message.rollbackCompleted, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.appendedBlockHistory != null && Object.hasOwnProperty.call(message, "appendedBlockHistory"))
                $root.wavesenterprise.AppendedBlockHistory.encode(message.appendedBlockHistory, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified BlockchainEvent message, length delimited. Does not implicitly {@link wavesenterprise.BlockchainEvent.verify|verify} messages.
         * @function encodeDelimited
         * @memberof wavesenterprise.BlockchainEvent
         * @static
         * @param {wavesenterprise.IBlockchainEvent} message BlockchainEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BlockchainEvent.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BlockchainEvent message from the specified reader or buffer.
         * @function decode
         * @memberof wavesenterprise.BlockchainEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {wavesenterprise.BlockchainEvent} BlockchainEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BlockchainEvent.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.wavesenterprise.BlockchainEvent();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 2:
                    message.microBlockAppended = $root.wavesenterprise.MicroBlockAppended.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.blockAppended = $root.wavesenterprise.BlockAppended.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.rollbackCompleted = $root.wavesenterprise.RollbackCompleted.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.appendedBlockHistory = $root.wavesenterprise.AppendedBlockHistory.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BlockchainEvent message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof wavesenterprise.BlockchainEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {wavesenterprise.BlockchainEvent} BlockchainEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BlockchainEvent.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BlockchainEvent message.
         * @function verify
         * @memberof wavesenterprise.BlockchainEvent
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BlockchainEvent.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.microBlockAppended != null && message.hasOwnProperty("microBlockAppended")) {
                properties.blockchainEvent = 1;
                {
                    var error = $root.wavesenterprise.MicroBlockAppended.verify(message.microBlockAppended);
                    if (error)
                        return "microBlockAppended." + error;
                }
            }
            if (message.blockAppended != null && message.hasOwnProperty("blockAppended")) {
                if (properties.blockchainEvent === 1)
                    return "blockchainEvent: multiple values";
                properties.blockchainEvent = 1;
                {
                    var error = $root.wavesenterprise.BlockAppended.verify(message.blockAppended);
                    if (error)
                        return "blockAppended." + error;
                }
            }
            if (message.rollbackCompleted != null && message.hasOwnProperty("rollbackCompleted")) {
                if (properties.blockchainEvent === 1)
                    return "blockchainEvent: multiple values";
                properties.blockchainEvent = 1;
                {
                    var error = $root.wavesenterprise.RollbackCompleted.verify(message.rollbackCompleted);
                    if (error)
                        return "rollbackCompleted." + error;
                }
            }
            if (message.appendedBlockHistory != null && message.hasOwnProperty("appendedBlockHistory")) {
                if (properties.blockchainEvent === 1)
                    return "blockchainEvent: multiple values";
                properties.blockchainEvent = 1;
                {
                    var error = $root.wavesenterprise.AppendedBlockHistory.verify(message.appendedBlockHistory);
                    if (error)
                        return "appendedBlockHistory." + error;
                }
            }
            return null;
        };

        /**
         * Creates a BlockchainEvent message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof wavesenterprise.BlockchainEvent
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {wavesenterprise.BlockchainEvent} BlockchainEvent
         */
        BlockchainEvent.fromObject = function fromObject(object) {
            if (object instanceof $root.wavesenterprise.BlockchainEvent)
                return object;
            var message = new $root.wavesenterprise.BlockchainEvent();
            if (object.microBlockAppended != null) {
                if (typeof object.microBlockAppended !== "object")
                    throw TypeError(".wavesenterprise.BlockchainEvent.microBlockAppended: object expected");
                message.microBlockAppended = $root.wavesenterprise.MicroBlockAppended.fromObject(object.microBlockAppended);
            }
            if (object.blockAppended != null) {
                if (typeof object.blockAppended !== "object")
                    throw TypeError(".wavesenterprise.BlockchainEvent.blockAppended: object expected");
                message.blockAppended = $root.wavesenterprise.BlockAppended.fromObject(object.blockAppended);
            }
            if (object.rollbackCompleted != null) {
                if (typeof object.rollbackCompleted !== "object")
                    throw TypeError(".wavesenterprise.BlockchainEvent.rollbackCompleted: object expected");
                message.rollbackCompleted = $root.wavesenterprise.RollbackCompleted.fromObject(object.rollbackCompleted);
            }
            if (object.appendedBlockHistory != null) {
                if (typeof object.appendedBlockHistory !== "object")
                    throw TypeError(".wavesenterprise.BlockchainEvent.appendedBlockHistory: object expected");
                message.appendedBlockHistory = $root.wavesenterprise.AppendedBlockHistory.fromObject(object.appendedBlockHistory);
            }
            return message;
        };

        /**
         * Creates a plain object from a BlockchainEvent message. Also converts values to other types if specified.
         * @function toObject
         * @memberof wavesenterprise.BlockchainEvent
         * @static
         * @param {wavesenterprise.BlockchainEvent} message BlockchainEvent
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BlockchainEvent.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (message.microBlockAppended != null && message.hasOwnProperty("microBlockAppended")) {
                object.microBlockAppended = $root.wavesenterprise.MicroBlockAppended.toObject(message.microBlockAppended, options);
                if (options.oneofs)
                    object.blockchainEvent = "microBlockAppended";
            }
            if (message.blockAppended != null && message.hasOwnProperty("blockAppended")) {
                object.blockAppended = $root.wavesenterprise.BlockAppended.toObject(message.blockAppended, options);
                if (options.oneofs)
                    object.blockchainEvent = "blockAppended";
            }
            if (message.rollbackCompleted != null && message.hasOwnProperty("rollbackCompleted")) {
                object.rollbackCompleted = $root.wavesenterprise.RollbackCompleted.toObject(message.rollbackCompleted, options);
                if (options.oneofs)
                    object.blockchainEvent = "rollbackCompleted";
            }
            if (message.appendedBlockHistory != null && message.hasOwnProperty("appendedBlockHistory")) {
                object.appendedBlockHistory = $root.wavesenterprise.AppendedBlockHistory.toObject(message.appendedBlockHistory, options);
                if (options.oneofs)
                    object.blockchainEvent = "appendedBlockHistory";
            }
            return object;
        };

        /**
         * Converts this BlockchainEvent to JSON.
         * @function toJSON
         * @memberof wavesenterprise.BlockchainEvent
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BlockchainEvent.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BlockchainEvent;
    })();

    wavesenterprise.GenericError = (function() {

        /**
         * Properties of a GenericError.
         * @memberof wavesenterprise
         * @interface IGenericError
         */

        /**
         * Constructs a new GenericError.
         * @memberof wavesenterprise
         * @classdesc Represents a GenericError.
         * @implements IGenericError
         * @constructor
         * @param {wavesenterprise.IGenericError=} [properties] Properties to set
         */
        function GenericError(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new GenericError instance using the specified properties.
         * @function create
         * @memberof wavesenterprise.GenericError
         * @static
         * @param {wavesenterprise.IGenericError=} [properties] Properties to set
         * @returns {wavesenterprise.GenericError} GenericError instance
         */
        GenericError.create = function create(properties) {
            return new GenericError(properties);
        };

        /**
         * Encodes the specified GenericError message. Does not implicitly {@link wavesenterprise.GenericError.verify|verify} messages.
         * @function encode
         * @memberof wavesenterprise.GenericError
         * @static
         * @param {wavesenterprise.IGenericError} message GenericError message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GenericError.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified GenericError message, length delimited. Does not implicitly {@link wavesenterprise.GenericError.verify|verify} messages.
         * @function encodeDelimited
         * @memberof wavesenterprise.GenericError
         * @static
         * @param {wavesenterprise.IGenericError} message GenericError message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GenericError.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GenericError message from the specified reader or buffer.
         * @function decode
         * @memberof wavesenterprise.GenericError
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {wavesenterprise.GenericError} GenericError
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GenericError.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.wavesenterprise.GenericError();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GenericError message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof wavesenterprise.GenericError
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {wavesenterprise.GenericError} GenericError
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GenericError.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GenericError message.
         * @function verify
         * @memberof wavesenterprise.GenericError
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GenericError.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a GenericError message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof wavesenterprise.GenericError
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {wavesenterprise.GenericError} GenericError
         */
        GenericError.fromObject = function fromObject(object) {
            if (object instanceof $root.wavesenterprise.GenericError)
                return object;
            return new $root.wavesenterprise.GenericError();
        };

        /**
         * Creates a plain object from a GenericError message. Also converts values to other types if specified.
         * @function toObject
         * @memberof wavesenterprise.GenericError
         * @static
         * @param {wavesenterprise.GenericError} message GenericError
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GenericError.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this GenericError to JSON.
         * @function toJSON
         * @memberof wavesenterprise.GenericError
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GenericError.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GenericError;
    })();

    wavesenterprise.BlockSignatureNotFoundError = (function() {

        /**
         * Properties of a BlockSignatureNotFoundError.
         * @memberof wavesenterprise
         * @interface IBlockSignatureNotFoundError
         * @property {Uint8Array|null} [blockSignature] BlockSignatureNotFoundError blockSignature
         */

        /**
         * Constructs a new BlockSignatureNotFoundError.
         * @memberof wavesenterprise
         * @classdesc Represents a BlockSignatureNotFoundError.
         * @implements IBlockSignatureNotFoundError
         * @constructor
         * @param {wavesenterprise.IBlockSignatureNotFoundError=} [properties] Properties to set
         */
        function BlockSignatureNotFoundError(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BlockSignatureNotFoundError blockSignature.
         * @member {Uint8Array} blockSignature
         * @memberof wavesenterprise.BlockSignatureNotFoundError
         * @instance
         */
        BlockSignatureNotFoundError.prototype.blockSignature = $util.newBuffer([]);

        /**
         * Creates a new BlockSignatureNotFoundError instance using the specified properties.
         * @function create
         * @memberof wavesenterprise.BlockSignatureNotFoundError
         * @static
         * @param {wavesenterprise.IBlockSignatureNotFoundError=} [properties] Properties to set
         * @returns {wavesenterprise.BlockSignatureNotFoundError} BlockSignatureNotFoundError instance
         */
        BlockSignatureNotFoundError.create = function create(properties) {
            return new BlockSignatureNotFoundError(properties);
        };

        /**
         * Encodes the specified BlockSignatureNotFoundError message. Does not implicitly {@link wavesenterprise.BlockSignatureNotFoundError.verify|verify} messages.
         * @function encode
         * @memberof wavesenterprise.BlockSignatureNotFoundError
         * @static
         * @param {wavesenterprise.IBlockSignatureNotFoundError} message BlockSignatureNotFoundError message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BlockSignatureNotFoundError.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.blockSignature != null && Object.hasOwnProperty.call(message, "blockSignature"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.blockSignature);
            return writer;
        };

        /**
         * Encodes the specified BlockSignatureNotFoundError message, length delimited. Does not implicitly {@link wavesenterprise.BlockSignatureNotFoundError.verify|verify} messages.
         * @function encodeDelimited
         * @memberof wavesenterprise.BlockSignatureNotFoundError
         * @static
         * @param {wavesenterprise.IBlockSignatureNotFoundError} message BlockSignatureNotFoundError message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BlockSignatureNotFoundError.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BlockSignatureNotFoundError message from the specified reader or buffer.
         * @function decode
         * @memberof wavesenterprise.BlockSignatureNotFoundError
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {wavesenterprise.BlockSignatureNotFoundError} BlockSignatureNotFoundError
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BlockSignatureNotFoundError.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.wavesenterprise.BlockSignatureNotFoundError();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.blockSignature = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BlockSignatureNotFoundError message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof wavesenterprise.BlockSignatureNotFoundError
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {wavesenterprise.BlockSignatureNotFoundError} BlockSignatureNotFoundError
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BlockSignatureNotFoundError.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BlockSignatureNotFoundError message.
         * @function verify
         * @memberof wavesenterprise.BlockSignatureNotFoundError
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BlockSignatureNotFoundError.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.blockSignature != null && message.hasOwnProperty("blockSignature"))
                if (!(message.blockSignature && typeof message.blockSignature.length === "number" || $util.isString(message.blockSignature)))
                    return "blockSignature: buffer expected";
            return null;
        };

        /**
         * Creates a BlockSignatureNotFoundError message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof wavesenterprise.BlockSignatureNotFoundError
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {wavesenterprise.BlockSignatureNotFoundError} BlockSignatureNotFoundError
         */
        BlockSignatureNotFoundError.fromObject = function fromObject(object) {
            if (object instanceof $root.wavesenterprise.BlockSignatureNotFoundError)
                return object;
            var message = new $root.wavesenterprise.BlockSignatureNotFoundError();
            if (object.blockSignature != null)
                if (typeof object.blockSignature === "string")
                    $util.base64.decode(object.blockSignature, message.blockSignature = $util.newBuffer($util.base64.length(object.blockSignature)), 0);
                else if (object.blockSignature.length)
                    message.blockSignature = object.blockSignature;
            return message;
        };

        /**
         * Creates a plain object from a BlockSignatureNotFoundError message. Also converts values to other types if specified.
         * @function toObject
         * @memberof wavesenterprise.BlockSignatureNotFoundError
         * @static
         * @param {wavesenterprise.BlockSignatureNotFoundError} message BlockSignatureNotFoundError
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BlockSignatureNotFoundError.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.blockSignature = "";
                else {
                    object.blockSignature = [];
                    if (options.bytes !== Array)
                        object.blockSignature = $util.newBuffer(object.blockSignature);
                }
            if (message.blockSignature != null && message.hasOwnProperty("blockSignature"))
                object.blockSignature = options.bytes === String ? $util.base64.encode(message.blockSignature, 0, message.blockSignature.length) : options.bytes === Array ? Array.prototype.slice.call(message.blockSignature) : message.blockSignature;
            return object;
        };

        /**
         * Converts this BlockSignatureNotFoundError to JSON.
         * @function toJSON
         * @memberof wavesenterprise.BlockSignatureNotFoundError
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BlockSignatureNotFoundError.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BlockSignatureNotFoundError;
    })();

    wavesenterprise.MissingRequiredRequestField = (function() {

        /**
         * Properties of a MissingRequiredRequestField.
         * @memberof wavesenterprise
         * @interface IMissingRequiredRequestField
         */

        /**
         * Constructs a new MissingRequiredRequestField.
         * @memberof wavesenterprise
         * @classdesc Represents a MissingRequiredRequestField.
         * @implements IMissingRequiredRequestField
         * @constructor
         * @param {wavesenterprise.IMissingRequiredRequestField=} [properties] Properties to set
         */
        function MissingRequiredRequestField(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new MissingRequiredRequestField instance using the specified properties.
         * @function create
         * @memberof wavesenterprise.MissingRequiredRequestField
         * @static
         * @param {wavesenterprise.IMissingRequiredRequestField=} [properties] Properties to set
         * @returns {wavesenterprise.MissingRequiredRequestField} MissingRequiredRequestField instance
         */
        MissingRequiredRequestField.create = function create(properties) {
            return new MissingRequiredRequestField(properties);
        };

        /**
         * Encodes the specified MissingRequiredRequestField message. Does not implicitly {@link wavesenterprise.MissingRequiredRequestField.verify|verify} messages.
         * @function encode
         * @memberof wavesenterprise.MissingRequiredRequestField
         * @static
         * @param {wavesenterprise.IMissingRequiredRequestField} message MissingRequiredRequestField message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MissingRequiredRequestField.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified MissingRequiredRequestField message, length delimited. Does not implicitly {@link wavesenterprise.MissingRequiredRequestField.verify|verify} messages.
         * @function encodeDelimited
         * @memberof wavesenterprise.MissingRequiredRequestField
         * @static
         * @param {wavesenterprise.IMissingRequiredRequestField} message MissingRequiredRequestField message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MissingRequiredRequestField.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MissingRequiredRequestField message from the specified reader or buffer.
         * @function decode
         * @memberof wavesenterprise.MissingRequiredRequestField
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {wavesenterprise.MissingRequiredRequestField} MissingRequiredRequestField
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MissingRequiredRequestField.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.wavesenterprise.MissingRequiredRequestField();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MissingRequiredRequestField message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof wavesenterprise.MissingRequiredRequestField
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {wavesenterprise.MissingRequiredRequestField} MissingRequiredRequestField
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MissingRequiredRequestField.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MissingRequiredRequestField message.
         * @function verify
         * @memberof wavesenterprise.MissingRequiredRequestField
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MissingRequiredRequestField.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a MissingRequiredRequestField message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof wavesenterprise.MissingRequiredRequestField
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {wavesenterprise.MissingRequiredRequestField} MissingRequiredRequestField
         */
        MissingRequiredRequestField.fromObject = function fromObject(object) {
            if (object instanceof $root.wavesenterprise.MissingRequiredRequestField)
                return object;
            return new $root.wavesenterprise.MissingRequiredRequestField();
        };

        /**
         * Creates a plain object from a MissingRequiredRequestField message. Also converts values to other types if specified.
         * @function toObject
         * @memberof wavesenterprise.MissingRequiredRequestField
         * @static
         * @param {wavesenterprise.MissingRequiredRequestField} message MissingRequiredRequestField
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MissingRequiredRequestField.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this MissingRequiredRequestField to JSON.
         * @function toJSON
         * @memberof wavesenterprise.MissingRequiredRequestField
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MissingRequiredRequestField.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MissingRequiredRequestField;
    })();

    wavesenterprise.MissingAuthorizationMetadata = (function() {

        /**
         * Properties of a MissingAuthorizationMetadata.
         * @memberof wavesenterprise
         * @interface IMissingAuthorizationMetadata
         */

        /**
         * Constructs a new MissingAuthorizationMetadata.
         * @memberof wavesenterprise
         * @classdesc Represents a MissingAuthorizationMetadata.
         * @implements IMissingAuthorizationMetadata
         * @constructor
         * @param {wavesenterprise.IMissingAuthorizationMetadata=} [properties] Properties to set
         */
        function MissingAuthorizationMetadata(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new MissingAuthorizationMetadata instance using the specified properties.
         * @function create
         * @memberof wavesenterprise.MissingAuthorizationMetadata
         * @static
         * @param {wavesenterprise.IMissingAuthorizationMetadata=} [properties] Properties to set
         * @returns {wavesenterprise.MissingAuthorizationMetadata} MissingAuthorizationMetadata instance
         */
        MissingAuthorizationMetadata.create = function create(properties) {
            return new MissingAuthorizationMetadata(properties);
        };

        /**
         * Encodes the specified MissingAuthorizationMetadata message. Does not implicitly {@link wavesenterprise.MissingAuthorizationMetadata.verify|verify} messages.
         * @function encode
         * @memberof wavesenterprise.MissingAuthorizationMetadata
         * @static
         * @param {wavesenterprise.IMissingAuthorizationMetadata} message MissingAuthorizationMetadata message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MissingAuthorizationMetadata.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified MissingAuthorizationMetadata message, length delimited. Does not implicitly {@link wavesenterprise.MissingAuthorizationMetadata.verify|verify} messages.
         * @function encodeDelimited
         * @memberof wavesenterprise.MissingAuthorizationMetadata
         * @static
         * @param {wavesenterprise.IMissingAuthorizationMetadata} message MissingAuthorizationMetadata message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MissingAuthorizationMetadata.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MissingAuthorizationMetadata message from the specified reader or buffer.
         * @function decode
         * @memberof wavesenterprise.MissingAuthorizationMetadata
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {wavesenterprise.MissingAuthorizationMetadata} MissingAuthorizationMetadata
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MissingAuthorizationMetadata.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.wavesenterprise.MissingAuthorizationMetadata();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MissingAuthorizationMetadata message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof wavesenterprise.MissingAuthorizationMetadata
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {wavesenterprise.MissingAuthorizationMetadata} MissingAuthorizationMetadata
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MissingAuthorizationMetadata.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MissingAuthorizationMetadata message.
         * @function verify
         * @memberof wavesenterprise.MissingAuthorizationMetadata
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MissingAuthorizationMetadata.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a MissingAuthorizationMetadata message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof wavesenterprise.MissingAuthorizationMetadata
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {wavesenterprise.MissingAuthorizationMetadata} MissingAuthorizationMetadata
         */
        MissingAuthorizationMetadata.fromObject = function fromObject(object) {
            if (object instanceof $root.wavesenterprise.MissingAuthorizationMetadata)
                return object;
            return new $root.wavesenterprise.MissingAuthorizationMetadata();
        };

        /**
         * Creates a plain object from a MissingAuthorizationMetadata message. Also converts values to other types if specified.
         * @function toObject
         * @memberof wavesenterprise.MissingAuthorizationMetadata
         * @static
         * @param {wavesenterprise.MissingAuthorizationMetadata} message MissingAuthorizationMetadata
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MissingAuthorizationMetadata.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this MissingAuthorizationMetadata to JSON.
         * @function toJSON
         * @memberof wavesenterprise.MissingAuthorizationMetadata
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MissingAuthorizationMetadata.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MissingAuthorizationMetadata;
    })();

    wavesenterprise.InvalidApiKey = (function() {

        /**
         * Properties of an InvalidApiKey.
         * @memberof wavesenterprise
         * @interface IInvalidApiKey
         */

        /**
         * Constructs a new InvalidApiKey.
         * @memberof wavesenterprise
         * @classdesc Represents an InvalidApiKey.
         * @implements IInvalidApiKey
         * @constructor
         * @param {wavesenterprise.IInvalidApiKey=} [properties] Properties to set
         */
        function InvalidApiKey(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new InvalidApiKey instance using the specified properties.
         * @function create
         * @memberof wavesenterprise.InvalidApiKey
         * @static
         * @param {wavesenterprise.IInvalidApiKey=} [properties] Properties to set
         * @returns {wavesenterprise.InvalidApiKey} InvalidApiKey instance
         */
        InvalidApiKey.create = function create(properties) {
            return new InvalidApiKey(properties);
        };

        /**
         * Encodes the specified InvalidApiKey message. Does not implicitly {@link wavesenterprise.InvalidApiKey.verify|verify} messages.
         * @function encode
         * @memberof wavesenterprise.InvalidApiKey
         * @static
         * @param {wavesenterprise.IInvalidApiKey} message InvalidApiKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InvalidApiKey.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified InvalidApiKey message, length delimited. Does not implicitly {@link wavesenterprise.InvalidApiKey.verify|verify} messages.
         * @function encodeDelimited
         * @memberof wavesenterprise.InvalidApiKey
         * @static
         * @param {wavesenterprise.IInvalidApiKey} message InvalidApiKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InvalidApiKey.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an InvalidApiKey message from the specified reader or buffer.
         * @function decode
         * @memberof wavesenterprise.InvalidApiKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {wavesenterprise.InvalidApiKey} InvalidApiKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InvalidApiKey.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.wavesenterprise.InvalidApiKey();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an InvalidApiKey message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof wavesenterprise.InvalidApiKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {wavesenterprise.InvalidApiKey} InvalidApiKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InvalidApiKey.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an InvalidApiKey message.
         * @function verify
         * @memberof wavesenterprise.InvalidApiKey
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        InvalidApiKey.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates an InvalidApiKey message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof wavesenterprise.InvalidApiKey
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {wavesenterprise.InvalidApiKey} InvalidApiKey
         */
        InvalidApiKey.fromObject = function fromObject(object) {
            if (object instanceof $root.wavesenterprise.InvalidApiKey)
                return object;
            return new $root.wavesenterprise.InvalidApiKey();
        };

        /**
         * Creates a plain object from an InvalidApiKey message. Also converts values to other types if specified.
         * @function toObject
         * @memberof wavesenterprise.InvalidApiKey
         * @static
         * @param {wavesenterprise.InvalidApiKey} message InvalidApiKey
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        InvalidApiKey.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this InvalidApiKey to JSON.
         * @function toJSON
         * @memberof wavesenterprise.InvalidApiKey
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        InvalidApiKey.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return InvalidApiKey;
    })();

    wavesenterprise.InvalidToken = (function() {

        /**
         * Properties of an InvalidToken.
         * @memberof wavesenterprise
         * @interface IInvalidToken
         */

        /**
         * Constructs a new InvalidToken.
         * @memberof wavesenterprise
         * @classdesc Represents an InvalidToken.
         * @implements IInvalidToken
         * @constructor
         * @param {wavesenterprise.IInvalidToken=} [properties] Properties to set
         */
        function InvalidToken(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new InvalidToken instance using the specified properties.
         * @function create
         * @memberof wavesenterprise.InvalidToken
         * @static
         * @param {wavesenterprise.IInvalidToken=} [properties] Properties to set
         * @returns {wavesenterprise.InvalidToken} InvalidToken instance
         */
        InvalidToken.create = function create(properties) {
            return new InvalidToken(properties);
        };

        /**
         * Encodes the specified InvalidToken message. Does not implicitly {@link wavesenterprise.InvalidToken.verify|verify} messages.
         * @function encode
         * @memberof wavesenterprise.InvalidToken
         * @static
         * @param {wavesenterprise.IInvalidToken} message InvalidToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InvalidToken.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified InvalidToken message, length delimited. Does not implicitly {@link wavesenterprise.InvalidToken.verify|verify} messages.
         * @function encodeDelimited
         * @memberof wavesenterprise.InvalidToken
         * @static
         * @param {wavesenterprise.IInvalidToken} message InvalidToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InvalidToken.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an InvalidToken message from the specified reader or buffer.
         * @function decode
         * @memberof wavesenterprise.InvalidToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {wavesenterprise.InvalidToken} InvalidToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InvalidToken.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.wavesenterprise.InvalidToken();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an InvalidToken message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof wavesenterprise.InvalidToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {wavesenterprise.InvalidToken} InvalidToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InvalidToken.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an InvalidToken message.
         * @function verify
         * @memberof wavesenterprise.InvalidToken
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        InvalidToken.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates an InvalidToken message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof wavesenterprise.InvalidToken
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {wavesenterprise.InvalidToken} InvalidToken
         */
        InvalidToken.fromObject = function fromObject(object) {
            if (object instanceof $root.wavesenterprise.InvalidToken)
                return object;
            return new $root.wavesenterprise.InvalidToken();
        };

        /**
         * Creates a plain object from an InvalidToken message. Also converts values to other types if specified.
         * @function toObject
         * @memberof wavesenterprise.InvalidToken
         * @static
         * @param {wavesenterprise.InvalidToken} message InvalidToken
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        InvalidToken.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this InvalidToken to JSON.
         * @function toJSON
         * @memberof wavesenterprise.InvalidToken
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        InvalidToken.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return InvalidToken;
    })();

    wavesenterprise.MicroBlockAppended = (function() {

        /**
         * Properties of a MicroBlockAppended.
         * @memberof wavesenterprise
         * @interface IMicroBlockAppended
         * @property {Array.<wavesenterprise.ITransaction>|null} [txs] MicroBlockAppended txs
         */

        /**
         * Constructs a new MicroBlockAppended.
         * @memberof wavesenterprise
         * @classdesc Represents a MicroBlockAppended.
         * @implements IMicroBlockAppended
         * @constructor
         * @param {wavesenterprise.IMicroBlockAppended=} [properties] Properties to set
         */
        function MicroBlockAppended(properties) {
            this.txs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MicroBlockAppended txs.
         * @member {Array.<wavesenterprise.ITransaction>} txs
         * @memberof wavesenterprise.MicroBlockAppended
         * @instance
         */
        MicroBlockAppended.prototype.txs = $util.emptyArray;

        /**
         * Creates a new MicroBlockAppended instance using the specified properties.
         * @function create
         * @memberof wavesenterprise.MicroBlockAppended
         * @static
         * @param {wavesenterprise.IMicroBlockAppended=} [properties] Properties to set
         * @returns {wavesenterprise.MicroBlockAppended} MicroBlockAppended instance
         */
        MicroBlockAppended.create = function create(properties) {
            return new MicroBlockAppended(properties);
        };

        /**
         * Encodes the specified MicroBlockAppended message. Does not implicitly {@link wavesenterprise.MicroBlockAppended.verify|verify} messages.
         * @function encode
         * @memberof wavesenterprise.MicroBlockAppended
         * @static
         * @param {wavesenterprise.IMicroBlockAppended} message MicroBlockAppended message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MicroBlockAppended.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.txs != null && message.txs.length)
                for (var i = 0; i < message.txs.length; ++i)
                    $root.wavesenterprise.Transaction.encode(message.txs[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified MicroBlockAppended message, length delimited. Does not implicitly {@link wavesenterprise.MicroBlockAppended.verify|verify} messages.
         * @function encodeDelimited
         * @memberof wavesenterprise.MicroBlockAppended
         * @static
         * @param {wavesenterprise.IMicroBlockAppended} message MicroBlockAppended message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MicroBlockAppended.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MicroBlockAppended message from the specified reader or buffer.
         * @function decode
         * @memberof wavesenterprise.MicroBlockAppended
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {wavesenterprise.MicroBlockAppended} MicroBlockAppended
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MicroBlockAppended.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.wavesenterprise.MicroBlockAppended();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.txs && message.txs.length))
                        message.txs = [];
                    message.txs.push($root.wavesenterprise.Transaction.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MicroBlockAppended message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof wavesenterprise.MicroBlockAppended
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {wavesenterprise.MicroBlockAppended} MicroBlockAppended
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MicroBlockAppended.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MicroBlockAppended message.
         * @function verify
         * @memberof wavesenterprise.MicroBlockAppended
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MicroBlockAppended.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.txs != null && message.hasOwnProperty("txs")) {
                if (!Array.isArray(message.txs))
                    return "txs: array expected";
                for (var i = 0; i < message.txs.length; ++i) {
                    var error = $root.wavesenterprise.Transaction.verify(message.txs[i]);
                    if (error)
                        return "txs." + error;
                }
            }
            return null;
        };

        /**
         * Creates a MicroBlockAppended message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof wavesenterprise.MicroBlockAppended
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {wavesenterprise.MicroBlockAppended} MicroBlockAppended
         */
        MicroBlockAppended.fromObject = function fromObject(object) {
            if (object instanceof $root.wavesenterprise.MicroBlockAppended)
                return object;
            var message = new $root.wavesenterprise.MicroBlockAppended();
            if (object.txs) {
                if (!Array.isArray(object.txs))
                    throw TypeError(".wavesenterprise.MicroBlockAppended.txs: array expected");
                message.txs = [];
                for (var i = 0; i < object.txs.length; ++i) {
                    if (typeof object.txs[i] !== "object")
                        throw TypeError(".wavesenterprise.MicroBlockAppended.txs: object expected");
                    message.txs[i] = $root.wavesenterprise.Transaction.fromObject(object.txs[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a MicroBlockAppended message. Also converts values to other types if specified.
         * @function toObject
         * @memberof wavesenterprise.MicroBlockAppended
         * @static
         * @param {wavesenterprise.MicroBlockAppended} message MicroBlockAppended
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MicroBlockAppended.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.txs = [];
            if (message.txs && message.txs.length) {
                object.txs = [];
                for (var j = 0; j < message.txs.length; ++j)
                    object.txs[j] = $root.wavesenterprise.Transaction.toObject(message.txs[j], options);
            }
            return object;
        };

        /**
         * Converts this MicroBlockAppended to JSON.
         * @function toJSON
         * @memberof wavesenterprise.MicroBlockAppended
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MicroBlockAppended.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MicroBlockAppended;
    })();

    wavesenterprise.BlockAppended = (function() {

        /**
         * Properties of a BlockAppended.
         * @memberof wavesenterprise
         * @interface IBlockAppended
         * @property {Uint8Array|null} [blockSignature] BlockAppended blockSignature
         * @property {Uint8Array|null} [reference] BlockAppended reference
         * @property {Array.<Uint8Array>|null} [txIds] BlockAppended txIds
         * @property {Uint8Array|null} [minerAddress] BlockAppended minerAddress
         * @property {number|Long|null} [height] BlockAppended height
         * @property {number|null} [version] BlockAppended version
         * @property {number|Long|null} [timestamp] BlockAppended timestamp
         * @property {number|Long|null} [fee] BlockAppended fee
         * @property {number|null} [blockSize] BlockAppended blockSize
         * @property {Array.<number>|null} [features] BlockAppended features
         */

        /**
         * Constructs a new BlockAppended.
         * @memberof wavesenterprise
         * @classdesc Represents a BlockAppended.
         * @implements IBlockAppended
         * @constructor
         * @param {wavesenterprise.IBlockAppended=} [properties] Properties to set
         */
        function BlockAppended(properties) {
            this.txIds = [];
            this.features = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BlockAppended blockSignature.
         * @member {Uint8Array} blockSignature
         * @memberof wavesenterprise.BlockAppended
         * @instance
         */
        BlockAppended.prototype.blockSignature = $util.newBuffer([]);

        /**
         * BlockAppended reference.
         * @member {Uint8Array} reference
         * @memberof wavesenterprise.BlockAppended
         * @instance
         */
        BlockAppended.prototype.reference = $util.newBuffer([]);

        /**
         * BlockAppended txIds.
         * @member {Array.<Uint8Array>} txIds
         * @memberof wavesenterprise.BlockAppended
         * @instance
         */
        BlockAppended.prototype.txIds = $util.emptyArray;

        /**
         * BlockAppended minerAddress.
         * @member {Uint8Array} minerAddress
         * @memberof wavesenterprise.BlockAppended
         * @instance
         */
        BlockAppended.prototype.minerAddress = $util.newBuffer([]);

        /**
         * BlockAppended height.
         * @member {number|Long} height
         * @memberof wavesenterprise.BlockAppended
         * @instance
         */
        BlockAppended.prototype.height = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * BlockAppended version.
         * @member {number} version
         * @memberof wavesenterprise.BlockAppended
         * @instance
         */
        BlockAppended.prototype.version = 0;

        /**
         * BlockAppended timestamp.
         * @member {number|Long} timestamp
         * @memberof wavesenterprise.BlockAppended
         * @instance
         */
        BlockAppended.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * BlockAppended fee.
         * @member {number|Long} fee
         * @memberof wavesenterprise.BlockAppended
         * @instance
         */
        BlockAppended.prototype.fee = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * BlockAppended blockSize.
         * @member {number} blockSize
         * @memberof wavesenterprise.BlockAppended
         * @instance
         */
        BlockAppended.prototype.blockSize = 0;

        /**
         * BlockAppended features.
         * @member {Array.<number>} features
         * @memberof wavesenterprise.BlockAppended
         * @instance
         */
        BlockAppended.prototype.features = $util.emptyArray;

        /**
         * Creates a new BlockAppended instance using the specified properties.
         * @function create
         * @memberof wavesenterprise.BlockAppended
         * @static
         * @param {wavesenterprise.IBlockAppended=} [properties] Properties to set
         * @returns {wavesenterprise.BlockAppended} BlockAppended instance
         */
        BlockAppended.create = function create(properties) {
            return new BlockAppended(properties);
        };

        /**
         * Encodes the specified BlockAppended message. Does not implicitly {@link wavesenterprise.BlockAppended.verify|verify} messages.
         * @function encode
         * @memberof wavesenterprise.BlockAppended
         * @static
         * @param {wavesenterprise.IBlockAppended} message BlockAppended message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BlockAppended.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.blockSignature != null && Object.hasOwnProperty.call(message, "blockSignature"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.blockSignature);
            if (message.reference != null && Object.hasOwnProperty.call(message, "reference"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.reference);
            if (message.txIds != null && message.txIds.length)
                for (var i = 0; i < message.txIds.length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.txIds[i]);
            if (message.minerAddress != null && Object.hasOwnProperty.call(message, "minerAddress"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.minerAddress);
            if (message.height != null && Object.hasOwnProperty.call(message, "height"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.height);
            if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.version);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.timestamp);
            if (message.fee != null && Object.hasOwnProperty.call(message, "fee"))
                writer.uint32(/* id 8, wireType 0 =*/64).int64(message.fee);
            if (message.blockSize != null && Object.hasOwnProperty.call(message, "blockSize"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.blockSize);
            if (message.features != null && message.features.length) {
                writer.uint32(/* id 10, wireType 2 =*/82).fork();
                for (var i = 0; i < message.features.length; ++i)
                    writer.int32(message.features[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified BlockAppended message, length delimited. Does not implicitly {@link wavesenterprise.BlockAppended.verify|verify} messages.
         * @function encodeDelimited
         * @memberof wavesenterprise.BlockAppended
         * @static
         * @param {wavesenterprise.IBlockAppended} message BlockAppended message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BlockAppended.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BlockAppended message from the specified reader or buffer.
         * @function decode
         * @memberof wavesenterprise.BlockAppended
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {wavesenterprise.BlockAppended} BlockAppended
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BlockAppended.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.wavesenterprise.BlockAppended();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.blockSignature = reader.bytes();
                    break;
                case 2:
                    message.reference = reader.bytes();
                    break;
                case 3:
                    if (!(message.txIds && message.txIds.length))
                        message.txIds = [];
                    message.txIds.push(reader.bytes());
                    break;
                case 4:
                    message.minerAddress = reader.bytes();
                    break;
                case 5:
                    message.height = reader.int64();
                    break;
                case 6:
                    message.version = reader.int32();
                    break;
                case 7:
                    message.timestamp = reader.int64();
                    break;
                case 8:
                    message.fee = reader.int64();
                    break;
                case 9:
                    message.blockSize = reader.int32();
                    break;
                case 10:
                    if (!(message.features && message.features.length))
                        message.features = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.features.push(reader.int32());
                    } else
                        message.features.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BlockAppended message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof wavesenterprise.BlockAppended
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {wavesenterprise.BlockAppended} BlockAppended
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BlockAppended.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BlockAppended message.
         * @function verify
         * @memberof wavesenterprise.BlockAppended
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BlockAppended.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.blockSignature != null && message.hasOwnProperty("blockSignature"))
                if (!(message.blockSignature && typeof message.blockSignature.length === "number" || $util.isString(message.blockSignature)))
                    return "blockSignature: buffer expected";
            if (message.reference != null && message.hasOwnProperty("reference"))
                if (!(message.reference && typeof message.reference.length === "number" || $util.isString(message.reference)))
                    return "reference: buffer expected";
            if (message.txIds != null && message.hasOwnProperty("txIds")) {
                if (!Array.isArray(message.txIds))
                    return "txIds: array expected";
                for (var i = 0; i < message.txIds.length; ++i)
                    if (!(message.txIds[i] && typeof message.txIds[i].length === "number" || $util.isString(message.txIds[i])))
                        return "txIds: buffer[] expected";
            }
            if (message.minerAddress != null && message.hasOwnProperty("minerAddress"))
                if (!(message.minerAddress && typeof message.minerAddress.length === "number" || $util.isString(message.minerAddress)))
                    return "minerAddress: buffer expected";
            if (message.height != null && message.hasOwnProperty("height"))
                if (!$util.isInteger(message.height) && !(message.height && $util.isInteger(message.height.low) && $util.isInteger(message.height.high)))
                    return "height: integer|Long expected";
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isInteger(message.version))
                    return "version: integer expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            if (message.fee != null && message.hasOwnProperty("fee"))
                if (!$util.isInteger(message.fee) && !(message.fee && $util.isInteger(message.fee.low) && $util.isInteger(message.fee.high)))
                    return "fee: integer|Long expected";
            if (message.blockSize != null && message.hasOwnProperty("blockSize"))
                if (!$util.isInteger(message.blockSize))
                    return "blockSize: integer expected";
            if (message.features != null && message.hasOwnProperty("features")) {
                if (!Array.isArray(message.features))
                    return "features: array expected";
                for (var i = 0; i < message.features.length; ++i)
                    if (!$util.isInteger(message.features[i]))
                        return "features: integer[] expected";
            }
            return null;
        };

        /**
         * Creates a BlockAppended message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof wavesenterprise.BlockAppended
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {wavesenterprise.BlockAppended} BlockAppended
         */
        BlockAppended.fromObject = function fromObject(object) {
            if (object instanceof $root.wavesenterprise.BlockAppended)
                return object;
            var message = new $root.wavesenterprise.BlockAppended();
            if (object.blockSignature != null)
                if (typeof object.blockSignature === "string")
                    $util.base64.decode(object.blockSignature, message.blockSignature = $util.newBuffer($util.base64.length(object.blockSignature)), 0);
                else if (object.blockSignature.length)
                    message.blockSignature = object.blockSignature;
            if (object.reference != null)
                if (typeof object.reference === "string")
                    $util.base64.decode(object.reference, message.reference = $util.newBuffer($util.base64.length(object.reference)), 0);
                else if (object.reference.length)
                    message.reference = object.reference;
            if (object.txIds) {
                if (!Array.isArray(object.txIds))
                    throw TypeError(".wavesenterprise.BlockAppended.txIds: array expected");
                message.txIds = [];
                for (var i = 0; i < object.txIds.length; ++i)
                    if (typeof object.txIds[i] === "string")
                        $util.base64.decode(object.txIds[i], message.txIds[i] = $util.newBuffer($util.base64.length(object.txIds[i])), 0);
                    else if (object.txIds[i].length)
                        message.txIds[i] = object.txIds[i];
            }
            if (object.minerAddress != null)
                if (typeof object.minerAddress === "string")
                    $util.base64.decode(object.minerAddress, message.minerAddress = $util.newBuffer($util.base64.length(object.minerAddress)), 0);
                else if (object.minerAddress.length)
                    message.minerAddress = object.minerAddress;
            if (object.height != null)
                if ($util.Long)
                    (message.height = $util.Long.fromValue(object.height)).unsigned = false;
                else if (typeof object.height === "string")
                    message.height = parseInt(object.height, 10);
                else if (typeof object.height === "number")
                    message.height = object.height;
                else if (typeof object.height === "object")
                    message.height = new $util.LongBits(object.height.low >>> 0, object.height.high >>> 0).toNumber();
            if (object.version != null)
                message.version = object.version | 0;
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            if (object.fee != null)
                if ($util.Long)
                    (message.fee = $util.Long.fromValue(object.fee)).unsigned = false;
                else if (typeof object.fee === "string")
                    message.fee = parseInt(object.fee, 10);
                else if (typeof object.fee === "number")
                    message.fee = object.fee;
                else if (typeof object.fee === "object")
                    message.fee = new $util.LongBits(object.fee.low >>> 0, object.fee.high >>> 0).toNumber();
            if (object.blockSize != null)
                message.blockSize = object.blockSize | 0;
            if (object.features) {
                if (!Array.isArray(object.features))
                    throw TypeError(".wavesenterprise.BlockAppended.features: array expected");
                message.features = [];
                for (var i = 0; i < object.features.length; ++i)
                    message.features[i] = object.features[i] | 0;
            }
            return message;
        };

        /**
         * Creates a plain object from a BlockAppended message. Also converts values to other types if specified.
         * @function toObject
         * @memberof wavesenterprise.BlockAppended
         * @static
         * @param {wavesenterprise.BlockAppended} message BlockAppended
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BlockAppended.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.txIds = [];
                object.features = [];
            }
            if (options.defaults) {
                if (options.bytes === String)
                    object.blockSignature = "";
                else {
                    object.blockSignature = [];
                    if (options.bytes !== Array)
                        object.blockSignature = $util.newBuffer(object.blockSignature);
                }
                if (options.bytes === String)
                    object.reference = "";
                else {
                    object.reference = [];
                    if (options.bytes !== Array)
                        object.reference = $util.newBuffer(object.reference);
                }
                if (options.bytes === String)
                    object.minerAddress = "";
                else {
                    object.minerAddress = [];
                    if (options.bytes !== Array)
                        object.minerAddress = $util.newBuffer(object.minerAddress);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.height = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.height = options.longs === String ? "0" : 0;
                object.version = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.fee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.fee = options.longs === String ? "0" : 0;
                object.blockSize = 0;
            }
            if (message.blockSignature != null && message.hasOwnProperty("blockSignature"))
                object.blockSignature = options.bytes === String ? $util.base64.encode(message.blockSignature, 0, message.blockSignature.length) : options.bytes === Array ? Array.prototype.slice.call(message.blockSignature) : message.blockSignature;
            if (message.reference != null && message.hasOwnProperty("reference"))
                object.reference = options.bytes === String ? $util.base64.encode(message.reference, 0, message.reference.length) : options.bytes === Array ? Array.prototype.slice.call(message.reference) : message.reference;
            if (message.txIds && message.txIds.length) {
                object.txIds = [];
                for (var j = 0; j < message.txIds.length; ++j)
                    object.txIds[j] = options.bytes === String ? $util.base64.encode(message.txIds[j], 0, message.txIds[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.txIds[j]) : message.txIds[j];
            }
            if (message.minerAddress != null && message.hasOwnProperty("minerAddress"))
                object.minerAddress = options.bytes === String ? $util.base64.encode(message.minerAddress, 0, message.minerAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.minerAddress) : message.minerAddress;
            if (message.height != null && message.hasOwnProperty("height"))
                if (typeof message.height === "number")
                    object.height = options.longs === String ? String(message.height) : message.height;
                else
                    object.height = options.longs === String ? $util.Long.prototype.toString.call(message.height) : options.longs === Number ? new $util.LongBits(message.height.low >>> 0, message.height.high >>> 0).toNumber() : message.height;
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            if (message.fee != null && message.hasOwnProperty("fee"))
                if (typeof message.fee === "number")
                    object.fee = options.longs === String ? String(message.fee) : message.fee;
                else
                    object.fee = options.longs === String ? $util.Long.prototype.toString.call(message.fee) : options.longs === Number ? new $util.LongBits(message.fee.low >>> 0, message.fee.high >>> 0).toNumber() : message.fee;
            if (message.blockSize != null && message.hasOwnProperty("blockSize"))
                object.blockSize = message.blockSize;
            if (message.features && message.features.length) {
                object.features = [];
                for (var j = 0; j < message.features.length; ++j)
                    object.features[j] = message.features[j];
            }
            return object;
        };

        /**
         * Converts this BlockAppended to JSON.
         * @function toJSON
         * @memberof wavesenterprise.BlockAppended
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BlockAppended.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BlockAppended;
    })();

    wavesenterprise.RollbackCompleted = (function() {

        /**
         * Properties of a RollbackCompleted.
         * @memberof wavesenterprise
         * @interface IRollbackCompleted
         * @property {Uint8Array|null} [returnToBlockSignature] RollbackCompleted returnToBlockSignature
         * @property {Array.<Uint8Array>|null} [rollbackTxIds] RollbackCompleted rollbackTxIds
         */

        /**
         * Constructs a new RollbackCompleted.
         * @memberof wavesenterprise
         * @classdesc Represents a RollbackCompleted.
         * @implements IRollbackCompleted
         * @constructor
         * @param {wavesenterprise.IRollbackCompleted=} [properties] Properties to set
         */
        function RollbackCompleted(properties) {
            this.rollbackTxIds = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RollbackCompleted returnToBlockSignature.
         * @member {Uint8Array} returnToBlockSignature
         * @memberof wavesenterprise.RollbackCompleted
         * @instance
         */
        RollbackCompleted.prototype.returnToBlockSignature = $util.newBuffer([]);

        /**
         * RollbackCompleted rollbackTxIds.
         * @member {Array.<Uint8Array>} rollbackTxIds
         * @memberof wavesenterprise.RollbackCompleted
         * @instance
         */
        RollbackCompleted.prototype.rollbackTxIds = $util.emptyArray;

        /**
         * Creates a new RollbackCompleted instance using the specified properties.
         * @function create
         * @memberof wavesenterprise.RollbackCompleted
         * @static
         * @param {wavesenterprise.IRollbackCompleted=} [properties] Properties to set
         * @returns {wavesenterprise.RollbackCompleted} RollbackCompleted instance
         */
        RollbackCompleted.create = function create(properties) {
            return new RollbackCompleted(properties);
        };

        /**
         * Encodes the specified RollbackCompleted message. Does not implicitly {@link wavesenterprise.RollbackCompleted.verify|verify} messages.
         * @function encode
         * @memberof wavesenterprise.RollbackCompleted
         * @static
         * @param {wavesenterprise.IRollbackCompleted} message RollbackCompleted message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RollbackCompleted.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.returnToBlockSignature != null && Object.hasOwnProperty.call(message, "returnToBlockSignature"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.returnToBlockSignature);
            if (message.rollbackTxIds != null && message.rollbackTxIds.length)
                for (var i = 0; i < message.rollbackTxIds.length; ++i)
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.rollbackTxIds[i]);
            return writer;
        };

        /**
         * Encodes the specified RollbackCompleted message, length delimited. Does not implicitly {@link wavesenterprise.RollbackCompleted.verify|verify} messages.
         * @function encodeDelimited
         * @memberof wavesenterprise.RollbackCompleted
         * @static
         * @param {wavesenterprise.IRollbackCompleted} message RollbackCompleted message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RollbackCompleted.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RollbackCompleted message from the specified reader or buffer.
         * @function decode
         * @memberof wavesenterprise.RollbackCompleted
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {wavesenterprise.RollbackCompleted} RollbackCompleted
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RollbackCompleted.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.wavesenterprise.RollbackCompleted();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.returnToBlockSignature = reader.bytes();
                    break;
                case 2:
                    if (!(message.rollbackTxIds && message.rollbackTxIds.length))
                        message.rollbackTxIds = [];
                    message.rollbackTxIds.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RollbackCompleted message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof wavesenterprise.RollbackCompleted
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {wavesenterprise.RollbackCompleted} RollbackCompleted
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RollbackCompleted.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RollbackCompleted message.
         * @function verify
         * @memberof wavesenterprise.RollbackCompleted
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RollbackCompleted.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.returnToBlockSignature != null && message.hasOwnProperty("returnToBlockSignature"))
                if (!(message.returnToBlockSignature && typeof message.returnToBlockSignature.length === "number" || $util.isString(message.returnToBlockSignature)))
                    return "returnToBlockSignature: buffer expected";
            if (message.rollbackTxIds != null && message.hasOwnProperty("rollbackTxIds")) {
                if (!Array.isArray(message.rollbackTxIds))
                    return "rollbackTxIds: array expected";
                for (var i = 0; i < message.rollbackTxIds.length; ++i)
                    if (!(message.rollbackTxIds[i] && typeof message.rollbackTxIds[i].length === "number" || $util.isString(message.rollbackTxIds[i])))
                        return "rollbackTxIds: buffer[] expected";
            }
            return null;
        };

        /**
         * Creates a RollbackCompleted message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof wavesenterprise.RollbackCompleted
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {wavesenterprise.RollbackCompleted} RollbackCompleted
         */
        RollbackCompleted.fromObject = function fromObject(object) {
            if (object instanceof $root.wavesenterprise.RollbackCompleted)
                return object;
            var message = new $root.wavesenterprise.RollbackCompleted();
            if (object.returnToBlockSignature != null)
                if (typeof object.returnToBlockSignature === "string")
                    $util.base64.decode(object.returnToBlockSignature, message.returnToBlockSignature = $util.newBuffer($util.base64.length(object.returnToBlockSignature)), 0);
                else if (object.returnToBlockSignature.length)
                    message.returnToBlockSignature = object.returnToBlockSignature;
            if (object.rollbackTxIds) {
                if (!Array.isArray(object.rollbackTxIds))
                    throw TypeError(".wavesenterprise.RollbackCompleted.rollbackTxIds: array expected");
                message.rollbackTxIds = [];
                for (var i = 0; i < object.rollbackTxIds.length; ++i)
                    if (typeof object.rollbackTxIds[i] === "string")
                        $util.base64.decode(object.rollbackTxIds[i], message.rollbackTxIds[i] = $util.newBuffer($util.base64.length(object.rollbackTxIds[i])), 0);
                    else if (object.rollbackTxIds[i].length)
                        message.rollbackTxIds[i] = object.rollbackTxIds[i];
            }
            return message;
        };

        /**
         * Creates a plain object from a RollbackCompleted message. Also converts values to other types if specified.
         * @function toObject
         * @memberof wavesenterprise.RollbackCompleted
         * @static
         * @param {wavesenterprise.RollbackCompleted} message RollbackCompleted
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RollbackCompleted.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.rollbackTxIds = [];
            if (options.defaults)
                if (options.bytes === String)
                    object.returnToBlockSignature = "";
                else {
                    object.returnToBlockSignature = [];
                    if (options.bytes !== Array)
                        object.returnToBlockSignature = $util.newBuffer(object.returnToBlockSignature);
                }
            if (message.returnToBlockSignature != null && message.hasOwnProperty("returnToBlockSignature"))
                object.returnToBlockSignature = options.bytes === String ? $util.base64.encode(message.returnToBlockSignature, 0, message.returnToBlockSignature.length) : options.bytes === Array ? Array.prototype.slice.call(message.returnToBlockSignature) : message.returnToBlockSignature;
            if (message.rollbackTxIds && message.rollbackTxIds.length) {
                object.rollbackTxIds = [];
                for (var j = 0; j < message.rollbackTxIds.length; ++j)
                    object.rollbackTxIds[j] = options.bytes === String ? $util.base64.encode(message.rollbackTxIds[j], 0, message.rollbackTxIds[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.rollbackTxIds[j]) : message.rollbackTxIds[j];
            }
            return object;
        };

        /**
         * Converts this RollbackCompleted to JSON.
         * @function toJSON
         * @memberof wavesenterprise.RollbackCompleted
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RollbackCompleted.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RollbackCompleted;
    })();

    wavesenterprise.AppendedBlockHistory = (function() {

        /**
         * Properties of an AppendedBlockHistory.
         * @memberof wavesenterprise
         * @interface IAppendedBlockHistory
         * @property {Uint8Array|null} [blockSignature] AppendedBlockHistory blockSignature
         * @property {Uint8Array|null} [reference] AppendedBlockHistory reference
         * @property {Array.<wavesenterprise.ITransaction>|null} [txs] AppendedBlockHistory txs
         * @property {Uint8Array|null} [minerAddress] AppendedBlockHistory minerAddress
         * @property {number|Long|null} [height] AppendedBlockHistory height
         * @property {number|null} [version] AppendedBlockHistory version
         * @property {number|Long|null} [timestamp] AppendedBlockHistory timestamp
         * @property {number|Long|null} [fee] AppendedBlockHistory fee
         * @property {number|null} [blockSize] AppendedBlockHistory blockSize
         * @property {Array.<number>|null} [features] AppendedBlockHistory features
         */

        /**
         * Constructs a new AppendedBlockHistory.
         * @memberof wavesenterprise
         * @classdesc Represents an AppendedBlockHistory.
         * @implements IAppendedBlockHistory
         * @constructor
         * @param {wavesenterprise.IAppendedBlockHistory=} [properties] Properties to set
         */
        function AppendedBlockHistory(properties) {
            this.txs = [];
            this.features = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AppendedBlockHistory blockSignature.
         * @member {Uint8Array} blockSignature
         * @memberof wavesenterprise.AppendedBlockHistory
         * @instance
         */
        AppendedBlockHistory.prototype.blockSignature = $util.newBuffer([]);

        /**
         * AppendedBlockHistory reference.
         * @member {Uint8Array} reference
         * @memberof wavesenterprise.AppendedBlockHistory
         * @instance
         */
        AppendedBlockHistory.prototype.reference = $util.newBuffer([]);

        /**
         * AppendedBlockHistory txs.
         * @member {Array.<wavesenterprise.ITransaction>} txs
         * @memberof wavesenterprise.AppendedBlockHistory
         * @instance
         */
        AppendedBlockHistory.prototype.txs = $util.emptyArray;

        /**
         * AppendedBlockHistory minerAddress.
         * @member {Uint8Array} minerAddress
         * @memberof wavesenterprise.AppendedBlockHistory
         * @instance
         */
        AppendedBlockHistory.prototype.minerAddress = $util.newBuffer([]);

        /**
         * AppendedBlockHistory height.
         * @member {number|Long} height
         * @memberof wavesenterprise.AppendedBlockHistory
         * @instance
         */
        AppendedBlockHistory.prototype.height = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * AppendedBlockHistory version.
         * @member {number} version
         * @memberof wavesenterprise.AppendedBlockHistory
         * @instance
         */
        AppendedBlockHistory.prototype.version = 0;

        /**
         * AppendedBlockHistory timestamp.
         * @member {number|Long} timestamp
         * @memberof wavesenterprise.AppendedBlockHistory
         * @instance
         */
        AppendedBlockHistory.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * AppendedBlockHistory fee.
         * @member {number|Long} fee
         * @memberof wavesenterprise.AppendedBlockHistory
         * @instance
         */
        AppendedBlockHistory.prototype.fee = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * AppendedBlockHistory blockSize.
         * @member {number} blockSize
         * @memberof wavesenterprise.AppendedBlockHistory
         * @instance
         */
        AppendedBlockHistory.prototype.blockSize = 0;

        /**
         * AppendedBlockHistory features.
         * @member {Array.<number>} features
         * @memberof wavesenterprise.AppendedBlockHistory
         * @instance
         */
        AppendedBlockHistory.prototype.features = $util.emptyArray;

        /**
         * Creates a new AppendedBlockHistory instance using the specified properties.
         * @function create
         * @memberof wavesenterprise.AppendedBlockHistory
         * @static
         * @param {wavesenterprise.IAppendedBlockHistory=} [properties] Properties to set
         * @returns {wavesenterprise.AppendedBlockHistory} AppendedBlockHistory instance
         */
        AppendedBlockHistory.create = function create(properties) {
            return new AppendedBlockHistory(properties);
        };

        /**
         * Encodes the specified AppendedBlockHistory message. Does not implicitly {@link wavesenterprise.AppendedBlockHistory.verify|verify} messages.
         * @function encode
         * @memberof wavesenterprise.AppendedBlockHistory
         * @static
         * @param {wavesenterprise.IAppendedBlockHistory} message AppendedBlockHistory message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AppendedBlockHistory.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.blockSignature != null && Object.hasOwnProperty.call(message, "blockSignature"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.blockSignature);
            if (message.reference != null && Object.hasOwnProperty.call(message, "reference"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.reference);
            if (message.txs != null && message.txs.length)
                for (var i = 0; i < message.txs.length; ++i)
                    $root.wavesenterprise.Transaction.encode(message.txs[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.minerAddress != null && Object.hasOwnProperty.call(message, "minerAddress"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.minerAddress);
            if (message.height != null && Object.hasOwnProperty.call(message, "height"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.height);
            if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.version);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.timestamp);
            if (message.fee != null && Object.hasOwnProperty.call(message, "fee"))
                writer.uint32(/* id 8, wireType 0 =*/64).int64(message.fee);
            if (message.blockSize != null && Object.hasOwnProperty.call(message, "blockSize"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.blockSize);
            if (message.features != null && message.features.length) {
                writer.uint32(/* id 10, wireType 2 =*/82).fork();
                for (var i = 0; i < message.features.length; ++i)
                    writer.int32(message.features[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified AppendedBlockHistory message, length delimited. Does not implicitly {@link wavesenterprise.AppendedBlockHistory.verify|verify} messages.
         * @function encodeDelimited
         * @memberof wavesenterprise.AppendedBlockHistory
         * @static
         * @param {wavesenterprise.IAppendedBlockHistory} message AppendedBlockHistory message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AppendedBlockHistory.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AppendedBlockHistory message from the specified reader or buffer.
         * @function decode
         * @memberof wavesenterprise.AppendedBlockHistory
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {wavesenterprise.AppendedBlockHistory} AppendedBlockHistory
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AppendedBlockHistory.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.wavesenterprise.AppendedBlockHistory();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.blockSignature = reader.bytes();
                    break;
                case 2:
                    message.reference = reader.bytes();
                    break;
                case 3:
                    if (!(message.txs && message.txs.length))
                        message.txs = [];
                    message.txs.push($root.wavesenterprise.Transaction.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.minerAddress = reader.bytes();
                    break;
                case 5:
                    message.height = reader.int64();
                    break;
                case 6:
                    message.version = reader.int32();
                    break;
                case 7:
                    message.timestamp = reader.int64();
                    break;
                case 8:
                    message.fee = reader.int64();
                    break;
                case 9:
                    message.blockSize = reader.int32();
                    break;
                case 10:
                    if (!(message.features && message.features.length))
                        message.features = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.features.push(reader.int32());
                    } else
                        message.features.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AppendedBlockHistory message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof wavesenterprise.AppendedBlockHistory
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {wavesenterprise.AppendedBlockHistory} AppendedBlockHistory
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AppendedBlockHistory.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AppendedBlockHistory message.
         * @function verify
         * @memberof wavesenterprise.AppendedBlockHistory
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AppendedBlockHistory.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.blockSignature != null && message.hasOwnProperty("blockSignature"))
                if (!(message.blockSignature && typeof message.blockSignature.length === "number" || $util.isString(message.blockSignature)))
                    return "blockSignature: buffer expected";
            if (message.reference != null && message.hasOwnProperty("reference"))
                if (!(message.reference && typeof message.reference.length === "number" || $util.isString(message.reference)))
                    return "reference: buffer expected";
            if (message.txs != null && message.hasOwnProperty("txs")) {
                if (!Array.isArray(message.txs))
                    return "txs: array expected";
                for (var i = 0; i < message.txs.length; ++i) {
                    var error = $root.wavesenterprise.Transaction.verify(message.txs[i]);
                    if (error)
                        return "txs." + error;
                }
            }
            if (message.minerAddress != null && message.hasOwnProperty("minerAddress"))
                if (!(message.minerAddress && typeof message.minerAddress.length === "number" || $util.isString(message.minerAddress)))
                    return "minerAddress: buffer expected";
            if (message.height != null && message.hasOwnProperty("height"))
                if (!$util.isInteger(message.height) && !(message.height && $util.isInteger(message.height.low) && $util.isInteger(message.height.high)))
                    return "height: integer|Long expected";
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isInteger(message.version))
                    return "version: integer expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            if (message.fee != null && message.hasOwnProperty("fee"))
                if (!$util.isInteger(message.fee) && !(message.fee && $util.isInteger(message.fee.low) && $util.isInteger(message.fee.high)))
                    return "fee: integer|Long expected";
            if (message.blockSize != null && message.hasOwnProperty("blockSize"))
                if (!$util.isInteger(message.blockSize))
                    return "blockSize: integer expected";
            if (message.features != null && message.hasOwnProperty("features")) {
                if (!Array.isArray(message.features))
                    return "features: array expected";
                for (var i = 0; i < message.features.length; ++i)
                    if (!$util.isInteger(message.features[i]))
                        return "features: integer[] expected";
            }
            return null;
        };

        /**
         * Creates an AppendedBlockHistory message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof wavesenterprise.AppendedBlockHistory
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {wavesenterprise.AppendedBlockHistory} AppendedBlockHistory
         */
        AppendedBlockHistory.fromObject = function fromObject(object) {
            if (object instanceof $root.wavesenterprise.AppendedBlockHistory)
                return object;
            var message = new $root.wavesenterprise.AppendedBlockHistory();
            if (object.blockSignature != null)
                if (typeof object.blockSignature === "string")
                    $util.base64.decode(object.blockSignature, message.blockSignature = $util.newBuffer($util.base64.length(object.blockSignature)), 0);
                else if (object.blockSignature.length)
                    message.blockSignature = object.blockSignature;
            if (object.reference != null)
                if (typeof object.reference === "string")
                    $util.base64.decode(object.reference, message.reference = $util.newBuffer($util.base64.length(object.reference)), 0);
                else if (object.reference.length)
                    message.reference = object.reference;
            if (object.txs) {
                if (!Array.isArray(object.txs))
                    throw TypeError(".wavesenterprise.AppendedBlockHistory.txs: array expected");
                message.txs = [];
                for (var i = 0; i < object.txs.length; ++i) {
                    if (typeof object.txs[i] !== "object")
                        throw TypeError(".wavesenterprise.AppendedBlockHistory.txs: object expected");
                    message.txs[i] = $root.wavesenterprise.Transaction.fromObject(object.txs[i]);
                }
            }
            if (object.minerAddress != null)
                if (typeof object.minerAddress === "string")
                    $util.base64.decode(object.minerAddress, message.minerAddress = $util.newBuffer($util.base64.length(object.minerAddress)), 0);
                else if (object.minerAddress.length)
                    message.minerAddress = object.minerAddress;
            if (object.height != null)
                if ($util.Long)
                    (message.height = $util.Long.fromValue(object.height)).unsigned = false;
                else if (typeof object.height === "string")
                    message.height = parseInt(object.height, 10);
                else if (typeof object.height === "number")
                    message.height = object.height;
                else if (typeof object.height === "object")
                    message.height = new $util.LongBits(object.height.low >>> 0, object.height.high >>> 0).toNumber();
            if (object.version != null)
                message.version = object.version | 0;
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            if (object.fee != null)
                if ($util.Long)
                    (message.fee = $util.Long.fromValue(object.fee)).unsigned = false;
                else if (typeof object.fee === "string")
                    message.fee = parseInt(object.fee, 10);
                else if (typeof object.fee === "number")
                    message.fee = object.fee;
                else if (typeof object.fee === "object")
                    message.fee = new $util.LongBits(object.fee.low >>> 0, object.fee.high >>> 0).toNumber();
            if (object.blockSize != null)
                message.blockSize = object.blockSize | 0;
            if (object.features) {
                if (!Array.isArray(object.features))
                    throw TypeError(".wavesenterprise.AppendedBlockHistory.features: array expected");
                message.features = [];
                for (var i = 0; i < object.features.length; ++i)
                    message.features[i] = object.features[i] | 0;
            }
            return message;
        };

        /**
         * Creates a plain object from an AppendedBlockHistory message. Also converts values to other types if specified.
         * @function toObject
         * @memberof wavesenterprise.AppendedBlockHistory
         * @static
         * @param {wavesenterprise.AppendedBlockHistory} message AppendedBlockHistory
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AppendedBlockHistory.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.txs = [];
                object.features = [];
            }
            if (options.defaults) {
                if (options.bytes === String)
                    object.blockSignature = "";
                else {
                    object.blockSignature = [];
                    if (options.bytes !== Array)
                        object.blockSignature = $util.newBuffer(object.blockSignature);
                }
                if (options.bytes === String)
                    object.reference = "";
                else {
                    object.reference = [];
                    if (options.bytes !== Array)
                        object.reference = $util.newBuffer(object.reference);
                }
                if (options.bytes === String)
                    object.minerAddress = "";
                else {
                    object.minerAddress = [];
                    if (options.bytes !== Array)
                        object.minerAddress = $util.newBuffer(object.minerAddress);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.height = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.height = options.longs === String ? "0" : 0;
                object.version = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.fee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.fee = options.longs === String ? "0" : 0;
                object.blockSize = 0;
            }
            if (message.blockSignature != null && message.hasOwnProperty("blockSignature"))
                object.blockSignature = options.bytes === String ? $util.base64.encode(message.blockSignature, 0, message.blockSignature.length) : options.bytes === Array ? Array.prototype.slice.call(message.blockSignature) : message.blockSignature;
            if (message.reference != null && message.hasOwnProperty("reference"))
                object.reference = options.bytes === String ? $util.base64.encode(message.reference, 0, message.reference.length) : options.bytes === Array ? Array.prototype.slice.call(message.reference) : message.reference;
            if (message.txs && message.txs.length) {
                object.txs = [];
                for (var j = 0; j < message.txs.length; ++j)
                    object.txs[j] = $root.wavesenterprise.Transaction.toObject(message.txs[j], options);
            }
            if (message.minerAddress != null && message.hasOwnProperty("minerAddress"))
                object.minerAddress = options.bytes === String ? $util.base64.encode(message.minerAddress, 0, message.minerAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.minerAddress) : message.minerAddress;
            if (message.height != null && message.hasOwnProperty("height"))
                if (typeof message.height === "number")
                    object.height = options.longs === String ? String(message.height) : message.height;
                else
                    object.height = options.longs === String ? $util.Long.prototype.toString.call(message.height) : options.longs === Number ? new $util.LongBits(message.height.low >>> 0, message.height.high >>> 0).toNumber() : message.height;
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            if (message.fee != null && message.hasOwnProperty("fee"))
                if (typeof message.fee === "number")
                    object.fee = options.longs === String ? String(message.fee) : message.fee;
                else
                    object.fee = options.longs === String ? $util.Long.prototype.toString.call(message.fee) : options.longs === Number ? new $util.LongBits(message.fee.low >>> 0, message.fee.high >>> 0).toNumber() : message.fee;
            if (message.blockSize != null && message.hasOwnProperty("blockSize"))
                object.blockSize = message.blockSize;
            if (message.features && message.features.length) {
                object.features = [];
                for (var j = 0; j < message.features.length; ++j)
                    object.features[j] = message.features[j];
            }
            return object;
        };

        /**
         * Converts this AppendedBlockHistory to JSON.
         * @function toJSON
         * @memberof wavesenterprise.AppendedBlockHistory
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AppendedBlockHistory.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AppendedBlockHistory;
    })();

    wavesenterprise.Transaction = (function() {

        /**
         * Properties of a Transaction.
         * @memberof wavesenterprise
         * @interface ITransaction
         * @property {number|null} [version] Transaction version
         * @property {wavesenterprise.IGenesisTransaction|null} [genesisTransaction] Transaction genesisTransaction
         * @property {wavesenterprise.IGenesisPermitTransaction|null} [genesisPermitTransaction] Transaction genesisPermitTransaction
         * @property {wavesenterprise.IGenesisRegisterNodeTransaction|null} [genesisRegisterNodeTransaction] Transaction genesisRegisterNodeTransaction
         * @property {wavesenterprise.IRegisterNodeTransaction|null} [registerNodeTransaction] Transaction registerNodeTransaction
         * @property {wavesenterprise.ICreateAliasTransaction|null} [createAliasTransaction] Transaction createAliasTransaction
         * @property {wavesenterprise.IIssueTransaction|null} [issueTransaction] Transaction issueTransaction
         * @property {wavesenterprise.IReissueTransaction|null} [reissueTransaction] Transaction reissueTransaction
         * @property {wavesenterprise.IBurnTransaction|null} [burnTransaction] Transaction burnTransaction
         * @property {wavesenterprise.ILeaseTransaction|null} [leaseTransaction] Transaction leaseTransaction
         * @property {wavesenterprise.ILeaseCancelTransaction|null} [leaseCancelTransaction] Transaction leaseCancelTransaction
         * @property {wavesenterprise.ISponsorFeeTransaction|null} [sponsorFeeTransaction] Transaction sponsorFeeTransaction
         * @property {wavesenterprise.ISetAssetScriptTransaction|null} [setAssetScriptTransaction] Transaction setAssetScriptTransaction
         * @property {wavesenterprise.IDataTransaction|null} [dataTransaction] Transaction dataTransaction
         * @property {wavesenterprise.ITransferTransaction|null} [transferTransaction] Transaction transferTransaction
         * @property {wavesenterprise.IMassTransferTransaction|null} [massTransferTransaction] Transaction massTransferTransaction
         * @property {wavesenterprise.IPermitTransaction|null} [permitTransaction] Transaction permitTransaction
         * @property {wavesenterprise.ICreatePolicyTransaction|null} [createPolicyTransaction] Transaction createPolicyTransaction
         * @property {wavesenterprise.IUpdatePolicyTransaction|null} [updatePolicyTransaction] Transaction updatePolicyTransaction
         * @property {wavesenterprise.IPolicyDataHashTransaction|null} [policyDataHashTransaction] Transaction policyDataHashTransaction
         * @property {wavesenterprise.ICreateContractTransaction|null} [createContractTransaction] Transaction createContractTransaction
         * @property {wavesenterprise.ICallContractTransaction|null} [callContractTransaction] Transaction callContractTransaction
         * @property {wavesenterprise.IExecutedContractTransaction|null} [executedContractTransaction] Transaction executedContractTransaction
         * @property {wavesenterprise.IDisableContractTransaction|null} [disableContractTransaction] Transaction disableContractTransaction
         * @property {wavesenterprise.IUpdateContractTransaction|null} [updateContractTransaction] Transaction updateContractTransaction
         * @property {wavesenterprise.ISetScriptTransaction|null} [setScriptTransaction] Transaction setScriptTransaction
         * @property {wavesenterprise.IAtomicTransaction|null} [atomicTransaction] Transaction atomicTransaction
         */

        /**
         * Constructs a new Transaction.
         * @memberof wavesenterprise
         * @classdesc Represents a Transaction.
         * @implements ITransaction
         * @constructor
         * @param {wavesenterprise.ITransaction=} [properties] Properties to set
         */
        function Transaction(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Transaction version.
         * @member {number} version
         * @memberof wavesenterprise.Transaction
         * @instance
         */
        Transaction.prototype.version = 0;

        /**
         * Transaction genesisTransaction.
         * @member {wavesenterprise.IGenesisTransaction|null|undefined} genesisTransaction
         * @memberof wavesenterprise.Transaction
         * @instance
         */
        Transaction.prototype.genesisTransaction = null;

        /**
         * Transaction genesisPermitTransaction.
         * @member {wavesenterprise.IGenesisPermitTransaction|null|undefined} genesisPermitTransaction
         * @memberof wavesenterprise.Transaction
         * @instance
         */
        Transaction.prototype.genesisPermitTransaction = null;

        /**
         * Transaction genesisRegisterNodeTransaction.
         * @member {wavesenterprise.IGenesisRegisterNodeTransaction|null|undefined} genesisRegisterNodeTransaction
         * @memberof wavesenterprise.Transaction
         * @instance
         */
        Transaction.prototype.genesisRegisterNodeTransaction = null;

        /**
         * Transaction registerNodeTransaction.
         * @member {wavesenterprise.IRegisterNodeTransaction|null|undefined} registerNodeTransaction
         * @memberof wavesenterprise.Transaction
         * @instance
         */
        Transaction.prototype.registerNodeTransaction = null;

        /**
         * Transaction createAliasTransaction.
         * @member {wavesenterprise.ICreateAliasTransaction|null|undefined} createAliasTransaction
         * @memberof wavesenterprise.Transaction
         * @instance
         */
        Transaction.prototype.createAliasTransaction = null;

        /**
         * Transaction issueTransaction.
         * @member {wavesenterprise.IIssueTransaction|null|undefined} issueTransaction
         * @memberof wavesenterprise.Transaction
         * @instance
         */
        Transaction.prototype.issueTransaction = null;

        /**
         * Transaction reissueTransaction.
         * @member {wavesenterprise.IReissueTransaction|null|undefined} reissueTransaction
         * @memberof wavesenterprise.Transaction
         * @instance
         */
        Transaction.prototype.reissueTransaction = null;

        /**
         * Transaction burnTransaction.
         * @member {wavesenterprise.IBurnTransaction|null|undefined} burnTransaction
         * @memberof wavesenterprise.Transaction
         * @instance
         */
        Transaction.prototype.burnTransaction = null;

        /**
         * Transaction leaseTransaction.
         * @member {wavesenterprise.ILeaseTransaction|null|undefined} leaseTransaction
         * @memberof wavesenterprise.Transaction
         * @instance
         */
        Transaction.prototype.leaseTransaction = null;

        /**
         * Transaction leaseCancelTransaction.
         * @member {wavesenterprise.ILeaseCancelTransaction|null|undefined} leaseCancelTransaction
         * @memberof wavesenterprise.Transaction
         * @instance
         */
        Transaction.prototype.leaseCancelTransaction = null;

        /**
         * Transaction sponsorFeeTransaction.
         * @member {wavesenterprise.ISponsorFeeTransaction|null|undefined} sponsorFeeTransaction
         * @memberof wavesenterprise.Transaction
         * @instance
         */
        Transaction.prototype.sponsorFeeTransaction = null;

        /**
         * Transaction setAssetScriptTransaction.
         * @member {wavesenterprise.ISetAssetScriptTransaction|null|undefined} setAssetScriptTransaction
         * @memberof wavesenterprise.Transaction
         * @instance
         */
        Transaction.prototype.setAssetScriptTransaction = null;

        /**
         * Transaction dataTransaction.
         * @member {wavesenterprise.IDataTransaction|null|undefined} dataTransaction
         * @memberof wavesenterprise.Transaction
         * @instance
         */
        Transaction.prototype.dataTransaction = null;

        /**
         * Transaction transferTransaction.
         * @member {wavesenterprise.ITransferTransaction|null|undefined} transferTransaction
         * @memberof wavesenterprise.Transaction
         * @instance
         */
        Transaction.prototype.transferTransaction = null;

        /**
         * Transaction massTransferTransaction.
         * @member {wavesenterprise.IMassTransferTransaction|null|undefined} massTransferTransaction
         * @memberof wavesenterprise.Transaction
         * @instance
         */
        Transaction.prototype.massTransferTransaction = null;

        /**
         * Transaction permitTransaction.
         * @member {wavesenterprise.IPermitTransaction|null|undefined} permitTransaction
         * @memberof wavesenterprise.Transaction
         * @instance
         */
        Transaction.prototype.permitTransaction = null;

        /**
         * Transaction createPolicyTransaction.
         * @member {wavesenterprise.ICreatePolicyTransaction|null|undefined} createPolicyTransaction
         * @memberof wavesenterprise.Transaction
         * @instance
         */
        Transaction.prototype.createPolicyTransaction = null;

        /**
         * Transaction updatePolicyTransaction.
         * @member {wavesenterprise.IUpdatePolicyTransaction|null|undefined} updatePolicyTransaction
         * @memberof wavesenterprise.Transaction
         * @instance
         */
        Transaction.prototype.updatePolicyTransaction = null;

        /**
         * Transaction policyDataHashTransaction.
         * @member {wavesenterprise.IPolicyDataHashTransaction|null|undefined} policyDataHashTransaction
         * @memberof wavesenterprise.Transaction
         * @instance
         */
        Transaction.prototype.policyDataHashTransaction = null;

        /**
         * Transaction createContractTransaction.
         * @member {wavesenterprise.ICreateContractTransaction|null|undefined} createContractTransaction
         * @memberof wavesenterprise.Transaction
         * @instance
         */
        Transaction.prototype.createContractTransaction = null;

        /**
         * Transaction callContractTransaction.
         * @member {wavesenterprise.ICallContractTransaction|null|undefined} callContractTransaction
         * @memberof wavesenterprise.Transaction
         * @instance
         */
        Transaction.prototype.callContractTransaction = null;

        /**
         * Transaction executedContractTransaction.
         * @member {wavesenterprise.IExecutedContractTransaction|null|undefined} executedContractTransaction
         * @memberof wavesenterprise.Transaction
         * @instance
         */
        Transaction.prototype.executedContractTransaction = null;

        /**
         * Transaction disableContractTransaction.
         * @member {wavesenterprise.IDisableContractTransaction|null|undefined} disableContractTransaction
         * @memberof wavesenterprise.Transaction
         * @instance
         */
        Transaction.prototype.disableContractTransaction = null;

        /**
         * Transaction updateContractTransaction.
         * @member {wavesenterprise.IUpdateContractTransaction|null|undefined} updateContractTransaction
         * @memberof wavesenterprise.Transaction
         * @instance
         */
        Transaction.prototype.updateContractTransaction = null;

        /**
         * Transaction setScriptTransaction.
         * @member {wavesenterprise.ISetScriptTransaction|null|undefined} setScriptTransaction
         * @memberof wavesenterprise.Transaction
         * @instance
         */
        Transaction.prototype.setScriptTransaction = null;

        /**
         * Transaction atomicTransaction.
         * @member {wavesenterprise.IAtomicTransaction|null|undefined} atomicTransaction
         * @memberof wavesenterprise.Transaction
         * @instance
         */
        Transaction.prototype.atomicTransaction = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * Transaction transaction.
         * @member {"genesisTransaction"|"genesisPermitTransaction"|"genesisRegisterNodeTransaction"|"registerNodeTransaction"|"createAliasTransaction"|"issueTransaction"|"reissueTransaction"|"burnTransaction"|"leaseTransaction"|"leaseCancelTransaction"|"sponsorFeeTransaction"|"setAssetScriptTransaction"|"dataTransaction"|"transferTransaction"|"massTransferTransaction"|"permitTransaction"|"createPolicyTransaction"|"updatePolicyTransaction"|"policyDataHashTransaction"|"createContractTransaction"|"callContractTransaction"|"executedContractTransaction"|"disableContractTransaction"|"updateContractTransaction"|"setScriptTransaction"|"atomicTransaction"|undefined} transaction
         * @memberof wavesenterprise.Transaction
         * @instance
         */
        Object.defineProperty(Transaction.prototype, "transaction", {
            get: $util.oneOfGetter($oneOfFields = ["genesisTransaction", "genesisPermitTransaction", "genesisRegisterNodeTransaction", "registerNodeTransaction", "createAliasTransaction", "issueTransaction", "reissueTransaction", "burnTransaction", "leaseTransaction", "leaseCancelTransaction", "sponsorFeeTransaction", "setAssetScriptTransaction", "dataTransaction", "transferTransaction", "massTransferTransaction", "permitTransaction", "createPolicyTransaction", "updatePolicyTransaction", "policyDataHashTransaction", "createContractTransaction", "callContractTransaction", "executedContractTransaction", "disableContractTransaction", "updateContractTransaction", "setScriptTransaction", "atomicTransaction"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new Transaction instance using the specified properties.
         * @function create
         * @memberof wavesenterprise.Transaction
         * @static
         * @param {wavesenterprise.ITransaction=} [properties] Properties to set
         * @returns {wavesenterprise.Transaction} Transaction instance
         */
        Transaction.create = function create(properties) {
            return new Transaction(properties);
        };

        /**
         * Encodes the specified Transaction message. Does not implicitly {@link wavesenterprise.Transaction.verify|verify} messages.
         * @function encode
         * @memberof wavesenterprise.Transaction
         * @static
         * @param {wavesenterprise.ITransaction} message Transaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Transaction.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.version);
            if (message.genesisTransaction != null && Object.hasOwnProperty.call(message, "genesisTransaction"))
                $root.wavesenterprise.GenesisTransaction.encode(message.genesisTransaction, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
            if (message.genesisPermitTransaction != null && Object.hasOwnProperty.call(message, "genesisPermitTransaction"))
                $root.wavesenterprise.GenesisPermitTransaction.encode(message.genesisPermitTransaction, writer.uint32(/* id 1001, wireType 2 =*/8010).fork()).ldelim();
            if (message.genesisRegisterNodeTransaction != null && Object.hasOwnProperty.call(message, "genesisRegisterNodeTransaction"))
                $root.wavesenterprise.GenesisRegisterNodeTransaction.encode(message.genesisRegisterNodeTransaction, writer.uint32(/* id 1002, wireType 2 =*/8018).fork()).ldelim();
            if (message.registerNodeTransaction != null && Object.hasOwnProperty.call(message, "registerNodeTransaction"))
                $root.wavesenterprise.RegisterNodeTransaction.encode(message.registerNodeTransaction, writer.uint32(/* id 1003, wireType 2 =*/8026).fork()).ldelim();
            if (message.createAliasTransaction != null && Object.hasOwnProperty.call(message, "createAliasTransaction"))
                $root.wavesenterprise.CreateAliasTransaction.encode(message.createAliasTransaction, writer.uint32(/* id 1004, wireType 2 =*/8034).fork()).ldelim();
            if (message.issueTransaction != null && Object.hasOwnProperty.call(message, "issueTransaction"))
                $root.wavesenterprise.IssueTransaction.encode(message.issueTransaction, writer.uint32(/* id 1005, wireType 2 =*/8042).fork()).ldelim();
            if (message.reissueTransaction != null && Object.hasOwnProperty.call(message, "reissueTransaction"))
                $root.wavesenterprise.ReissueTransaction.encode(message.reissueTransaction, writer.uint32(/* id 1006, wireType 2 =*/8050).fork()).ldelim();
            if (message.burnTransaction != null && Object.hasOwnProperty.call(message, "burnTransaction"))
                $root.wavesenterprise.BurnTransaction.encode(message.burnTransaction, writer.uint32(/* id 1007, wireType 2 =*/8058).fork()).ldelim();
            if (message.leaseTransaction != null && Object.hasOwnProperty.call(message, "leaseTransaction"))
                $root.wavesenterprise.LeaseTransaction.encode(message.leaseTransaction, writer.uint32(/* id 1008, wireType 2 =*/8066).fork()).ldelim();
            if (message.leaseCancelTransaction != null && Object.hasOwnProperty.call(message, "leaseCancelTransaction"))
                $root.wavesenterprise.LeaseCancelTransaction.encode(message.leaseCancelTransaction, writer.uint32(/* id 1009, wireType 2 =*/8074).fork()).ldelim();
            if (message.sponsorFeeTransaction != null && Object.hasOwnProperty.call(message, "sponsorFeeTransaction"))
                $root.wavesenterprise.SponsorFeeTransaction.encode(message.sponsorFeeTransaction, writer.uint32(/* id 1010, wireType 2 =*/8082).fork()).ldelim();
            if (message.setAssetScriptTransaction != null && Object.hasOwnProperty.call(message, "setAssetScriptTransaction"))
                $root.wavesenterprise.SetAssetScriptTransaction.encode(message.setAssetScriptTransaction, writer.uint32(/* id 1011, wireType 2 =*/8090).fork()).ldelim();
            if (message.dataTransaction != null && Object.hasOwnProperty.call(message, "dataTransaction"))
                $root.wavesenterprise.DataTransaction.encode(message.dataTransaction, writer.uint32(/* id 1012, wireType 2 =*/8098).fork()).ldelim();
            if (message.transferTransaction != null && Object.hasOwnProperty.call(message, "transferTransaction"))
                $root.wavesenterprise.TransferTransaction.encode(message.transferTransaction, writer.uint32(/* id 1013, wireType 2 =*/8106).fork()).ldelim();
            if (message.massTransferTransaction != null && Object.hasOwnProperty.call(message, "massTransferTransaction"))
                $root.wavesenterprise.MassTransferTransaction.encode(message.massTransferTransaction, writer.uint32(/* id 1014, wireType 2 =*/8114).fork()).ldelim();
            if (message.permitTransaction != null && Object.hasOwnProperty.call(message, "permitTransaction"))
                $root.wavesenterprise.PermitTransaction.encode(message.permitTransaction, writer.uint32(/* id 1015, wireType 2 =*/8122).fork()).ldelim();
            if (message.createPolicyTransaction != null && Object.hasOwnProperty.call(message, "createPolicyTransaction"))
                $root.wavesenterprise.CreatePolicyTransaction.encode(message.createPolicyTransaction, writer.uint32(/* id 1016, wireType 2 =*/8130).fork()).ldelim();
            if (message.updatePolicyTransaction != null && Object.hasOwnProperty.call(message, "updatePolicyTransaction"))
                $root.wavesenterprise.UpdatePolicyTransaction.encode(message.updatePolicyTransaction, writer.uint32(/* id 1017, wireType 2 =*/8138).fork()).ldelim();
            if (message.policyDataHashTransaction != null && Object.hasOwnProperty.call(message, "policyDataHashTransaction"))
                $root.wavesenterprise.PolicyDataHashTransaction.encode(message.policyDataHashTransaction, writer.uint32(/* id 1018, wireType 2 =*/8146).fork()).ldelim();
            if (message.createContractTransaction != null && Object.hasOwnProperty.call(message, "createContractTransaction"))
                $root.wavesenterprise.CreateContractTransaction.encode(message.createContractTransaction, writer.uint32(/* id 1019, wireType 2 =*/8154).fork()).ldelim();
            if (message.callContractTransaction != null && Object.hasOwnProperty.call(message, "callContractTransaction"))
                $root.wavesenterprise.CallContractTransaction.encode(message.callContractTransaction, writer.uint32(/* id 1020, wireType 2 =*/8162).fork()).ldelim();
            if (message.executedContractTransaction != null && Object.hasOwnProperty.call(message, "executedContractTransaction"))
                $root.wavesenterprise.ExecutedContractTransaction.encode(message.executedContractTransaction, writer.uint32(/* id 1021, wireType 2 =*/8170).fork()).ldelim();
            if (message.disableContractTransaction != null && Object.hasOwnProperty.call(message, "disableContractTransaction"))
                $root.wavesenterprise.DisableContractTransaction.encode(message.disableContractTransaction, writer.uint32(/* id 1022, wireType 2 =*/8178).fork()).ldelim();
            if (message.updateContractTransaction != null && Object.hasOwnProperty.call(message, "updateContractTransaction"))
                $root.wavesenterprise.UpdateContractTransaction.encode(message.updateContractTransaction, writer.uint32(/* id 1023, wireType 2 =*/8186).fork()).ldelim();
            if (message.setScriptTransaction != null && Object.hasOwnProperty.call(message, "setScriptTransaction"))
                $root.wavesenterprise.SetScriptTransaction.encode(message.setScriptTransaction, writer.uint32(/* id 1024, wireType 2 =*/8194).fork()).ldelim();
            if (message.atomicTransaction != null && Object.hasOwnProperty.call(message, "atomicTransaction"))
                $root.wavesenterprise.AtomicTransaction.encode(message.atomicTransaction, writer.uint32(/* id 1025, wireType 2 =*/8202).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Transaction message, length delimited. Does not implicitly {@link wavesenterprise.Transaction.verify|verify} messages.
         * @function encodeDelimited
         * @memberof wavesenterprise.Transaction
         * @static
         * @param {wavesenterprise.ITransaction} message Transaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Transaction.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Transaction message from the specified reader or buffer.
         * @function decode
         * @memberof wavesenterprise.Transaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {wavesenterprise.Transaction} Transaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Transaction.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.wavesenterprise.Transaction();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.version = reader.int32();
                    break;
                case 1000:
                    message.genesisTransaction = $root.wavesenterprise.GenesisTransaction.decode(reader, reader.uint32());
                    break;
                case 1001:
                    message.genesisPermitTransaction = $root.wavesenterprise.GenesisPermitTransaction.decode(reader, reader.uint32());
                    break;
                case 1002:
                    message.genesisRegisterNodeTransaction = $root.wavesenterprise.GenesisRegisterNodeTransaction.decode(reader, reader.uint32());
                    break;
                case 1003:
                    message.registerNodeTransaction = $root.wavesenterprise.RegisterNodeTransaction.decode(reader, reader.uint32());
                    break;
                case 1004:
                    message.createAliasTransaction = $root.wavesenterprise.CreateAliasTransaction.decode(reader, reader.uint32());
                    break;
                case 1005:
                    message.issueTransaction = $root.wavesenterprise.IssueTransaction.decode(reader, reader.uint32());
                    break;
                case 1006:
                    message.reissueTransaction = $root.wavesenterprise.ReissueTransaction.decode(reader, reader.uint32());
                    break;
                case 1007:
                    message.burnTransaction = $root.wavesenterprise.BurnTransaction.decode(reader, reader.uint32());
                    break;
                case 1008:
                    message.leaseTransaction = $root.wavesenterprise.LeaseTransaction.decode(reader, reader.uint32());
                    break;
                case 1009:
                    message.leaseCancelTransaction = $root.wavesenterprise.LeaseCancelTransaction.decode(reader, reader.uint32());
                    break;
                case 1010:
                    message.sponsorFeeTransaction = $root.wavesenterprise.SponsorFeeTransaction.decode(reader, reader.uint32());
                    break;
                case 1011:
                    message.setAssetScriptTransaction = $root.wavesenterprise.SetAssetScriptTransaction.decode(reader, reader.uint32());
                    break;
                case 1012:
                    message.dataTransaction = $root.wavesenterprise.DataTransaction.decode(reader, reader.uint32());
                    break;
                case 1013:
                    message.transferTransaction = $root.wavesenterprise.TransferTransaction.decode(reader, reader.uint32());
                    break;
                case 1014:
                    message.massTransferTransaction = $root.wavesenterprise.MassTransferTransaction.decode(reader, reader.uint32());
                    break;
                case 1015:
                    message.permitTransaction = $root.wavesenterprise.PermitTransaction.decode(reader, reader.uint32());
                    break;
                case 1016:
                    message.createPolicyTransaction = $root.wavesenterprise.CreatePolicyTransaction.decode(reader, reader.uint32());
                    break;
                case 1017:
                    message.updatePolicyTransaction = $root.wavesenterprise.UpdatePolicyTransaction.decode(reader, reader.uint32());
                    break;
                case 1018:
                    message.policyDataHashTransaction = $root.wavesenterprise.PolicyDataHashTransaction.decode(reader, reader.uint32());
                    break;
                case 1019:
                    message.createContractTransaction = $root.wavesenterprise.CreateContractTransaction.decode(reader, reader.uint32());
                    break;
                case 1020:
                    message.callContractTransaction = $root.wavesenterprise.CallContractTransaction.decode(reader, reader.uint32());
                    break;
                case 1021:
                    message.executedContractTransaction = $root.wavesenterprise.ExecutedContractTransaction.decode(reader, reader.uint32());
                    break;
                case 1022:
                    message.disableContractTransaction = $root.wavesenterprise.DisableContractTransaction.decode(reader, reader.uint32());
                    break;
                case 1023:
                    message.updateContractTransaction = $root.wavesenterprise.UpdateContractTransaction.decode(reader, reader.uint32());
                    break;
                case 1024:
                    message.setScriptTransaction = $root.wavesenterprise.SetScriptTransaction.decode(reader, reader.uint32());
                    break;
                case 1025:
                    message.atomicTransaction = $root.wavesenterprise.AtomicTransaction.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Transaction message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof wavesenterprise.Transaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {wavesenterprise.Transaction} Transaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Transaction.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Transaction message.
         * @function verify
         * @memberof wavesenterprise.Transaction
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Transaction.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isInteger(message.version))
                    return "version: integer expected";
            if (message.genesisTransaction != null && message.hasOwnProperty("genesisTransaction")) {
                properties.transaction = 1;
                {
                    var error = $root.wavesenterprise.GenesisTransaction.verify(message.genesisTransaction);
                    if (error)
                        return "genesisTransaction." + error;
                }
            }
            if (message.genesisPermitTransaction != null && message.hasOwnProperty("genesisPermitTransaction")) {
                if (properties.transaction === 1)
                    return "transaction: multiple values";
                properties.transaction = 1;
                {
                    var error = $root.wavesenterprise.GenesisPermitTransaction.verify(message.genesisPermitTransaction);
                    if (error)
                        return "genesisPermitTransaction." + error;
                }
            }
            if (message.genesisRegisterNodeTransaction != null && message.hasOwnProperty("genesisRegisterNodeTransaction")) {
                if (properties.transaction === 1)
                    return "transaction: multiple values";
                properties.transaction = 1;
                {
                    var error = $root.wavesenterprise.GenesisRegisterNodeTransaction.verify(message.genesisRegisterNodeTransaction);
                    if (error)
                        return "genesisRegisterNodeTransaction." + error;
                }
            }
            if (message.registerNodeTransaction != null && message.hasOwnProperty("registerNodeTransaction")) {
                if (properties.transaction === 1)
                    return "transaction: multiple values";
                properties.transaction = 1;
                {
                    var error = $root.wavesenterprise.RegisterNodeTransaction.verify(message.registerNodeTransaction);
                    if (error)
                        return "registerNodeTransaction." + error;
                }
            }
            if (message.createAliasTransaction != null && message.hasOwnProperty("createAliasTransaction")) {
                if (properties.transaction === 1)
                    return "transaction: multiple values";
                properties.transaction = 1;
                {
                    var error = $root.wavesenterprise.CreateAliasTransaction.verify(message.createAliasTransaction);
                    if (error)
                        return "createAliasTransaction." + error;
                }
            }
            if (message.issueTransaction != null && message.hasOwnProperty("issueTransaction")) {
                if (properties.transaction === 1)
                    return "transaction: multiple values";
                properties.transaction = 1;
                {
                    var error = $root.wavesenterprise.IssueTransaction.verify(message.issueTransaction);
                    if (error)
                        return "issueTransaction." + error;
                }
            }
            if (message.reissueTransaction != null && message.hasOwnProperty("reissueTransaction")) {
                if (properties.transaction === 1)
                    return "transaction: multiple values";
                properties.transaction = 1;
                {
                    var error = $root.wavesenterprise.ReissueTransaction.verify(message.reissueTransaction);
                    if (error)
                        return "reissueTransaction." + error;
                }
            }
            if (message.burnTransaction != null && message.hasOwnProperty("burnTransaction")) {
                if (properties.transaction === 1)
                    return "transaction: multiple values";
                properties.transaction = 1;
                {
                    var error = $root.wavesenterprise.BurnTransaction.verify(message.burnTransaction);
                    if (error)
                        return "burnTransaction." + error;
                }
            }
            if (message.leaseTransaction != null && message.hasOwnProperty("leaseTransaction")) {
                if (properties.transaction === 1)
                    return "transaction: multiple values";
                properties.transaction = 1;
                {
                    var error = $root.wavesenterprise.LeaseTransaction.verify(message.leaseTransaction);
                    if (error)
                        return "leaseTransaction." + error;
                }
            }
            if (message.leaseCancelTransaction != null && message.hasOwnProperty("leaseCancelTransaction")) {
                if (properties.transaction === 1)
                    return "transaction: multiple values";
                properties.transaction = 1;
                {
                    var error = $root.wavesenterprise.LeaseCancelTransaction.verify(message.leaseCancelTransaction);
                    if (error)
                        return "leaseCancelTransaction." + error;
                }
            }
            if (message.sponsorFeeTransaction != null && message.hasOwnProperty("sponsorFeeTransaction")) {
                if (properties.transaction === 1)
                    return "transaction: multiple values";
                properties.transaction = 1;
                {
                    var error = $root.wavesenterprise.SponsorFeeTransaction.verify(message.sponsorFeeTransaction);
                    if (error)
                        return "sponsorFeeTransaction." + error;
                }
            }
            if (message.setAssetScriptTransaction != null && message.hasOwnProperty("setAssetScriptTransaction")) {
                if (properties.transaction === 1)
                    return "transaction: multiple values";
                properties.transaction = 1;
                {
                    var error = $root.wavesenterprise.SetAssetScriptTransaction.verify(message.setAssetScriptTransaction);
                    if (error)
                        return "setAssetScriptTransaction." + error;
                }
            }
            if (message.dataTransaction != null && message.hasOwnProperty("dataTransaction")) {
                if (properties.transaction === 1)
                    return "transaction: multiple values";
                properties.transaction = 1;
                {
                    var error = $root.wavesenterprise.DataTransaction.verify(message.dataTransaction);
                    if (error)
                        return "dataTransaction." + error;
                }
            }
            if (message.transferTransaction != null && message.hasOwnProperty("transferTransaction")) {
                if (properties.transaction === 1)
                    return "transaction: multiple values";
                properties.transaction = 1;
                {
                    var error = $root.wavesenterprise.TransferTransaction.verify(message.transferTransaction);
                    if (error)
                        return "transferTransaction." + error;
                }
            }
            if (message.massTransferTransaction != null && message.hasOwnProperty("massTransferTransaction")) {
                if (properties.transaction === 1)
                    return "transaction: multiple values";
                properties.transaction = 1;
                {
                    var error = $root.wavesenterprise.MassTransferTransaction.verify(message.massTransferTransaction);
                    if (error)
                        return "massTransferTransaction." + error;
                }
            }
            if (message.permitTransaction != null && message.hasOwnProperty("permitTransaction")) {
                if (properties.transaction === 1)
                    return "transaction: multiple values";
                properties.transaction = 1;
                {
                    var error = $root.wavesenterprise.PermitTransaction.verify(message.permitTransaction);
                    if (error)
                        return "permitTransaction." + error;
                }
            }
            if (message.createPolicyTransaction != null && message.hasOwnProperty("createPolicyTransaction")) {
                if (properties.transaction === 1)
                    return "transaction: multiple values";
                properties.transaction = 1;
                {
                    var error = $root.wavesenterprise.CreatePolicyTransaction.verify(message.createPolicyTransaction);
                    if (error)
                        return "createPolicyTransaction." + error;
                }
            }
            if (message.updatePolicyTransaction != null && message.hasOwnProperty("updatePolicyTransaction")) {
                if (properties.transaction === 1)
                    return "transaction: multiple values";
                properties.transaction = 1;
                {
                    var error = $root.wavesenterprise.UpdatePolicyTransaction.verify(message.updatePolicyTransaction);
                    if (error)
                        return "updatePolicyTransaction." + error;
                }
            }
            if (message.policyDataHashTransaction != null && message.hasOwnProperty("policyDataHashTransaction")) {
                if (properties.transaction === 1)
                    return "transaction: multiple values";
                properties.transaction = 1;
                {
                    var error = $root.wavesenterprise.PolicyDataHashTransaction.verify(message.policyDataHashTransaction);
                    if (error)
                        return "policyDataHashTransaction." + error;
                }
            }
            if (message.createContractTransaction != null && message.hasOwnProperty("createContractTransaction")) {
                if (properties.transaction === 1)
                    return "transaction: multiple values";
                properties.transaction = 1;
                {
                    var error = $root.wavesenterprise.CreateContractTransaction.verify(message.createContractTransaction);
                    if (error)
                        return "createContractTransaction." + error;
                }
            }
            if (message.callContractTransaction != null && message.hasOwnProperty("callContractTransaction")) {
                if (properties.transaction === 1)
                    return "transaction: multiple values";
                properties.transaction = 1;
                {
                    var error = $root.wavesenterprise.CallContractTransaction.verify(message.callContractTransaction);
                    if (error)
                        return "callContractTransaction." + error;
                }
            }
            if (message.executedContractTransaction != null && message.hasOwnProperty("executedContractTransaction")) {
                if (properties.transaction === 1)
                    return "transaction: multiple values";
                properties.transaction = 1;
                {
                    var error = $root.wavesenterprise.ExecutedContractTransaction.verify(message.executedContractTransaction);
                    if (error)
                        return "executedContractTransaction." + error;
                }
            }
            if (message.disableContractTransaction != null && message.hasOwnProperty("disableContractTransaction")) {
                if (properties.transaction === 1)
                    return "transaction: multiple values";
                properties.transaction = 1;
                {
                    var error = $root.wavesenterprise.DisableContractTransaction.verify(message.disableContractTransaction);
                    if (error)
                        return "disableContractTransaction." + error;
                }
            }
            if (message.updateContractTransaction != null && message.hasOwnProperty("updateContractTransaction")) {
                if (properties.transaction === 1)
                    return "transaction: multiple values";
                properties.transaction = 1;
                {
                    var error = $root.wavesenterprise.UpdateContractTransaction.verify(message.updateContractTransaction);
                    if (error)
                        return "updateContractTransaction." + error;
                }
            }
            if (message.setScriptTransaction != null && message.hasOwnProperty("setScriptTransaction")) {
                if (properties.transaction === 1)
                    return "transaction: multiple values";
                properties.transaction = 1;
                {
                    var error = $root.wavesenterprise.SetScriptTransaction.verify(message.setScriptTransaction);
                    if (error)
                        return "setScriptTransaction." + error;
                }
            }
            if (message.atomicTransaction != null && message.hasOwnProperty("atomicTransaction")) {
                if (properties.transaction === 1)
                    return "transaction: multiple values";
                properties.transaction = 1;
                {
                    var error = $root.wavesenterprise.AtomicTransaction.verify(message.atomicTransaction);
                    if (error)
                        return "atomicTransaction." + error;
                }
            }
            return null;
        };

        /**
         * Creates a Transaction message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof wavesenterprise.Transaction
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {wavesenterprise.Transaction} Transaction
         */
        Transaction.fromObject = function fromObject(object) {
            if (object instanceof $root.wavesenterprise.Transaction)
                return object;
            var message = new $root.wavesenterprise.Transaction();
            if (object.version != null)
                message.version = object.version | 0;
            if (object.genesisTransaction != null) {
                if (typeof object.genesisTransaction !== "object")
                    throw TypeError(".wavesenterprise.Transaction.genesisTransaction: object expected");
                message.genesisTransaction = $root.wavesenterprise.GenesisTransaction.fromObject(object.genesisTransaction);
            }
            if (object.genesisPermitTransaction != null) {
                if (typeof object.genesisPermitTransaction !== "object")
                    throw TypeError(".wavesenterprise.Transaction.genesisPermitTransaction: object expected");
                message.genesisPermitTransaction = $root.wavesenterprise.GenesisPermitTransaction.fromObject(object.genesisPermitTransaction);
            }
            if (object.genesisRegisterNodeTransaction != null) {
                if (typeof object.genesisRegisterNodeTransaction !== "object")
                    throw TypeError(".wavesenterprise.Transaction.genesisRegisterNodeTransaction: object expected");
                message.genesisRegisterNodeTransaction = $root.wavesenterprise.GenesisRegisterNodeTransaction.fromObject(object.genesisRegisterNodeTransaction);
            }
            if (object.registerNodeTransaction != null) {
                if (typeof object.registerNodeTransaction !== "object")
                    throw TypeError(".wavesenterprise.Transaction.registerNodeTransaction: object expected");
                message.registerNodeTransaction = $root.wavesenterprise.RegisterNodeTransaction.fromObject(object.registerNodeTransaction);
            }
            if (object.createAliasTransaction != null) {
                if (typeof object.createAliasTransaction !== "object")
                    throw TypeError(".wavesenterprise.Transaction.createAliasTransaction: object expected");
                message.createAliasTransaction = $root.wavesenterprise.CreateAliasTransaction.fromObject(object.createAliasTransaction);
            }
            if (object.issueTransaction != null) {
                if (typeof object.issueTransaction !== "object")
                    throw TypeError(".wavesenterprise.Transaction.issueTransaction: object expected");
                message.issueTransaction = $root.wavesenterprise.IssueTransaction.fromObject(object.issueTransaction);
            }
            if (object.reissueTransaction != null) {
                if (typeof object.reissueTransaction !== "object")
                    throw TypeError(".wavesenterprise.Transaction.reissueTransaction: object expected");
                message.reissueTransaction = $root.wavesenterprise.ReissueTransaction.fromObject(object.reissueTransaction);
            }
            if (object.burnTransaction != null) {
                if (typeof object.burnTransaction !== "object")
                    throw TypeError(".wavesenterprise.Transaction.burnTransaction: object expected");
                message.burnTransaction = $root.wavesenterprise.BurnTransaction.fromObject(object.burnTransaction);
            }
            if (object.leaseTransaction != null) {
                if (typeof object.leaseTransaction !== "object")
                    throw TypeError(".wavesenterprise.Transaction.leaseTransaction: object expected");
                message.leaseTransaction = $root.wavesenterprise.LeaseTransaction.fromObject(object.leaseTransaction);
            }
            if (object.leaseCancelTransaction != null) {
                if (typeof object.leaseCancelTransaction !== "object")
                    throw TypeError(".wavesenterprise.Transaction.leaseCancelTransaction: object expected");
                message.leaseCancelTransaction = $root.wavesenterprise.LeaseCancelTransaction.fromObject(object.leaseCancelTransaction);
            }
            if (object.sponsorFeeTransaction != null) {
                if (typeof object.sponsorFeeTransaction !== "object")
                    throw TypeError(".wavesenterprise.Transaction.sponsorFeeTransaction: object expected");
                message.sponsorFeeTransaction = $root.wavesenterprise.SponsorFeeTransaction.fromObject(object.sponsorFeeTransaction);
            }
            if (object.setAssetScriptTransaction != null) {
                if (typeof object.setAssetScriptTransaction !== "object")
                    throw TypeError(".wavesenterprise.Transaction.setAssetScriptTransaction: object expected");
                message.setAssetScriptTransaction = $root.wavesenterprise.SetAssetScriptTransaction.fromObject(object.setAssetScriptTransaction);
            }
            if (object.dataTransaction != null) {
                if (typeof object.dataTransaction !== "object")
                    throw TypeError(".wavesenterprise.Transaction.dataTransaction: object expected");
                message.dataTransaction = $root.wavesenterprise.DataTransaction.fromObject(object.dataTransaction);
            }
            if (object.transferTransaction != null) {
                if (typeof object.transferTransaction !== "object")
                    throw TypeError(".wavesenterprise.Transaction.transferTransaction: object expected");
                message.transferTransaction = $root.wavesenterprise.TransferTransaction.fromObject(object.transferTransaction);
            }
            if (object.massTransferTransaction != null) {
                if (typeof object.massTransferTransaction !== "object")
                    throw TypeError(".wavesenterprise.Transaction.massTransferTransaction: object expected");
                message.massTransferTransaction = $root.wavesenterprise.MassTransferTransaction.fromObject(object.massTransferTransaction);
            }
            if (object.permitTransaction != null) {
                if (typeof object.permitTransaction !== "object")
                    throw TypeError(".wavesenterprise.Transaction.permitTransaction: object expected");
                message.permitTransaction = $root.wavesenterprise.PermitTransaction.fromObject(object.permitTransaction);
            }
            if (object.createPolicyTransaction != null) {
                if (typeof object.createPolicyTransaction !== "object")
                    throw TypeError(".wavesenterprise.Transaction.createPolicyTransaction: object expected");
                message.createPolicyTransaction = $root.wavesenterprise.CreatePolicyTransaction.fromObject(object.createPolicyTransaction);
            }
            if (object.updatePolicyTransaction != null) {
                if (typeof object.updatePolicyTransaction !== "object")
                    throw TypeError(".wavesenterprise.Transaction.updatePolicyTransaction: object expected");
                message.updatePolicyTransaction = $root.wavesenterprise.UpdatePolicyTransaction.fromObject(object.updatePolicyTransaction);
            }
            if (object.policyDataHashTransaction != null) {
                if (typeof object.policyDataHashTransaction !== "object")
                    throw TypeError(".wavesenterprise.Transaction.policyDataHashTransaction: object expected");
                message.policyDataHashTransaction = $root.wavesenterprise.PolicyDataHashTransaction.fromObject(object.policyDataHashTransaction);
            }
            if (object.createContractTransaction != null) {
                if (typeof object.createContractTransaction !== "object")
                    throw TypeError(".wavesenterprise.Transaction.createContractTransaction: object expected");
                message.createContractTransaction = $root.wavesenterprise.CreateContractTransaction.fromObject(object.createContractTransaction);
            }
            if (object.callContractTransaction != null) {
                if (typeof object.callContractTransaction !== "object")
                    throw TypeError(".wavesenterprise.Transaction.callContractTransaction: object expected");
                message.callContractTransaction = $root.wavesenterprise.CallContractTransaction.fromObject(object.callContractTransaction);
            }
            if (object.executedContractTransaction != null) {
                if (typeof object.executedContractTransaction !== "object")
                    throw TypeError(".wavesenterprise.Transaction.executedContractTransaction: object expected");
                message.executedContractTransaction = $root.wavesenterprise.ExecutedContractTransaction.fromObject(object.executedContractTransaction);
            }
            if (object.disableContractTransaction != null) {
                if (typeof object.disableContractTransaction !== "object")
                    throw TypeError(".wavesenterprise.Transaction.disableContractTransaction: object expected");
                message.disableContractTransaction = $root.wavesenterprise.DisableContractTransaction.fromObject(object.disableContractTransaction);
            }
            if (object.updateContractTransaction != null) {
                if (typeof object.updateContractTransaction !== "object")
                    throw TypeError(".wavesenterprise.Transaction.updateContractTransaction: object expected");
                message.updateContractTransaction = $root.wavesenterprise.UpdateContractTransaction.fromObject(object.updateContractTransaction);
            }
            if (object.setScriptTransaction != null) {
                if (typeof object.setScriptTransaction !== "object")
                    throw TypeError(".wavesenterprise.Transaction.setScriptTransaction: object expected");
                message.setScriptTransaction = $root.wavesenterprise.SetScriptTransaction.fromObject(object.setScriptTransaction);
            }
            if (object.atomicTransaction != null) {
                if (typeof object.atomicTransaction !== "object")
                    throw TypeError(".wavesenterprise.Transaction.atomicTransaction: object expected");
                message.atomicTransaction = $root.wavesenterprise.AtomicTransaction.fromObject(object.atomicTransaction);
            }
            return message;
        };

        /**
         * Creates a plain object from a Transaction message. Also converts values to other types if specified.
         * @function toObject
         * @memberof wavesenterprise.Transaction
         * @static
         * @param {wavesenterprise.Transaction} message Transaction
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Transaction.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.version = 0;
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            if (message.genesisTransaction != null && message.hasOwnProperty("genesisTransaction")) {
                object.genesisTransaction = $root.wavesenterprise.GenesisTransaction.toObject(message.genesisTransaction, options);
                if (options.oneofs)
                    object.transaction = "genesisTransaction";
            }
            if (message.genesisPermitTransaction != null && message.hasOwnProperty("genesisPermitTransaction")) {
                object.genesisPermitTransaction = $root.wavesenterprise.GenesisPermitTransaction.toObject(message.genesisPermitTransaction, options);
                if (options.oneofs)
                    object.transaction = "genesisPermitTransaction";
            }
            if (message.genesisRegisterNodeTransaction != null && message.hasOwnProperty("genesisRegisterNodeTransaction")) {
                object.genesisRegisterNodeTransaction = $root.wavesenterprise.GenesisRegisterNodeTransaction.toObject(message.genesisRegisterNodeTransaction, options);
                if (options.oneofs)
                    object.transaction = "genesisRegisterNodeTransaction";
            }
            if (message.registerNodeTransaction != null && message.hasOwnProperty("registerNodeTransaction")) {
                object.registerNodeTransaction = $root.wavesenterprise.RegisterNodeTransaction.toObject(message.registerNodeTransaction, options);
                if (options.oneofs)
                    object.transaction = "registerNodeTransaction";
            }
            if (message.createAliasTransaction != null && message.hasOwnProperty("createAliasTransaction")) {
                object.createAliasTransaction = $root.wavesenterprise.CreateAliasTransaction.toObject(message.createAliasTransaction, options);
                if (options.oneofs)
                    object.transaction = "createAliasTransaction";
            }
            if (message.issueTransaction != null && message.hasOwnProperty("issueTransaction")) {
                object.issueTransaction = $root.wavesenterprise.IssueTransaction.toObject(message.issueTransaction, options);
                if (options.oneofs)
                    object.transaction = "issueTransaction";
            }
            if (message.reissueTransaction != null && message.hasOwnProperty("reissueTransaction")) {
                object.reissueTransaction = $root.wavesenterprise.ReissueTransaction.toObject(message.reissueTransaction, options);
                if (options.oneofs)
                    object.transaction = "reissueTransaction";
            }
            if (message.burnTransaction != null && message.hasOwnProperty("burnTransaction")) {
                object.burnTransaction = $root.wavesenterprise.BurnTransaction.toObject(message.burnTransaction, options);
                if (options.oneofs)
                    object.transaction = "burnTransaction";
            }
            if (message.leaseTransaction != null && message.hasOwnProperty("leaseTransaction")) {
                object.leaseTransaction = $root.wavesenterprise.LeaseTransaction.toObject(message.leaseTransaction, options);
                if (options.oneofs)
                    object.transaction = "leaseTransaction";
            }
            if (message.leaseCancelTransaction != null && message.hasOwnProperty("leaseCancelTransaction")) {
                object.leaseCancelTransaction = $root.wavesenterprise.LeaseCancelTransaction.toObject(message.leaseCancelTransaction, options);
                if (options.oneofs)
                    object.transaction = "leaseCancelTransaction";
            }
            if (message.sponsorFeeTransaction != null && message.hasOwnProperty("sponsorFeeTransaction")) {
                object.sponsorFeeTransaction = $root.wavesenterprise.SponsorFeeTransaction.toObject(message.sponsorFeeTransaction, options);
                if (options.oneofs)
                    object.transaction = "sponsorFeeTransaction";
            }
            if (message.setAssetScriptTransaction != null && message.hasOwnProperty("setAssetScriptTransaction")) {
                object.setAssetScriptTransaction = $root.wavesenterprise.SetAssetScriptTransaction.toObject(message.setAssetScriptTransaction, options);
                if (options.oneofs)
                    object.transaction = "setAssetScriptTransaction";
            }
            if (message.dataTransaction != null && message.hasOwnProperty("dataTransaction")) {
                object.dataTransaction = $root.wavesenterprise.DataTransaction.toObject(message.dataTransaction, options);
                if (options.oneofs)
                    object.transaction = "dataTransaction";
            }
            if (message.transferTransaction != null && message.hasOwnProperty("transferTransaction")) {
                object.transferTransaction = $root.wavesenterprise.TransferTransaction.toObject(message.transferTransaction, options);
                if (options.oneofs)
                    object.transaction = "transferTransaction";
            }
            if (message.massTransferTransaction != null && message.hasOwnProperty("massTransferTransaction")) {
                object.massTransferTransaction = $root.wavesenterprise.MassTransferTransaction.toObject(message.massTransferTransaction, options);
                if (options.oneofs)
                    object.transaction = "massTransferTransaction";
            }
            if (message.permitTransaction != null && message.hasOwnProperty("permitTransaction")) {
                object.permitTransaction = $root.wavesenterprise.PermitTransaction.toObject(message.permitTransaction, options);
                if (options.oneofs)
                    object.transaction = "permitTransaction";
            }
            if (message.createPolicyTransaction != null && message.hasOwnProperty("createPolicyTransaction")) {
                object.createPolicyTransaction = $root.wavesenterprise.CreatePolicyTransaction.toObject(message.createPolicyTransaction, options);
                if (options.oneofs)
                    object.transaction = "createPolicyTransaction";
            }
            if (message.updatePolicyTransaction != null && message.hasOwnProperty("updatePolicyTransaction")) {
                object.updatePolicyTransaction = $root.wavesenterprise.UpdatePolicyTransaction.toObject(message.updatePolicyTransaction, options);
                if (options.oneofs)
                    object.transaction = "updatePolicyTransaction";
            }
            if (message.policyDataHashTransaction != null && message.hasOwnProperty("policyDataHashTransaction")) {
                object.policyDataHashTransaction = $root.wavesenterprise.PolicyDataHashTransaction.toObject(message.policyDataHashTransaction, options);
                if (options.oneofs)
                    object.transaction = "policyDataHashTransaction";
            }
            if (message.createContractTransaction != null && message.hasOwnProperty("createContractTransaction")) {
                object.createContractTransaction = $root.wavesenterprise.CreateContractTransaction.toObject(message.createContractTransaction, options);
                if (options.oneofs)
                    object.transaction = "createContractTransaction";
            }
            if (message.callContractTransaction != null && message.hasOwnProperty("callContractTransaction")) {
                object.callContractTransaction = $root.wavesenterprise.CallContractTransaction.toObject(message.callContractTransaction, options);
                if (options.oneofs)
                    object.transaction = "callContractTransaction";
            }
            if (message.executedContractTransaction != null && message.hasOwnProperty("executedContractTransaction")) {
                object.executedContractTransaction = $root.wavesenterprise.ExecutedContractTransaction.toObject(message.executedContractTransaction, options);
                if (options.oneofs)
                    object.transaction = "executedContractTransaction";
            }
            if (message.disableContractTransaction != null && message.hasOwnProperty("disableContractTransaction")) {
                object.disableContractTransaction = $root.wavesenterprise.DisableContractTransaction.toObject(message.disableContractTransaction, options);
                if (options.oneofs)
                    object.transaction = "disableContractTransaction";
            }
            if (message.updateContractTransaction != null && message.hasOwnProperty("updateContractTransaction")) {
                object.updateContractTransaction = $root.wavesenterprise.UpdateContractTransaction.toObject(message.updateContractTransaction, options);
                if (options.oneofs)
                    object.transaction = "updateContractTransaction";
            }
            if (message.setScriptTransaction != null && message.hasOwnProperty("setScriptTransaction")) {
                object.setScriptTransaction = $root.wavesenterprise.SetScriptTransaction.toObject(message.setScriptTransaction, options);
                if (options.oneofs)
                    object.transaction = "setScriptTransaction";
            }
            if (message.atomicTransaction != null && message.hasOwnProperty("atomicTransaction")) {
                object.atomicTransaction = $root.wavesenterprise.AtomicTransaction.toObject(message.atomicTransaction, options);
                if (options.oneofs)
                    object.transaction = "atomicTransaction";
            }
            return object;
        };

        /**
         * Converts this Transaction to JSON.
         * @function toJSON
         * @memberof wavesenterprise.Transaction
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Transaction.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Transaction;
    })();

    wavesenterprise.GenesisTransaction = (function() {

        /**
         * Properties of a GenesisTransaction.
         * @memberof wavesenterprise
         * @interface IGenesisTransaction
         * @property {Uint8Array|null} [id] GenesisTransaction id
         * @property {Uint8Array|null} [recipient] GenesisTransaction recipient
         * @property {number|Long|null} [amount] GenesisTransaction amount
         * @property {number|Long|null} [fee] GenesisTransaction fee
         * @property {number|Long|null} [timestamp] GenesisTransaction timestamp
         * @property {Uint8Array|null} [signature] GenesisTransaction signature
         */

        /**
         * Constructs a new GenesisTransaction.
         * @memberof wavesenterprise
         * @classdesc Represents a GenesisTransaction.
         * @implements IGenesisTransaction
         * @constructor
         * @param {wavesenterprise.IGenesisTransaction=} [properties] Properties to set
         */
        function GenesisTransaction(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GenesisTransaction id.
         * @member {Uint8Array} id
         * @memberof wavesenterprise.GenesisTransaction
         * @instance
         */
        GenesisTransaction.prototype.id = $util.newBuffer([]);

        /**
         * GenesisTransaction recipient.
         * @member {Uint8Array} recipient
         * @memberof wavesenterprise.GenesisTransaction
         * @instance
         */
        GenesisTransaction.prototype.recipient = $util.newBuffer([]);

        /**
         * GenesisTransaction amount.
         * @member {number|Long} amount
         * @memberof wavesenterprise.GenesisTransaction
         * @instance
         */
        GenesisTransaction.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * GenesisTransaction fee.
         * @member {number|Long} fee
         * @memberof wavesenterprise.GenesisTransaction
         * @instance
         */
        GenesisTransaction.prototype.fee = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * GenesisTransaction timestamp.
         * @member {number|Long} timestamp
         * @memberof wavesenterprise.GenesisTransaction
         * @instance
         */
        GenesisTransaction.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * GenesisTransaction signature.
         * @member {Uint8Array} signature
         * @memberof wavesenterprise.GenesisTransaction
         * @instance
         */
        GenesisTransaction.prototype.signature = $util.newBuffer([]);

        /**
         * Creates a new GenesisTransaction instance using the specified properties.
         * @function create
         * @memberof wavesenterprise.GenesisTransaction
         * @static
         * @param {wavesenterprise.IGenesisTransaction=} [properties] Properties to set
         * @returns {wavesenterprise.GenesisTransaction} GenesisTransaction instance
         */
        GenesisTransaction.create = function create(properties) {
            return new GenesisTransaction(properties);
        };

        /**
         * Encodes the specified GenesisTransaction message. Does not implicitly {@link wavesenterprise.GenesisTransaction.verify|verify} messages.
         * @function encode
         * @memberof wavesenterprise.GenesisTransaction
         * @static
         * @param {wavesenterprise.IGenesisTransaction} message GenesisTransaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GenesisTransaction.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.id);
            if (message.recipient != null && Object.hasOwnProperty.call(message, "recipient"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.recipient);
            if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.amount);
            if (message.fee != null && Object.hasOwnProperty.call(message, "fee"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.fee);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.timestamp);
            if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.signature);
            return writer;
        };

        /**
         * Encodes the specified GenesisTransaction message, length delimited. Does not implicitly {@link wavesenterprise.GenesisTransaction.verify|verify} messages.
         * @function encodeDelimited
         * @memberof wavesenterprise.GenesisTransaction
         * @static
         * @param {wavesenterprise.IGenesisTransaction} message GenesisTransaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GenesisTransaction.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GenesisTransaction message from the specified reader or buffer.
         * @function decode
         * @memberof wavesenterprise.GenesisTransaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {wavesenterprise.GenesisTransaction} GenesisTransaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GenesisTransaction.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.wavesenterprise.GenesisTransaction();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.bytes();
                    break;
                case 2:
                    message.recipient = reader.bytes();
                    break;
                case 3:
                    message.amount = reader.int64();
                    break;
                case 4:
                    message.fee = reader.int64();
                    break;
                case 5:
                    message.timestamp = reader.int64();
                    break;
                case 6:
                    message.signature = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GenesisTransaction message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof wavesenterprise.GenesisTransaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {wavesenterprise.GenesisTransaction} GenesisTransaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GenesisTransaction.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GenesisTransaction message.
         * @function verify
         * @memberof wavesenterprise.GenesisTransaction
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GenesisTransaction.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!(message.id && typeof message.id.length === "number" || $util.isString(message.id)))
                    return "id: buffer expected";
            if (message.recipient != null && message.hasOwnProperty("recipient"))
                if (!(message.recipient && typeof message.recipient.length === "number" || $util.isString(message.recipient)))
                    return "recipient: buffer expected";
            if (message.amount != null && message.hasOwnProperty("amount"))
                if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                    return "amount: integer|Long expected";
            if (message.fee != null && message.hasOwnProperty("fee"))
                if (!$util.isInteger(message.fee) && !(message.fee && $util.isInteger(message.fee.low) && $util.isInteger(message.fee.high)))
                    return "fee: integer|Long expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            if (message.signature != null && message.hasOwnProperty("signature"))
                if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                    return "signature: buffer expected";
            return null;
        };

        /**
         * Creates a GenesisTransaction message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof wavesenterprise.GenesisTransaction
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {wavesenterprise.GenesisTransaction} GenesisTransaction
         */
        GenesisTransaction.fromObject = function fromObject(object) {
            if (object instanceof $root.wavesenterprise.GenesisTransaction)
                return object;
            var message = new $root.wavesenterprise.GenesisTransaction();
            if (object.id != null)
                if (typeof object.id === "string")
                    $util.base64.decode(object.id, message.id = $util.newBuffer($util.base64.length(object.id)), 0);
                else if (object.id.length)
                    message.id = object.id;
            if (object.recipient != null)
                if (typeof object.recipient === "string")
                    $util.base64.decode(object.recipient, message.recipient = $util.newBuffer($util.base64.length(object.recipient)), 0);
                else if (object.recipient.length)
                    message.recipient = object.recipient;
            if (object.amount != null)
                if ($util.Long)
                    (message.amount = $util.Long.fromValue(object.amount)).unsigned = false;
                else if (typeof object.amount === "string")
                    message.amount = parseInt(object.amount, 10);
                else if (typeof object.amount === "number")
                    message.amount = object.amount;
                else if (typeof object.amount === "object")
                    message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber();
            if (object.fee != null)
                if ($util.Long)
                    (message.fee = $util.Long.fromValue(object.fee)).unsigned = false;
                else if (typeof object.fee === "string")
                    message.fee = parseInt(object.fee, 10);
                else if (typeof object.fee === "number")
                    message.fee = object.fee;
                else if (typeof object.fee === "object")
                    message.fee = new $util.LongBits(object.fee.low >>> 0, object.fee.high >>> 0).toNumber();
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            if (object.signature != null)
                if (typeof object.signature === "string")
                    $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                else if (object.signature.length)
                    message.signature = object.signature;
            return message;
        };

        /**
         * Creates a plain object from a GenesisTransaction message. Also converts values to other types if specified.
         * @function toObject
         * @memberof wavesenterprise.GenesisTransaction
         * @static
         * @param {wavesenterprise.GenesisTransaction} message GenesisTransaction
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GenesisTransaction.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.id = "";
                else {
                    object.id = [];
                    if (options.bytes !== Array)
                        object.id = $util.newBuffer(object.id);
                }
                if (options.bytes === String)
                    object.recipient = "";
                else {
                    object.recipient = [];
                    if (options.bytes !== Array)
                        object.recipient = $util.newBuffer(object.recipient);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.amount = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.fee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.fee = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.signature = "";
                else {
                    object.signature = [];
                    if (options.bytes !== Array)
                        object.signature = $util.newBuffer(object.signature);
                }
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = options.bytes === String ? $util.base64.encode(message.id, 0, message.id.length) : options.bytes === Array ? Array.prototype.slice.call(message.id) : message.id;
            if (message.recipient != null && message.hasOwnProperty("recipient"))
                object.recipient = options.bytes === String ? $util.base64.encode(message.recipient, 0, message.recipient.length) : options.bytes === Array ? Array.prototype.slice.call(message.recipient) : message.recipient;
            if (message.amount != null && message.hasOwnProperty("amount"))
                if (typeof message.amount === "number")
                    object.amount = options.longs === String ? String(message.amount) : message.amount;
                else
                    object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber() : message.amount;
            if (message.fee != null && message.hasOwnProperty("fee"))
                if (typeof message.fee === "number")
                    object.fee = options.longs === String ? String(message.fee) : message.fee;
                else
                    object.fee = options.longs === String ? $util.Long.prototype.toString.call(message.fee) : options.longs === Number ? new $util.LongBits(message.fee.low >>> 0, message.fee.high >>> 0).toNumber() : message.fee;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            if (message.signature != null && message.hasOwnProperty("signature"))
                object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
            return object;
        };

        /**
         * Converts this GenesisTransaction to JSON.
         * @function toJSON
         * @memberof wavesenterprise.GenesisTransaction
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GenesisTransaction.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GenesisTransaction;
    })();

    wavesenterprise.GenesisPermitTransaction = (function() {

        /**
         * Properties of a GenesisPermitTransaction.
         * @memberof wavesenterprise
         * @interface IGenesisPermitTransaction
         * @property {Uint8Array|null} [id] GenesisPermitTransaction id
         * @property {Uint8Array|null} [target] GenesisPermitTransaction target
         * @property {wavesenterprise.IRole|null} [role] GenesisPermitTransaction role
         * @property {number|Long|null} [fee] GenesisPermitTransaction fee
         * @property {number|Long|null} [timestamp] GenesisPermitTransaction timestamp
         * @property {Uint8Array|null} [signature] GenesisPermitTransaction signature
         */

        /**
         * Constructs a new GenesisPermitTransaction.
         * @memberof wavesenterprise
         * @classdesc Represents a GenesisPermitTransaction.
         * @implements IGenesisPermitTransaction
         * @constructor
         * @param {wavesenterprise.IGenesisPermitTransaction=} [properties] Properties to set
         */
        function GenesisPermitTransaction(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GenesisPermitTransaction id.
         * @member {Uint8Array} id
         * @memberof wavesenterprise.GenesisPermitTransaction
         * @instance
         */
        GenesisPermitTransaction.prototype.id = $util.newBuffer([]);

        /**
         * GenesisPermitTransaction target.
         * @member {Uint8Array} target
         * @memberof wavesenterprise.GenesisPermitTransaction
         * @instance
         */
        GenesisPermitTransaction.prototype.target = $util.newBuffer([]);

        /**
         * GenesisPermitTransaction role.
         * @member {wavesenterprise.IRole|null|undefined} role
         * @memberof wavesenterprise.GenesisPermitTransaction
         * @instance
         */
        GenesisPermitTransaction.prototype.role = null;

        /**
         * GenesisPermitTransaction fee.
         * @member {number|Long} fee
         * @memberof wavesenterprise.GenesisPermitTransaction
         * @instance
         */
        GenesisPermitTransaction.prototype.fee = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * GenesisPermitTransaction timestamp.
         * @member {number|Long} timestamp
         * @memberof wavesenterprise.GenesisPermitTransaction
         * @instance
         */
        GenesisPermitTransaction.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * GenesisPermitTransaction signature.
         * @member {Uint8Array} signature
         * @memberof wavesenterprise.GenesisPermitTransaction
         * @instance
         */
        GenesisPermitTransaction.prototype.signature = $util.newBuffer([]);

        /**
         * Creates a new GenesisPermitTransaction instance using the specified properties.
         * @function create
         * @memberof wavesenterprise.GenesisPermitTransaction
         * @static
         * @param {wavesenterprise.IGenesisPermitTransaction=} [properties] Properties to set
         * @returns {wavesenterprise.GenesisPermitTransaction} GenesisPermitTransaction instance
         */
        GenesisPermitTransaction.create = function create(properties) {
            return new GenesisPermitTransaction(properties);
        };

        /**
         * Encodes the specified GenesisPermitTransaction message. Does not implicitly {@link wavesenterprise.GenesisPermitTransaction.verify|verify} messages.
         * @function encode
         * @memberof wavesenterprise.GenesisPermitTransaction
         * @static
         * @param {wavesenterprise.IGenesisPermitTransaction} message GenesisPermitTransaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GenesisPermitTransaction.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.id);
            if (message.target != null && Object.hasOwnProperty.call(message, "target"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.target);
            if (message.role != null && Object.hasOwnProperty.call(message, "role"))
                $root.wavesenterprise.Role.encode(message.role, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.fee != null && Object.hasOwnProperty.call(message, "fee"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.fee);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.timestamp);
            if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.signature);
            return writer;
        };

        /**
         * Encodes the specified GenesisPermitTransaction message, length delimited. Does not implicitly {@link wavesenterprise.GenesisPermitTransaction.verify|verify} messages.
         * @function encodeDelimited
         * @memberof wavesenterprise.GenesisPermitTransaction
         * @static
         * @param {wavesenterprise.IGenesisPermitTransaction} message GenesisPermitTransaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GenesisPermitTransaction.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GenesisPermitTransaction message from the specified reader or buffer.
         * @function decode
         * @memberof wavesenterprise.GenesisPermitTransaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {wavesenterprise.GenesisPermitTransaction} GenesisPermitTransaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GenesisPermitTransaction.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.wavesenterprise.GenesisPermitTransaction();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.bytes();
                    break;
                case 2:
                    message.target = reader.bytes();
                    break;
                case 3:
                    message.role = $root.wavesenterprise.Role.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.fee = reader.int64();
                    break;
                case 5:
                    message.timestamp = reader.int64();
                    break;
                case 6:
                    message.signature = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GenesisPermitTransaction message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof wavesenterprise.GenesisPermitTransaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {wavesenterprise.GenesisPermitTransaction} GenesisPermitTransaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GenesisPermitTransaction.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GenesisPermitTransaction message.
         * @function verify
         * @memberof wavesenterprise.GenesisPermitTransaction
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GenesisPermitTransaction.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!(message.id && typeof message.id.length === "number" || $util.isString(message.id)))
                    return "id: buffer expected";
            if (message.target != null && message.hasOwnProperty("target"))
                if (!(message.target && typeof message.target.length === "number" || $util.isString(message.target)))
                    return "target: buffer expected";
            if (message.role != null && message.hasOwnProperty("role")) {
                var error = $root.wavesenterprise.Role.verify(message.role);
                if (error)
                    return "role." + error;
            }
            if (message.fee != null && message.hasOwnProperty("fee"))
                if (!$util.isInteger(message.fee) && !(message.fee && $util.isInteger(message.fee.low) && $util.isInteger(message.fee.high)))
                    return "fee: integer|Long expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            if (message.signature != null && message.hasOwnProperty("signature"))
                if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                    return "signature: buffer expected";
            return null;
        };

        /**
         * Creates a GenesisPermitTransaction message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof wavesenterprise.GenesisPermitTransaction
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {wavesenterprise.GenesisPermitTransaction} GenesisPermitTransaction
         */
        GenesisPermitTransaction.fromObject = function fromObject(object) {
            if (object instanceof $root.wavesenterprise.GenesisPermitTransaction)
                return object;
            var message = new $root.wavesenterprise.GenesisPermitTransaction();
            if (object.id != null)
                if (typeof object.id === "string")
                    $util.base64.decode(object.id, message.id = $util.newBuffer($util.base64.length(object.id)), 0);
                else if (object.id.length)
                    message.id = object.id;
            if (object.target != null)
                if (typeof object.target === "string")
                    $util.base64.decode(object.target, message.target = $util.newBuffer($util.base64.length(object.target)), 0);
                else if (object.target.length)
                    message.target = object.target;
            if (object.role != null) {
                if (typeof object.role !== "object")
                    throw TypeError(".wavesenterprise.GenesisPermitTransaction.role: object expected");
                message.role = $root.wavesenterprise.Role.fromObject(object.role);
            }
            if (object.fee != null)
                if ($util.Long)
                    (message.fee = $util.Long.fromValue(object.fee)).unsigned = false;
                else if (typeof object.fee === "string")
                    message.fee = parseInt(object.fee, 10);
                else if (typeof object.fee === "number")
                    message.fee = object.fee;
                else if (typeof object.fee === "object")
                    message.fee = new $util.LongBits(object.fee.low >>> 0, object.fee.high >>> 0).toNumber();
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            if (object.signature != null)
                if (typeof object.signature === "string")
                    $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                else if (object.signature.length)
                    message.signature = object.signature;
            return message;
        };

        /**
         * Creates a plain object from a GenesisPermitTransaction message. Also converts values to other types if specified.
         * @function toObject
         * @memberof wavesenterprise.GenesisPermitTransaction
         * @static
         * @param {wavesenterprise.GenesisPermitTransaction} message GenesisPermitTransaction
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GenesisPermitTransaction.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.id = "";
                else {
                    object.id = [];
                    if (options.bytes !== Array)
                        object.id = $util.newBuffer(object.id);
                }
                if (options.bytes === String)
                    object.target = "";
                else {
                    object.target = [];
                    if (options.bytes !== Array)
                        object.target = $util.newBuffer(object.target);
                }
                object.role = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.fee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.fee = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.signature = "";
                else {
                    object.signature = [];
                    if (options.bytes !== Array)
                        object.signature = $util.newBuffer(object.signature);
                }
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = options.bytes === String ? $util.base64.encode(message.id, 0, message.id.length) : options.bytes === Array ? Array.prototype.slice.call(message.id) : message.id;
            if (message.target != null && message.hasOwnProperty("target"))
                object.target = options.bytes === String ? $util.base64.encode(message.target, 0, message.target.length) : options.bytes === Array ? Array.prototype.slice.call(message.target) : message.target;
            if (message.role != null && message.hasOwnProperty("role"))
                object.role = $root.wavesenterprise.Role.toObject(message.role, options);
            if (message.fee != null && message.hasOwnProperty("fee"))
                if (typeof message.fee === "number")
                    object.fee = options.longs === String ? String(message.fee) : message.fee;
                else
                    object.fee = options.longs === String ? $util.Long.prototype.toString.call(message.fee) : options.longs === Number ? new $util.LongBits(message.fee.low >>> 0, message.fee.high >>> 0).toNumber() : message.fee;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            if (message.signature != null && message.hasOwnProperty("signature"))
                object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
            return object;
        };

        /**
         * Converts this GenesisPermitTransaction to JSON.
         * @function toJSON
         * @memberof wavesenterprise.GenesisPermitTransaction
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GenesisPermitTransaction.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GenesisPermitTransaction;
    })();

    wavesenterprise.Role = (function() {

        /**
         * Properties of a Role.
         * @memberof wavesenterprise
         * @interface IRole
         * @property {number|null} [id] Role id
         */

        /**
         * Constructs a new Role.
         * @memberof wavesenterprise
         * @classdesc Represents a Role.
         * @implements IRole
         * @constructor
         * @param {wavesenterprise.IRole=} [properties] Properties to set
         */
        function Role(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Role id.
         * @member {number} id
         * @memberof wavesenterprise.Role
         * @instance
         */
        Role.prototype.id = 0;

        /**
         * Creates a new Role instance using the specified properties.
         * @function create
         * @memberof wavesenterprise.Role
         * @static
         * @param {wavesenterprise.IRole=} [properties] Properties to set
         * @returns {wavesenterprise.Role} Role instance
         */
        Role.create = function create(properties) {
            return new Role(properties);
        };

        /**
         * Encodes the specified Role message. Does not implicitly {@link wavesenterprise.Role.verify|verify} messages.
         * @function encode
         * @memberof wavesenterprise.Role
         * @static
         * @param {wavesenterprise.IRole} message Role message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Role.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            return writer;
        };

        /**
         * Encodes the specified Role message, length delimited. Does not implicitly {@link wavesenterprise.Role.verify|verify} messages.
         * @function encodeDelimited
         * @memberof wavesenterprise.Role
         * @static
         * @param {wavesenterprise.IRole} message Role message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Role.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Role message from the specified reader or buffer.
         * @function decode
         * @memberof wavesenterprise.Role
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {wavesenterprise.Role} Role
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Role.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.wavesenterprise.Role();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Role message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof wavesenterprise.Role
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {wavesenterprise.Role} Role
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Role.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Role message.
         * @function verify
         * @memberof wavesenterprise.Role
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Role.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            return null;
        };

        /**
         * Creates a Role message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof wavesenterprise.Role
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {wavesenterprise.Role} Role
         */
        Role.fromObject = function fromObject(object) {
            if (object instanceof $root.wavesenterprise.Role)
                return object;
            var message = new $root.wavesenterprise.Role();
            if (object.id != null)
                message.id = object.id | 0;
            return message;
        };

        /**
         * Creates a plain object from a Role message. Also converts values to other types if specified.
         * @function toObject
         * @memberof wavesenterprise.Role
         * @static
         * @param {wavesenterprise.Role} message Role
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Role.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.id = 0;
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            return object;
        };

        /**
         * Converts this Role to JSON.
         * @function toJSON
         * @memberof wavesenterprise.Role
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Role.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Role;
    })();

    wavesenterprise.GenesisRegisterNodeTransaction = (function() {

        /**
         * Properties of a GenesisRegisterNodeTransaction.
         * @memberof wavesenterprise
         * @interface IGenesisRegisterNodeTransaction
         * @property {Uint8Array|null} [id] GenesisRegisterNodeTransaction id
         * @property {Uint8Array|null} [targetPublicKey] GenesisRegisterNodeTransaction targetPublicKey
         * @property {number|Long|null} [fee] GenesisRegisterNodeTransaction fee
         * @property {number|Long|null} [timestamp] GenesisRegisterNodeTransaction timestamp
         * @property {Uint8Array|null} [signature] GenesisRegisterNodeTransaction signature
         */

        /**
         * Constructs a new GenesisRegisterNodeTransaction.
         * @memberof wavesenterprise
         * @classdesc Represents a GenesisRegisterNodeTransaction.
         * @implements IGenesisRegisterNodeTransaction
         * @constructor
         * @param {wavesenterprise.IGenesisRegisterNodeTransaction=} [properties] Properties to set
         */
        function GenesisRegisterNodeTransaction(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GenesisRegisterNodeTransaction id.
         * @member {Uint8Array} id
         * @memberof wavesenterprise.GenesisRegisterNodeTransaction
         * @instance
         */
        GenesisRegisterNodeTransaction.prototype.id = $util.newBuffer([]);

        /**
         * GenesisRegisterNodeTransaction targetPublicKey.
         * @member {Uint8Array} targetPublicKey
         * @memberof wavesenterprise.GenesisRegisterNodeTransaction
         * @instance
         */
        GenesisRegisterNodeTransaction.prototype.targetPublicKey = $util.newBuffer([]);

        /**
         * GenesisRegisterNodeTransaction fee.
         * @member {number|Long} fee
         * @memberof wavesenterprise.GenesisRegisterNodeTransaction
         * @instance
         */
        GenesisRegisterNodeTransaction.prototype.fee = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * GenesisRegisterNodeTransaction timestamp.
         * @member {number|Long} timestamp
         * @memberof wavesenterprise.GenesisRegisterNodeTransaction
         * @instance
         */
        GenesisRegisterNodeTransaction.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * GenesisRegisterNodeTransaction signature.
         * @member {Uint8Array} signature
         * @memberof wavesenterprise.GenesisRegisterNodeTransaction
         * @instance
         */
        GenesisRegisterNodeTransaction.prototype.signature = $util.newBuffer([]);

        /**
         * Creates a new GenesisRegisterNodeTransaction instance using the specified properties.
         * @function create
         * @memberof wavesenterprise.GenesisRegisterNodeTransaction
         * @static
         * @param {wavesenterprise.IGenesisRegisterNodeTransaction=} [properties] Properties to set
         * @returns {wavesenterprise.GenesisRegisterNodeTransaction} GenesisRegisterNodeTransaction instance
         */
        GenesisRegisterNodeTransaction.create = function create(properties) {
            return new GenesisRegisterNodeTransaction(properties);
        };

        /**
         * Encodes the specified GenesisRegisterNodeTransaction message. Does not implicitly {@link wavesenterprise.GenesisRegisterNodeTransaction.verify|verify} messages.
         * @function encode
         * @memberof wavesenterprise.GenesisRegisterNodeTransaction
         * @static
         * @param {wavesenterprise.IGenesisRegisterNodeTransaction} message GenesisRegisterNodeTransaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GenesisRegisterNodeTransaction.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.id);
            if (message.targetPublicKey != null && Object.hasOwnProperty.call(message, "targetPublicKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.targetPublicKey);
            if (message.fee != null && Object.hasOwnProperty.call(message, "fee"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.fee);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.timestamp);
            if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.signature);
            return writer;
        };

        /**
         * Encodes the specified GenesisRegisterNodeTransaction message, length delimited. Does not implicitly {@link wavesenterprise.GenesisRegisterNodeTransaction.verify|verify} messages.
         * @function encodeDelimited
         * @memberof wavesenterprise.GenesisRegisterNodeTransaction
         * @static
         * @param {wavesenterprise.IGenesisRegisterNodeTransaction} message GenesisRegisterNodeTransaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GenesisRegisterNodeTransaction.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GenesisRegisterNodeTransaction message from the specified reader or buffer.
         * @function decode
         * @memberof wavesenterprise.GenesisRegisterNodeTransaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {wavesenterprise.GenesisRegisterNodeTransaction} GenesisRegisterNodeTransaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GenesisRegisterNodeTransaction.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.wavesenterprise.GenesisRegisterNodeTransaction();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.bytes();
                    break;
                case 2:
                    message.targetPublicKey = reader.bytes();
                    break;
                case 4:
                    message.fee = reader.int64();
                    break;
                case 5:
                    message.timestamp = reader.int64();
                    break;
                case 6:
                    message.signature = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GenesisRegisterNodeTransaction message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof wavesenterprise.GenesisRegisterNodeTransaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {wavesenterprise.GenesisRegisterNodeTransaction} GenesisRegisterNodeTransaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GenesisRegisterNodeTransaction.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GenesisRegisterNodeTransaction message.
         * @function verify
         * @memberof wavesenterprise.GenesisRegisterNodeTransaction
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GenesisRegisterNodeTransaction.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!(message.id && typeof message.id.length === "number" || $util.isString(message.id)))
                    return "id: buffer expected";
            if (message.targetPublicKey != null && message.hasOwnProperty("targetPublicKey"))
                if (!(message.targetPublicKey && typeof message.targetPublicKey.length === "number" || $util.isString(message.targetPublicKey)))
                    return "targetPublicKey: buffer expected";
            if (message.fee != null && message.hasOwnProperty("fee"))
                if (!$util.isInteger(message.fee) && !(message.fee && $util.isInteger(message.fee.low) && $util.isInteger(message.fee.high)))
                    return "fee: integer|Long expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            if (message.signature != null && message.hasOwnProperty("signature"))
                if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                    return "signature: buffer expected";
            return null;
        };

        /**
         * Creates a GenesisRegisterNodeTransaction message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof wavesenterprise.GenesisRegisterNodeTransaction
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {wavesenterprise.GenesisRegisterNodeTransaction} GenesisRegisterNodeTransaction
         */
        GenesisRegisterNodeTransaction.fromObject = function fromObject(object) {
            if (object instanceof $root.wavesenterprise.GenesisRegisterNodeTransaction)
                return object;
            var message = new $root.wavesenterprise.GenesisRegisterNodeTransaction();
            if (object.id != null)
                if (typeof object.id === "string")
                    $util.base64.decode(object.id, message.id = $util.newBuffer($util.base64.length(object.id)), 0);
                else if (object.id.length)
                    message.id = object.id;
            if (object.targetPublicKey != null)
                if (typeof object.targetPublicKey === "string")
                    $util.base64.decode(object.targetPublicKey, message.targetPublicKey = $util.newBuffer($util.base64.length(object.targetPublicKey)), 0);
                else if (object.targetPublicKey.length)
                    message.targetPublicKey = object.targetPublicKey;
            if (object.fee != null)
                if ($util.Long)
                    (message.fee = $util.Long.fromValue(object.fee)).unsigned = false;
                else if (typeof object.fee === "string")
                    message.fee = parseInt(object.fee, 10);
                else if (typeof object.fee === "number")
                    message.fee = object.fee;
                else if (typeof object.fee === "object")
                    message.fee = new $util.LongBits(object.fee.low >>> 0, object.fee.high >>> 0).toNumber();
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            if (object.signature != null)
                if (typeof object.signature === "string")
                    $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                else if (object.signature.length)
                    message.signature = object.signature;
            return message;
        };

        /**
         * Creates a plain object from a GenesisRegisterNodeTransaction message. Also converts values to other types if specified.
         * @function toObject
         * @memberof wavesenterprise.GenesisRegisterNodeTransaction
         * @static
         * @param {wavesenterprise.GenesisRegisterNodeTransaction} message GenesisRegisterNodeTransaction
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GenesisRegisterNodeTransaction.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.id = "";
                else {
                    object.id = [];
                    if (options.bytes !== Array)
                        object.id = $util.newBuffer(object.id);
                }
                if (options.bytes === String)
                    object.targetPublicKey = "";
                else {
                    object.targetPublicKey = [];
                    if (options.bytes !== Array)
                        object.targetPublicKey = $util.newBuffer(object.targetPublicKey);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.fee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.fee = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.signature = "";
                else {
                    object.signature = [];
                    if (options.bytes !== Array)
                        object.signature = $util.newBuffer(object.signature);
                }
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = options.bytes === String ? $util.base64.encode(message.id, 0, message.id.length) : options.bytes === Array ? Array.prototype.slice.call(message.id) : message.id;
            if (message.targetPublicKey != null && message.hasOwnProperty("targetPublicKey"))
                object.targetPublicKey = options.bytes === String ? $util.base64.encode(message.targetPublicKey, 0, message.targetPublicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.targetPublicKey) : message.targetPublicKey;
            if (message.fee != null && message.hasOwnProperty("fee"))
                if (typeof message.fee === "number")
                    object.fee = options.longs === String ? String(message.fee) : message.fee;
                else
                    object.fee = options.longs === String ? $util.Long.prototype.toString.call(message.fee) : options.longs === Number ? new $util.LongBits(message.fee.low >>> 0, message.fee.high >>> 0).toNumber() : message.fee;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            if (message.signature != null && message.hasOwnProperty("signature"))
                object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
            return object;
        };

        /**
         * Converts this GenesisRegisterNodeTransaction to JSON.
         * @function toJSON
         * @memberof wavesenterprise.GenesisRegisterNodeTransaction
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GenesisRegisterNodeTransaction.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GenesisRegisterNodeTransaction;
    })();

    wavesenterprise.RegisterNodeTransaction = (function() {

        /**
         * Properties of a RegisterNodeTransaction.
         * @memberof wavesenterprise
         * @interface IRegisterNodeTransaction
         * @property {Uint8Array|null} [id] RegisterNodeTransaction id
         * @property {Uint8Array|null} [senderPublicKey] RegisterNodeTransaction senderPublicKey
         * @property {Uint8Array|null} [target] RegisterNodeTransaction target
         * @property {google.protobuf.IStringValue|null} [nodeName] RegisterNodeTransaction nodeName
         * @property {wavesenterprise.OpType|null} [opType] RegisterNodeTransaction opType
         * @property {number|Long|null} [timestamp] RegisterNodeTransaction timestamp
         * @property {number|Long|null} [fee] RegisterNodeTransaction fee
         * @property {Array.<Uint8Array>|null} [proofs] RegisterNodeTransaction proofs
         */

        /**
         * Constructs a new RegisterNodeTransaction.
         * @memberof wavesenterprise
         * @classdesc Represents a RegisterNodeTransaction.
         * @implements IRegisterNodeTransaction
         * @constructor
         * @param {wavesenterprise.IRegisterNodeTransaction=} [properties] Properties to set
         */
        function RegisterNodeTransaction(properties) {
            this.proofs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RegisterNodeTransaction id.
         * @member {Uint8Array} id
         * @memberof wavesenterprise.RegisterNodeTransaction
         * @instance
         */
        RegisterNodeTransaction.prototype.id = $util.newBuffer([]);

        /**
         * RegisterNodeTransaction senderPublicKey.
         * @member {Uint8Array} senderPublicKey
         * @memberof wavesenterprise.RegisterNodeTransaction
         * @instance
         */
        RegisterNodeTransaction.prototype.senderPublicKey = $util.newBuffer([]);

        /**
         * RegisterNodeTransaction target.
         * @member {Uint8Array} target
         * @memberof wavesenterprise.RegisterNodeTransaction
         * @instance
         */
        RegisterNodeTransaction.prototype.target = $util.newBuffer([]);

        /**
         * RegisterNodeTransaction nodeName.
         * @member {google.protobuf.IStringValue|null|undefined} nodeName
         * @memberof wavesenterprise.RegisterNodeTransaction
         * @instance
         */
        RegisterNodeTransaction.prototype.nodeName = null;

        /**
         * RegisterNodeTransaction opType.
         * @member {wavesenterprise.OpType} opType
         * @memberof wavesenterprise.RegisterNodeTransaction
         * @instance
         */
        RegisterNodeTransaction.prototype.opType = 0;

        /**
         * RegisterNodeTransaction timestamp.
         * @member {number|Long} timestamp
         * @memberof wavesenterprise.RegisterNodeTransaction
         * @instance
         */
        RegisterNodeTransaction.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * RegisterNodeTransaction fee.
         * @member {number|Long} fee
         * @memberof wavesenterprise.RegisterNodeTransaction
         * @instance
         */
        RegisterNodeTransaction.prototype.fee = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * RegisterNodeTransaction proofs.
         * @member {Array.<Uint8Array>} proofs
         * @memberof wavesenterprise.RegisterNodeTransaction
         * @instance
         */
        RegisterNodeTransaction.prototype.proofs = $util.emptyArray;

        /**
         * Creates a new RegisterNodeTransaction instance using the specified properties.
         * @function create
         * @memberof wavesenterprise.RegisterNodeTransaction
         * @static
         * @param {wavesenterprise.IRegisterNodeTransaction=} [properties] Properties to set
         * @returns {wavesenterprise.RegisterNodeTransaction} RegisterNodeTransaction instance
         */
        RegisterNodeTransaction.create = function create(properties) {
            return new RegisterNodeTransaction(properties);
        };

        /**
         * Encodes the specified RegisterNodeTransaction message. Does not implicitly {@link wavesenterprise.RegisterNodeTransaction.verify|verify} messages.
         * @function encode
         * @memberof wavesenterprise.RegisterNodeTransaction
         * @static
         * @param {wavesenterprise.IRegisterNodeTransaction} message RegisterNodeTransaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RegisterNodeTransaction.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.id);
            if (message.senderPublicKey != null && Object.hasOwnProperty.call(message, "senderPublicKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.senderPublicKey);
            if (message.target != null && Object.hasOwnProperty.call(message, "target"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.target);
            if (message.nodeName != null && Object.hasOwnProperty.call(message, "nodeName"))
                $root.google.protobuf.StringValue.encode(message.nodeName, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.opType != null && Object.hasOwnProperty.call(message, "opType"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.opType);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.timestamp);
            if (message.fee != null && Object.hasOwnProperty.call(message, "fee"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.fee);
            if (message.proofs != null && message.proofs.length)
                for (var i = 0; i < message.proofs.length; ++i)
                    writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.proofs[i]);
            return writer;
        };

        /**
         * Encodes the specified RegisterNodeTransaction message, length delimited. Does not implicitly {@link wavesenterprise.RegisterNodeTransaction.verify|verify} messages.
         * @function encodeDelimited
         * @memberof wavesenterprise.RegisterNodeTransaction
         * @static
         * @param {wavesenterprise.IRegisterNodeTransaction} message RegisterNodeTransaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RegisterNodeTransaction.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RegisterNodeTransaction message from the specified reader or buffer.
         * @function decode
         * @memberof wavesenterprise.RegisterNodeTransaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {wavesenterprise.RegisterNodeTransaction} RegisterNodeTransaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RegisterNodeTransaction.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.wavesenterprise.RegisterNodeTransaction();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.bytes();
                    break;
                case 2:
                    message.senderPublicKey = reader.bytes();
                    break;
                case 3:
                    message.target = reader.bytes();
                    break;
                case 4:
                    message.nodeName = $root.google.protobuf.StringValue.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.opType = reader.int32();
                    break;
                case 6:
                    message.timestamp = reader.int64();
                    break;
                case 7:
                    message.fee = reader.int64();
                    break;
                case 8:
                    if (!(message.proofs && message.proofs.length))
                        message.proofs = [];
                    message.proofs.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RegisterNodeTransaction message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof wavesenterprise.RegisterNodeTransaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {wavesenterprise.RegisterNodeTransaction} RegisterNodeTransaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RegisterNodeTransaction.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RegisterNodeTransaction message.
         * @function verify
         * @memberof wavesenterprise.RegisterNodeTransaction
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RegisterNodeTransaction.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!(message.id && typeof message.id.length === "number" || $util.isString(message.id)))
                    return "id: buffer expected";
            if (message.senderPublicKey != null && message.hasOwnProperty("senderPublicKey"))
                if (!(message.senderPublicKey && typeof message.senderPublicKey.length === "number" || $util.isString(message.senderPublicKey)))
                    return "senderPublicKey: buffer expected";
            if (message.target != null && message.hasOwnProperty("target"))
                if (!(message.target && typeof message.target.length === "number" || $util.isString(message.target)))
                    return "target: buffer expected";
            if (message.nodeName != null && message.hasOwnProperty("nodeName")) {
                var error = $root.google.protobuf.StringValue.verify(message.nodeName);
                if (error)
                    return "nodeName." + error;
            }
            if (message.opType != null && message.hasOwnProperty("opType"))
                switch (message.opType) {
                default:
                    return "opType: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            if (message.fee != null && message.hasOwnProperty("fee"))
                if (!$util.isInteger(message.fee) && !(message.fee && $util.isInteger(message.fee.low) && $util.isInteger(message.fee.high)))
                    return "fee: integer|Long expected";
            if (message.proofs != null && message.hasOwnProperty("proofs")) {
                if (!Array.isArray(message.proofs))
                    return "proofs: array expected";
                for (var i = 0; i < message.proofs.length; ++i)
                    if (!(message.proofs[i] && typeof message.proofs[i].length === "number" || $util.isString(message.proofs[i])))
                        return "proofs: buffer[] expected";
            }
            return null;
        };

        /**
         * Creates a RegisterNodeTransaction message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof wavesenterprise.RegisterNodeTransaction
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {wavesenterprise.RegisterNodeTransaction} RegisterNodeTransaction
         */
        RegisterNodeTransaction.fromObject = function fromObject(object) {
            if (object instanceof $root.wavesenterprise.RegisterNodeTransaction)
                return object;
            var message = new $root.wavesenterprise.RegisterNodeTransaction();
            if (object.id != null)
                if (typeof object.id === "string")
                    $util.base64.decode(object.id, message.id = $util.newBuffer($util.base64.length(object.id)), 0);
                else if (object.id.length)
                    message.id = object.id;
            if (object.senderPublicKey != null)
                if (typeof object.senderPublicKey === "string")
                    $util.base64.decode(object.senderPublicKey, message.senderPublicKey = $util.newBuffer($util.base64.length(object.senderPublicKey)), 0);
                else if (object.senderPublicKey.length)
                    message.senderPublicKey = object.senderPublicKey;
            if (object.target != null)
                if (typeof object.target === "string")
                    $util.base64.decode(object.target, message.target = $util.newBuffer($util.base64.length(object.target)), 0);
                else if (object.target.length)
                    message.target = object.target;
            if (object.nodeName != null) {
                if (typeof object.nodeName !== "object")
                    throw TypeError(".wavesenterprise.RegisterNodeTransaction.nodeName: object expected");
                message.nodeName = $root.google.protobuf.StringValue.fromObject(object.nodeName);
            }
            switch (object.opType) {
            case "UNKNOWN_OP_TYPE":
            case 0:
                message.opType = 0;
                break;
            case "ADD":
            case 1:
                message.opType = 1;
                break;
            case "REMOVE":
            case 2:
                message.opType = 2;
                break;
            }
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            if (object.fee != null)
                if ($util.Long)
                    (message.fee = $util.Long.fromValue(object.fee)).unsigned = false;
                else if (typeof object.fee === "string")
                    message.fee = parseInt(object.fee, 10);
                else if (typeof object.fee === "number")
                    message.fee = object.fee;
                else if (typeof object.fee === "object")
                    message.fee = new $util.LongBits(object.fee.low >>> 0, object.fee.high >>> 0).toNumber();
            if (object.proofs) {
                if (!Array.isArray(object.proofs))
                    throw TypeError(".wavesenterprise.RegisterNodeTransaction.proofs: array expected");
                message.proofs = [];
                for (var i = 0; i < object.proofs.length; ++i)
                    if (typeof object.proofs[i] === "string")
                        $util.base64.decode(object.proofs[i], message.proofs[i] = $util.newBuffer($util.base64.length(object.proofs[i])), 0);
                    else if (object.proofs[i].length)
                        message.proofs[i] = object.proofs[i];
            }
            return message;
        };

        /**
         * Creates a plain object from a RegisterNodeTransaction message. Also converts values to other types if specified.
         * @function toObject
         * @memberof wavesenterprise.RegisterNodeTransaction
         * @static
         * @param {wavesenterprise.RegisterNodeTransaction} message RegisterNodeTransaction
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RegisterNodeTransaction.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.proofs = [];
            if (options.defaults) {
                if (options.bytes === String)
                    object.id = "";
                else {
                    object.id = [];
                    if (options.bytes !== Array)
                        object.id = $util.newBuffer(object.id);
                }
                if (options.bytes === String)
                    object.senderPublicKey = "";
                else {
                    object.senderPublicKey = [];
                    if (options.bytes !== Array)
                        object.senderPublicKey = $util.newBuffer(object.senderPublicKey);
                }
                if (options.bytes === String)
                    object.target = "";
                else {
                    object.target = [];
                    if (options.bytes !== Array)
                        object.target = $util.newBuffer(object.target);
                }
                object.nodeName = null;
                object.opType = options.enums === String ? "UNKNOWN_OP_TYPE" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.fee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.fee = options.longs === String ? "0" : 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = options.bytes === String ? $util.base64.encode(message.id, 0, message.id.length) : options.bytes === Array ? Array.prototype.slice.call(message.id) : message.id;
            if (message.senderPublicKey != null && message.hasOwnProperty("senderPublicKey"))
                object.senderPublicKey = options.bytes === String ? $util.base64.encode(message.senderPublicKey, 0, message.senderPublicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.senderPublicKey) : message.senderPublicKey;
            if (message.target != null && message.hasOwnProperty("target"))
                object.target = options.bytes === String ? $util.base64.encode(message.target, 0, message.target.length) : options.bytes === Array ? Array.prototype.slice.call(message.target) : message.target;
            if (message.nodeName != null && message.hasOwnProperty("nodeName"))
                object.nodeName = $root.google.protobuf.StringValue.toObject(message.nodeName, options);
            if (message.opType != null && message.hasOwnProperty("opType"))
                object.opType = options.enums === String ? $root.wavesenterprise.OpType[message.opType] : message.opType;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            if (message.fee != null && message.hasOwnProperty("fee"))
                if (typeof message.fee === "number")
                    object.fee = options.longs === String ? String(message.fee) : message.fee;
                else
                    object.fee = options.longs === String ? $util.Long.prototype.toString.call(message.fee) : options.longs === Number ? new $util.LongBits(message.fee.low >>> 0, message.fee.high >>> 0).toNumber() : message.fee;
            if (message.proofs && message.proofs.length) {
                object.proofs = [];
                for (var j = 0; j < message.proofs.length; ++j)
                    object.proofs[j] = options.bytes === String ? $util.base64.encode(message.proofs[j], 0, message.proofs[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.proofs[j]) : message.proofs[j];
            }
            return object;
        };

        /**
         * Converts this RegisterNodeTransaction to JSON.
         * @function toJSON
         * @memberof wavesenterprise.RegisterNodeTransaction
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RegisterNodeTransaction.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RegisterNodeTransaction;
    })();

    /**
     * OpType enum.
     * @name wavesenterprise.OpType
     * @enum {number}
     * @property {number} UNKNOWN_OP_TYPE=0 UNKNOWN_OP_TYPE value
     * @property {number} ADD=1 ADD value
     * @property {number} REMOVE=2 REMOVE value
     */
    wavesenterprise.OpType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "UNKNOWN_OP_TYPE"] = 0;
        values[valuesById[1] = "ADD"] = 1;
        values[valuesById[2] = "REMOVE"] = 2;
        return values;
    })();

    wavesenterprise.CreateAliasTransaction = (function() {

        /**
         * Properties of a CreateAliasTransaction.
         * @memberof wavesenterprise
         * @interface ICreateAliasTransaction
         * @property {Uint8Array|null} [id] CreateAliasTransaction id
         * @property {Uint8Array|null} [senderPublicKey] CreateAliasTransaction senderPublicKey
         * @property {Uint8Array|null} [alias] CreateAliasTransaction alias
         * @property {number|Long|null} [fee] CreateAliasTransaction fee
         * @property {number|Long|null} [timestamp] CreateAliasTransaction timestamp
         * @property {google.protobuf.IBytesValue|null} [feeAssetId] CreateAliasTransaction feeAssetId
         * @property {Array.<Uint8Array>|null} [proofs] CreateAliasTransaction proofs
         */

        /**
         * Constructs a new CreateAliasTransaction.
         * @memberof wavesenterprise
         * @classdesc Represents a CreateAliasTransaction.
         * @implements ICreateAliasTransaction
         * @constructor
         * @param {wavesenterprise.ICreateAliasTransaction=} [properties] Properties to set
         */
        function CreateAliasTransaction(properties) {
            this.proofs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CreateAliasTransaction id.
         * @member {Uint8Array} id
         * @memberof wavesenterprise.CreateAliasTransaction
         * @instance
         */
        CreateAliasTransaction.prototype.id = $util.newBuffer([]);

        /**
         * CreateAliasTransaction senderPublicKey.
         * @member {Uint8Array} senderPublicKey
         * @memberof wavesenterprise.CreateAliasTransaction
         * @instance
         */
        CreateAliasTransaction.prototype.senderPublicKey = $util.newBuffer([]);

        /**
         * CreateAliasTransaction alias.
         * @member {Uint8Array} alias
         * @memberof wavesenterprise.CreateAliasTransaction
         * @instance
         */
        CreateAliasTransaction.prototype.alias = $util.newBuffer([]);

        /**
         * CreateAliasTransaction fee.
         * @member {number|Long} fee
         * @memberof wavesenterprise.CreateAliasTransaction
         * @instance
         */
        CreateAliasTransaction.prototype.fee = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * CreateAliasTransaction timestamp.
         * @member {number|Long} timestamp
         * @memberof wavesenterprise.CreateAliasTransaction
         * @instance
         */
        CreateAliasTransaction.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * CreateAliasTransaction feeAssetId.
         * @member {google.protobuf.IBytesValue|null|undefined} feeAssetId
         * @memberof wavesenterprise.CreateAliasTransaction
         * @instance
         */
        CreateAliasTransaction.prototype.feeAssetId = null;

        /**
         * CreateAliasTransaction proofs.
         * @member {Array.<Uint8Array>} proofs
         * @memberof wavesenterprise.CreateAliasTransaction
         * @instance
         */
        CreateAliasTransaction.prototype.proofs = $util.emptyArray;

        /**
         * Creates a new CreateAliasTransaction instance using the specified properties.
         * @function create
         * @memberof wavesenterprise.CreateAliasTransaction
         * @static
         * @param {wavesenterprise.ICreateAliasTransaction=} [properties] Properties to set
         * @returns {wavesenterprise.CreateAliasTransaction} CreateAliasTransaction instance
         */
        CreateAliasTransaction.create = function create(properties) {
            return new CreateAliasTransaction(properties);
        };

        /**
         * Encodes the specified CreateAliasTransaction message. Does not implicitly {@link wavesenterprise.CreateAliasTransaction.verify|verify} messages.
         * @function encode
         * @memberof wavesenterprise.CreateAliasTransaction
         * @static
         * @param {wavesenterprise.ICreateAliasTransaction} message CreateAliasTransaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateAliasTransaction.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.id);
            if (message.senderPublicKey != null && Object.hasOwnProperty.call(message, "senderPublicKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.senderPublicKey);
            if (message.alias != null && Object.hasOwnProperty.call(message, "alias"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.alias);
            if (message.fee != null && Object.hasOwnProperty.call(message, "fee"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.fee);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.timestamp);
            if (message.feeAssetId != null && Object.hasOwnProperty.call(message, "feeAssetId"))
                $root.google.protobuf.BytesValue.encode(message.feeAssetId, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.proofs != null && message.proofs.length)
                for (var i = 0; i < message.proofs.length; ++i)
                    writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.proofs[i]);
            return writer;
        };

        /**
         * Encodes the specified CreateAliasTransaction message, length delimited. Does not implicitly {@link wavesenterprise.CreateAliasTransaction.verify|verify} messages.
         * @function encodeDelimited
         * @memberof wavesenterprise.CreateAliasTransaction
         * @static
         * @param {wavesenterprise.ICreateAliasTransaction} message CreateAliasTransaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateAliasTransaction.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CreateAliasTransaction message from the specified reader or buffer.
         * @function decode
         * @memberof wavesenterprise.CreateAliasTransaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {wavesenterprise.CreateAliasTransaction} CreateAliasTransaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateAliasTransaction.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.wavesenterprise.CreateAliasTransaction();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.bytes();
                    break;
                case 2:
                    message.senderPublicKey = reader.bytes();
                    break;
                case 3:
                    message.alias = reader.bytes();
                    break;
                case 4:
                    message.fee = reader.int64();
                    break;
                case 5:
                    message.timestamp = reader.int64();
                    break;
                case 6:
                    message.feeAssetId = $root.google.protobuf.BytesValue.decode(reader, reader.uint32());
                    break;
                case 7:
                    if (!(message.proofs && message.proofs.length))
                        message.proofs = [];
                    message.proofs.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CreateAliasTransaction message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof wavesenterprise.CreateAliasTransaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {wavesenterprise.CreateAliasTransaction} CreateAliasTransaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateAliasTransaction.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CreateAliasTransaction message.
         * @function verify
         * @memberof wavesenterprise.CreateAliasTransaction
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CreateAliasTransaction.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!(message.id && typeof message.id.length === "number" || $util.isString(message.id)))
                    return "id: buffer expected";
            if (message.senderPublicKey != null && message.hasOwnProperty("senderPublicKey"))
                if (!(message.senderPublicKey && typeof message.senderPublicKey.length === "number" || $util.isString(message.senderPublicKey)))
                    return "senderPublicKey: buffer expected";
            if (message.alias != null && message.hasOwnProperty("alias"))
                if (!(message.alias && typeof message.alias.length === "number" || $util.isString(message.alias)))
                    return "alias: buffer expected";
            if (message.fee != null && message.hasOwnProperty("fee"))
                if (!$util.isInteger(message.fee) && !(message.fee && $util.isInteger(message.fee.low) && $util.isInteger(message.fee.high)))
                    return "fee: integer|Long expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            if (message.feeAssetId != null && message.hasOwnProperty("feeAssetId")) {
                var error = $root.google.protobuf.BytesValue.verify(message.feeAssetId);
                if (error)
                    return "feeAssetId." + error;
            }
            if (message.proofs != null && message.hasOwnProperty("proofs")) {
                if (!Array.isArray(message.proofs))
                    return "proofs: array expected";
                for (var i = 0; i < message.proofs.length; ++i)
                    if (!(message.proofs[i] && typeof message.proofs[i].length === "number" || $util.isString(message.proofs[i])))
                        return "proofs: buffer[] expected";
            }
            return null;
        };

        /**
         * Creates a CreateAliasTransaction message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof wavesenterprise.CreateAliasTransaction
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {wavesenterprise.CreateAliasTransaction} CreateAliasTransaction
         */
        CreateAliasTransaction.fromObject = function fromObject(object) {
            if (object instanceof $root.wavesenterprise.CreateAliasTransaction)
                return object;
            var message = new $root.wavesenterprise.CreateAliasTransaction();
            if (object.id != null)
                if (typeof object.id === "string")
                    $util.base64.decode(object.id, message.id = $util.newBuffer($util.base64.length(object.id)), 0);
                else if (object.id.length)
                    message.id = object.id;
            if (object.senderPublicKey != null)
                if (typeof object.senderPublicKey === "string")
                    $util.base64.decode(object.senderPublicKey, message.senderPublicKey = $util.newBuffer($util.base64.length(object.senderPublicKey)), 0);
                else if (object.senderPublicKey.length)
                    message.senderPublicKey = object.senderPublicKey;
            if (object.alias != null)
                if (typeof object.alias === "string")
                    $util.base64.decode(object.alias, message.alias = $util.newBuffer($util.base64.length(object.alias)), 0);
                else if (object.alias.length)
                    message.alias = object.alias;
            if (object.fee != null)
                if ($util.Long)
                    (message.fee = $util.Long.fromValue(object.fee)).unsigned = false;
                else if (typeof object.fee === "string")
                    message.fee = parseInt(object.fee, 10);
                else if (typeof object.fee === "number")
                    message.fee = object.fee;
                else if (typeof object.fee === "object")
                    message.fee = new $util.LongBits(object.fee.low >>> 0, object.fee.high >>> 0).toNumber();
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            if (object.feeAssetId != null) {
                if (typeof object.feeAssetId !== "object")
                    throw TypeError(".wavesenterprise.CreateAliasTransaction.feeAssetId: object expected");
                message.feeAssetId = $root.google.protobuf.BytesValue.fromObject(object.feeAssetId);
            }
            if (object.proofs) {
                if (!Array.isArray(object.proofs))
                    throw TypeError(".wavesenterprise.CreateAliasTransaction.proofs: array expected");
                message.proofs = [];
                for (var i = 0; i < object.proofs.length; ++i)
                    if (typeof object.proofs[i] === "string")
                        $util.base64.decode(object.proofs[i], message.proofs[i] = $util.newBuffer($util.base64.length(object.proofs[i])), 0);
                    else if (object.proofs[i].length)
                        message.proofs[i] = object.proofs[i];
            }
            return message;
        };

        /**
         * Creates a plain object from a CreateAliasTransaction message. Also converts values to other types if specified.
         * @function toObject
         * @memberof wavesenterprise.CreateAliasTransaction
         * @static
         * @param {wavesenterprise.CreateAliasTransaction} message CreateAliasTransaction
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CreateAliasTransaction.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.proofs = [];
            if (options.defaults) {
                if (options.bytes === String)
                    object.id = "";
                else {
                    object.id = [];
                    if (options.bytes !== Array)
                        object.id = $util.newBuffer(object.id);
                }
                if (options.bytes === String)
                    object.senderPublicKey = "";
                else {
                    object.senderPublicKey = [];
                    if (options.bytes !== Array)
                        object.senderPublicKey = $util.newBuffer(object.senderPublicKey);
                }
                if (options.bytes === String)
                    object.alias = "";
                else {
                    object.alias = [];
                    if (options.bytes !== Array)
                        object.alias = $util.newBuffer(object.alias);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.fee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.fee = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
                object.feeAssetId = null;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = options.bytes === String ? $util.base64.encode(message.id, 0, message.id.length) : options.bytes === Array ? Array.prototype.slice.call(message.id) : message.id;
            if (message.senderPublicKey != null && message.hasOwnProperty("senderPublicKey"))
                object.senderPublicKey = options.bytes === String ? $util.base64.encode(message.senderPublicKey, 0, message.senderPublicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.senderPublicKey) : message.senderPublicKey;
            if (message.alias != null && message.hasOwnProperty("alias"))
                object.alias = options.bytes === String ? $util.base64.encode(message.alias, 0, message.alias.length) : options.bytes === Array ? Array.prototype.slice.call(message.alias) : message.alias;
            if (message.fee != null && message.hasOwnProperty("fee"))
                if (typeof message.fee === "number")
                    object.fee = options.longs === String ? String(message.fee) : message.fee;
                else
                    object.fee = options.longs === String ? $util.Long.prototype.toString.call(message.fee) : options.longs === Number ? new $util.LongBits(message.fee.low >>> 0, message.fee.high >>> 0).toNumber() : message.fee;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            if (message.feeAssetId != null && message.hasOwnProperty("feeAssetId"))
                object.feeAssetId = $root.google.protobuf.BytesValue.toObject(message.feeAssetId, options);
            if (message.proofs && message.proofs.length) {
                object.proofs = [];
                for (var j = 0; j < message.proofs.length; ++j)
                    object.proofs[j] = options.bytes === String ? $util.base64.encode(message.proofs[j], 0, message.proofs[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.proofs[j]) : message.proofs[j];
            }
            return object;
        };

        /**
         * Converts this CreateAliasTransaction to JSON.
         * @function toJSON
         * @memberof wavesenterprise.CreateAliasTransaction
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CreateAliasTransaction.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CreateAliasTransaction;
    })();

    wavesenterprise.IssueTransaction = (function() {

        /**
         * Properties of an IssueTransaction.
         * @memberof wavesenterprise
         * @interface IIssueTransaction
         * @property {Uint8Array|null} [id] IssueTransaction id
         * @property {number|null} [chainId] IssueTransaction chainId
         * @property {Uint8Array|null} [senderPublicKey] IssueTransaction senderPublicKey
         * @property {Uint8Array|null} [name] IssueTransaction name
         * @property {Uint8Array|null} [description] IssueTransaction description
         * @property {number|Long|null} [quantity] IssueTransaction quantity
         * @property {number|null} [decimals] IssueTransaction decimals
         * @property {boolean|null} [reissuable] IssueTransaction reissuable
         * @property {number|Long|null} [fee] IssueTransaction fee
         * @property {number|Long|null} [timestamp] IssueTransaction timestamp
         * @property {google.protobuf.IBytesValue|null} [script] IssueTransaction script
         * @property {Array.<Uint8Array>|null} [proofs] IssueTransaction proofs
         */

        /**
         * Constructs a new IssueTransaction.
         * @memberof wavesenterprise
         * @classdesc Represents an IssueTransaction.
         * @implements IIssueTransaction
         * @constructor
         * @param {wavesenterprise.IIssueTransaction=} [properties] Properties to set
         */
        function IssueTransaction(properties) {
            this.proofs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IssueTransaction id.
         * @member {Uint8Array} id
         * @memberof wavesenterprise.IssueTransaction
         * @instance
         */
        IssueTransaction.prototype.id = $util.newBuffer([]);

        /**
         * IssueTransaction chainId.
         * @member {number} chainId
         * @memberof wavesenterprise.IssueTransaction
         * @instance
         */
        IssueTransaction.prototype.chainId = 0;

        /**
         * IssueTransaction senderPublicKey.
         * @member {Uint8Array} senderPublicKey
         * @memberof wavesenterprise.IssueTransaction
         * @instance
         */
        IssueTransaction.prototype.senderPublicKey = $util.newBuffer([]);

        /**
         * IssueTransaction name.
         * @member {Uint8Array} name
         * @memberof wavesenterprise.IssueTransaction
         * @instance
         */
        IssueTransaction.prototype.name = $util.newBuffer([]);

        /**
         * IssueTransaction description.
         * @member {Uint8Array} description
         * @memberof wavesenterprise.IssueTransaction
         * @instance
         */
        IssueTransaction.prototype.description = $util.newBuffer([]);

        /**
         * IssueTransaction quantity.
         * @member {number|Long} quantity
         * @memberof wavesenterprise.IssueTransaction
         * @instance
         */
        IssueTransaction.prototype.quantity = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * IssueTransaction decimals.
         * @member {number} decimals
         * @memberof wavesenterprise.IssueTransaction
         * @instance
         */
        IssueTransaction.prototype.decimals = 0;

        /**
         * IssueTransaction reissuable.
         * @member {boolean} reissuable
         * @memberof wavesenterprise.IssueTransaction
         * @instance
         */
        IssueTransaction.prototype.reissuable = false;

        /**
         * IssueTransaction fee.
         * @member {number|Long} fee
         * @memberof wavesenterprise.IssueTransaction
         * @instance
         */
        IssueTransaction.prototype.fee = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * IssueTransaction timestamp.
         * @member {number|Long} timestamp
         * @memberof wavesenterprise.IssueTransaction
         * @instance
         */
        IssueTransaction.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * IssueTransaction script.
         * @member {google.protobuf.IBytesValue|null|undefined} script
         * @memberof wavesenterprise.IssueTransaction
         * @instance
         */
        IssueTransaction.prototype.script = null;

        /**
         * IssueTransaction proofs.
         * @member {Array.<Uint8Array>} proofs
         * @memberof wavesenterprise.IssueTransaction
         * @instance
         */
        IssueTransaction.prototype.proofs = $util.emptyArray;

        /**
         * Creates a new IssueTransaction instance using the specified properties.
         * @function create
         * @memberof wavesenterprise.IssueTransaction
         * @static
         * @param {wavesenterprise.IIssueTransaction=} [properties] Properties to set
         * @returns {wavesenterprise.IssueTransaction} IssueTransaction instance
         */
        IssueTransaction.create = function create(properties) {
            return new IssueTransaction(properties);
        };

        /**
         * Encodes the specified IssueTransaction message. Does not implicitly {@link wavesenterprise.IssueTransaction.verify|verify} messages.
         * @function encode
         * @memberof wavesenterprise.IssueTransaction
         * @static
         * @param {wavesenterprise.IIssueTransaction} message IssueTransaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IssueTransaction.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.id);
            if (message.chainId != null && Object.hasOwnProperty.call(message, "chainId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.chainId);
            if (message.senderPublicKey != null && Object.hasOwnProperty.call(message, "senderPublicKey"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.senderPublicKey);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.name);
            if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.description);
            if (message.quantity != null && Object.hasOwnProperty.call(message, "quantity"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.quantity);
            if (message.decimals != null && Object.hasOwnProperty.call(message, "decimals"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.decimals);
            if (message.reissuable != null && Object.hasOwnProperty.call(message, "reissuable"))
                writer.uint32(/* id 8, wireType 0 =*/64).bool(message.reissuable);
            if (message.fee != null && Object.hasOwnProperty.call(message, "fee"))
                writer.uint32(/* id 9, wireType 0 =*/72).int64(message.fee);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 10, wireType 0 =*/80).int64(message.timestamp);
            if (message.script != null && Object.hasOwnProperty.call(message, "script"))
                $root.google.protobuf.BytesValue.encode(message.script, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            if (message.proofs != null && message.proofs.length)
                for (var i = 0; i < message.proofs.length; ++i)
                    writer.uint32(/* id 12, wireType 2 =*/98).bytes(message.proofs[i]);
            return writer;
        };

        /**
         * Encodes the specified IssueTransaction message, length delimited. Does not implicitly {@link wavesenterprise.IssueTransaction.verify|verify} messages.
         * @function encodeDelimited
         * @memberof wavesenterprise.IssueTransaction
         * @static
         * @param {wavesenterprise.IIssueTransaction} message IssueTransaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IssueTransaction.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IssueTransaction message from the specified reader or buffer.
         * @function decode
         * @memberof wavesenterprise.IssueTransaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {wavesenterprise.IssueTransaction} IssueTransaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IssueTransaction.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.wavesenterprise.IssueTransaction();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.bytes();
                    break;
                case 2:
                    message.chainId = reader.int32();
                    break;
                case 3:
                    message.senderPublicKey = reader.bytes();
                    break;
                case 4:
                    message.name = reader.bytes();
                    break;
                case 5:
                    message.description = reader.bytes();
                    break;
                case 6:
                    message.quantity = reader.int64();
                    break;
                case 7:
                    message.decimals = reader.int32();
                    break;
                case 8:
                    message.reissuable = reader.bool();
                    break;
                case 9:
                    message.fee = reader.int64();
                    break;
                case 10:
                    message.timestamp = reader.int64();
                    break;
                case 11:
                    message.script = $root.google.protobuf.BytesValue.decode(reader, reader.uint32());
                    break;
                case 12:
                    if (!(message.proofs && message.proofs.length))
                        message.proofs = [];
                    message.proofs.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IssueTransaction message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof wavesenterprise.IssueTransaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {wavesenterprise.IssueTransaction} IssueTransaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IssueTransaction.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IssueTransaction message.
         * @function verify
         * @memberof wavesenterprise.IssueTransaction
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IssueTransaction.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!(message.id && typeof message.id.length === "number" || $util.isString(message.id)))
                    return "id: buffer expected";
            if (message.chainId != null && message.hasOwnProperty("chainId"))
                if (!$util.isInteger(message.chainId))
                    return "chainId: integer expected";
            if (message.senderPublicKey != null && message.hasOwnProperty("senderPublicKey"))
                if (!(message.senderPublicKey && typeof message.senderPublicKey.length === "number" || $util.isString(message.senderPublicKey)))
                    return "senderPublicKey: buffer expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!(message.name && typeof message.name.length === "number" || $util.isString(message.name)))
                    return "name: buffer expected";
            if (message.description != null && message.hasOwnProperty("description"))
                if (!(message.description && typeof message.description.length === "number" || $util.isString(message.description)))
                    return "description: buffer expected";
            if (message.quantity != null && message.hasOwnProperty("quantity"))
                if (!$util.isInteger(message.quantity) && !(message.quantity && $util.isInteger(message.quantity.low) && $util.isInteger(message.quantity.high)))
                    return "quantity: integer|Long expected";
            if (message.decimals != null && message.hasOwnProperty("decimals"))
                if (!$util.isInteger(message.decimals))
                    return "decimals: integer expected";
            if (message.reissuable != null && message.hasOwnProperty("reissuable"))
                if (typeof message.reissuable !== "boolean")
                    return "reissuable: boolean expected";
            if (message.fee != null && message.hasOwnProperty("fee"))
                if (!$util.isInteger(message.fee) && !(message.fee && $util.isInteger(message.fee.low) && $util.isInteger(message.fee.high)))
                    return "fee: integer|Long expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            if (message.script != null && message.hasOwnProperty("script")) {
                var error = $root.google.protobuf.BytesValue.verify(message.script);
                if (error)
                    return "script." + error;
            }
            if (message.proofs != null && message.hasOwnProperty("proofs")) {
                if (!Array.isArray(message.proofs))
                    return "proofs: array expected";
                for (var i = 0; i < message.proofs.length; ++i)
                    if (!(message.proofs[i] && typeof message.proofs[i].length === "number" || $util.isString(message.proofs[i])))
                        return "proofs: buffer[] expected";
            }
            return null;
        };

        /**
         * Creates an IssueTransaction message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof wavesenterprise.IssueTransaction
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {wavesenterprise.IssueTransaction} IssueTransaction
         */
        IssueTransaction.fromObject = function fromObject(object) {
            if (object instanceof $root.wavesenterprise.IssueTransaction)
                return object;
            var message = new $root.wavesenterprise.IssueTransaction();
            if (object.id != null)
                if (typeof object.id === "string")
                    $util.base64.decode(object.id, message.id = $util.newBuffer($util.base64.length(object.id)), 0);
                else if (object.id.length)
                    message.id = object.id;
            if (object.chainId != null)
                message.chainId = object.chainId | 0;
            if (object.senderPublicKey != null)
                if (typeof object.senderPublicKey === "string")
                    $util.base64.decode(object.senderPublicKey, message.senderPublicKey = $util.newBuffer($util.base64.length(object.senderPublicKey)), 0);
                else if (object.senderPublicKey.length)
                    message.senderPublicKey = object.senderPublicKey;
            if (object.name != null)
                if (typeof object.name === "string")
                    $util.base64.decode(object.name, message.name = $util.newBuffer($util.base64.length(object.name)), 0);
                else if (object.name.length)
                    message.name = object.name;
            if (object.description != null)
                if (typeof object.description === "string")
                    $util.base64.decode(object.description, message.description = $util.newBuffer($util.base64.length(object.description)), 0);
                else if (object.description.length)
                    message.description = object.description;
            if (object.quantity != null)
                if ($util.Long)
                    (message.quantity = $util.Long.fromValue(object.quantity)).unsigned = false;
                else if (typeof object.quantity === "string")
                    message.quantity = parseInt(object.quantity, 10);
                else if (typeof object.quantity === "number")
                    message.quantity = object.quantity;
                else if (typeof object.quantity === "object")
                    message.quantity = new $util.LongBits(object.quantity.low >>> 0, object.quantity.high >>> 0).toNumber();
            if (object.decimals != null)
                message.decimals = object.decimals | 0;
            if (object.reissuable != null)
                message.reissuable = Boolean(object.reissuable);
            if (object.fee != null)
                if ($util.Long)
                    (message.fee = $util.Long.fromValue(object.fee)).unsigned = false;
                else if (typeof object.fee === "string")
                    message.fee = parseInt(object.fee, 10);
                else if (typeof object.fee === "number")
                    message.fee = object.fee;
                else if (typeof object.fee === "object")
                    message.fee = new $util.LongBits(object.fee.low >>> 0, object.fee.high >>> 0).toNumber();
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            if (object.script != null) {
                if (typeof object.script !== "object")
                    throw TypeError(".wavesenterprise.IssueTransaction.script: object expected");
                message.script = $root.google.protobuf.BytesValue.fromObject(object.script);
            }
            if (object.proofs) {
                if (!Array.isArray(object.proofs))
                    throw TypeError(".wavesenterprise.IssueTransaction.proofs: array expected");
                message.proofs = [];
                for (var i = 0; i < object.proofs.length; ++i)
                    if (typeof object.proofs[i] === "string")
                        $util.base64.decode(object.proofs[i], message.proofs[i] = $util.newBuffer($util.base64.length(object.proofs[i])), 0);
                    else if (object.proofs[i].length)
                        message.proofs[i] = object.proofs[i];
            }
            return message;
        };

        /**
         * Creates a plain object from an IssueTransaction message. Also converts values to other types if specified.
         * @function toObject
         * @memberof wavesenterprise.IssueTransaction
         * @static
         * @param {wavesenterprise.IssueTransaction} message IssueTransaction
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IssueTransaction.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.proofs = [];
            if (options.defaults) {
                if (options.bytes === String)
                    object.id = "";
                else {
                    object.id = [];
                    if (options.bytes !== Array)
                        object.id = $util.newBuffer(object.id);
                }
                object.chainId = 0;
                if (options.bytes === String)
                    object.senderPublicKey = "";
                else {
                    object.senderPublicKey = [];
                    if (options.bytes !== Array)
                        object.senderPublicKey = $util.newBuffer(object.senderPublicKey);
                }
                if (options.bytes === String)
                    object.name = "";
                else {
                    object.name = [];
                    if (options.bytes !== Array)
                        object.name = $util.newBuffer(object.name);
                }
                if (options.bytes === String)
                    object.description = "";
                else {
                    object.description = [];
                    if (options.bytes !== Array)
                        object.description = $util.newBuffer(object.description);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.quantity = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.quantity = options.longs === String ? "0" : 0;
                object.decimals = 0;
                object.reissuable = false;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.fee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.fee = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
                object.script = null;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = options.bytes === String ? $util.base64.encode(message.id, 0, message.id.length) : options.bytes === Array ? Array.prototype.slice.call(message.id) : message.id;
            if (message.chainId != null && message.hasOwnProperty("chainId"))
                object.chainId = message.chainId;
            if (message.senderPublicKey != null && message.hasOwnProperty("senderPublicKey"))
                object.senderPublicKey = options.bytes === String ? $util.base64.encode(message.senderPublicKey, 0, message.senderPublicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.senderPublicKey) : message.senderPublicKey;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = options.bytes === String ? $util.base64.encode(message.name, 0, message.name.length) : options.bytes === Array ? Array.prototype.slice.call(message.name) : message.name;
            if (message.description != null && message.hasOwnProperty("description"))
                object.description = options.bytes === String ? $util.base64.encode(message.description, 0, message.description.length) : options.bytes === Array ? Array.prototype.slice.call(message.description) : message.description;
            if (message.quantity != null && message.hasOwnProperty("quantity"))
                if (typeof message.quantity === "number")
                    object.quantity = options.longs === String ? String(message.quantity) : message.quantity;
                else
                    object.quantity = options.longs === String ? $util.Long.prototype.toString.call(message.quantity) : options.longs === Number ? new $util.LongBits(message.quantity.low >>> 0, message.quantity.high >>> 0).toNumber() : message.quantity;
            if (message.decimals != null && message.hasOwnProperty("decimals"))
                object.decimals = message.decimals;
            if (message.reissuable != null && message.hasOwnProperty("reissuable"))
                object.reissuable = message.reissuable;
            if (message.fee != null && message.hasOwnProperty("fee"))
                if (typeof message.fee === "number")
                    object.fee = options.longs === String ? String(message.fee) : message.fee;
                else
                    object.fee = options.longs === String ? $util.Long.prototype.toString.call(message.fee) : options.longs === Number ? new $util.LongBits(message.fee.low >>> 0, message.fee.high >>> 0).toNumber() : message.fee;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            if (message.script != null && message.hasOwnProperty("script"))
                object.script = $root.google.protobuf.BytesValue.toObject(message.script, options);
            if (message.proofs && message.proofs.length) {
                object.proofs = [];
                for (var j = 0; j < message.proofs.length; ++j)
                    object.proofs[j] = options.bytes === String ? $util.base64.encode(message.proofs[j], 0, message.proofs[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.proofs[j]) : message.proofs[j];
            }
            return object;
        };

        /**
         * Converts this IssueTransaction to JSON.
         * @function toJSON
         * @memberof wavesenterprise.IssueTransaction
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IssueTransaction.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IssueTransaction;
    })();

    wavesenterprise.ReissueTransaction = (function() {

        /**
         * Properties of a ReissueTransaction.
         * @memberof wavesenterprise
         * @interface IReissueTransaction
         * @property {Uint8Array|null} [id] ReissueTransaction id
         * @property {number|null} [chainId] ReissueTransaction chainId
         * @property {Uint8Array|null} [senderPublicKey] ReissueTransaction senderPublicKey
         * @property {Uint8Array|null} [assetId] ReissueTransaction assetId
         * @property {number|Long|null} [quantity] ReissueTransaction quantity
         * @property {boolean|null} [reissuable] ReissueTransaction reissuable
         * @property {number|Long|null} [fee] ReissueTransaction fee
         * @property {number|Long|null} [timestamp] ReissueTransaction timestamp
         * @property {Array.<Uint8Array>|null} [proofs] ReissueTransaction proofs
         */

        /**
         * Constructs a new ReissueTransaction.
         * @memberof wavesenterprise
         * @classdesc Represents a ReissueTransaction.
         * @implements IReissueTransaction
         * @constructor
         * @param {wavesenterprise.IReissueTransaction=} [properties] Properties to set
         */
        function ReissueTransaction(properties) {
            this.proofs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ReissueTransaction id.
         * @member {Uint8Array} id
         * @memberof wavesenterprise.ReissueTransaction
         * @instance
         */
        ReissueTransaction.prototype.id = $util.newBuffer([]);

        /**
         * ReissueTransaction chainId.
         * @member {number} chainId
         * @memberof wavesenterprise.ReissueTransaction
         * @instance
         */
        ReissueTransaction.prototype.chainId = 0;

        /**
         * ReissueTransaction senderPublicKey.
         * @member {Uint8Array} senderPublicKey
         * @memberof wavesenterprise.ReissueTransaction
         * @instance
         */
        ReissueTransaction.prototype.senderPublicKey = $util.newBuffer([]);

        /**
         * ReissueTransaction assetId.
         * @member {Uint8Array} assetId
         * @memberof wavesenterprise.ReissueTransaction
         * @instance
         */
        ReissueTransaction.prototype.assetId = $util.newBuffer([]);

        /**
         * ReissueTransaction quantity.
         * @member {number|Long} quantity
         * @memberof wavesenterprise.ReissueTransaction
         * @instance
         */
        ReissueTransaction.prototype.quantity = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ReissueTransaction reissuable.
         * @member {boolean} reissuable
         * @memberof wavesenterprise.ReissueTransaction
         * @instance
         */
        ReissueTransaction.prototype.reissuable = false;

        /**
         * ReissueTransaction fee.
         * @member {number|Long} fee
         * @memberof wavesenterprise.ReissueTransaction
         * @instance
         */
        ReissueTransaction.prototype.fee = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ReissueTransaction timestamp.
         * @member {number|Long} timestamp
         * @memberof wavesenterprise.ReissueTransaction
         * @instance
         */
        ReissueTransaction.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ReissueTransaction proofs.
         * @member {Array.<Uint8Array>} proofs
         * @memberof wavesenterprise.ReissueTransaction
         * @instance
         */
        ReissueTransaction.prototype.proofs = $util.emptyArray;

        /**
         * Creates a new ReissueTransaction instance using the specified properties.
         * @function create
         * @memberof wavesenterprise.ReissueTransaction
         * @static
         * @param {wavesenterprise.IReissueTransaction=} [properties] Properties to set
         * @returns {wavesenterprise.ReissueTransaction} ReissueTransaction instance
         */
        ReissueTransaction.create = function create(properties) {
            return new ReissueTransaction(properties);
        };

        /**
         * Encodes the specified ReissueTransaction message. Does not implicitly {@link wavesenterprise.ReissueTransaction.verify|verify} messages.
         * @function encode
         * @memberof wavesenterprise.ReissueTransaction
         * @static
         * @param {wavesenterprise.IReissueTransaction} message ReissueTransaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReissueTransaction.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.id);
            if (message.chainId != null && Object.hasOwnProperty.call(message, "chainId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.chainId);
            if (message.senderPublicKey != null && Object.hasOwnProperty.call(message, "senderPublicKey"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.senderPublicKey);
            if (message.assetId != null && Object.hasOwnProperty.call(message, "assetId"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.assetId);
            if (message.quantity != null && Object.hasOwnProperty.call(message, "quantity"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.quantity);
            if (message.reissuable != null && Object.hasOwnProperty.call(message, "reissuable"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.reissuable);
            if (message.fee != null && Object.hasOwnProperty.call(message, "fee"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.fee);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 8, wireType 0 =*/64).int64(message.timestamp);
            if (message.proofs != null && message.proofs.length)
                for (var i = 0; i < message.proofs.length; ++i)
                    writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.proofs[i]);
            return writer;
        };

        /**
         * Encodes the specified ReissueTransaction message, length delimited. Does not implicitly {@link wavesenterprise.ReissueTransaction.verify|verify} messages.
         * @function encodeDelimited
         * @memberof wavesenterprise.ReissueTransaction
         * @static
         * @param {wavesenterprise.IReissueTransaction} message ReissueTransaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReissueTransaction.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ReissueTransaction message from the specified reader or buffer.
         * @function decode
         * @memberof wavesenterprise.ReissueTransaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {wavesenterprise.ReissueTransaction} ReissueTransaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReissueTransaction.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.wavesenterprise.ReissueTransaction();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.bytes();
                    break;
                case 2:
                    message.chainId = reader.int32();
                    break;
                case 3:
                    message.senderPublicKey = reader.bytes();
                    break;
                case 4:
                    message.assetId = reader.bytes();
                    break;
                case 5:
                    message.quantity = reader.int64();
                    break;
                case 6:
                    message.reissuable = reader.bool();
                    break;
                case 7:
                    message.fee = reader.int64();
                    break;
                case 8:
                    message.timestamp = reader.int64();
                    break;
                case 9:
                    if (!(message.proofs && message.proofs.length))
                        message.proofs = [];
                    message.proofs.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ReissueTransaction message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof wavesenterprise.ReissueTransaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {wavesenterprise.ReissueTransaction} ReissueTransaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReissueTransaction.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ReissueTransaction message.
         * @function verify
         * @memberof wavesenterprise.ReissueTransaction
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ReissueTransaction.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!(message.id && typeof message.id.length === "number" || $util.isString(message.id)))
                    return "id: buffer expected";
            if (message.chainId != null && message.hasOwnProperty("chainId"))
                if (!$util.isInteger(message.chainId))
                    return "chainId: integer expected";
            if (message.senderPublicKey != null && message.hasOwnProperty("senderPublicKey"))
                if (!(message.senderPublicKey && typeof message.senderPublicKey.length === "number" || $util.isString(message.senderPublicKey)))
                    return "senderPublicKey: buffer expected";
            if (message.assetId != null && message.hasOwnProperty("assetId"))
                if (!(message.assetId && typeof message.assetId.length === "number" || $util.isString(message.assetId)))
                    return "assetId: buffer expected";
            if (message.quantity != null && message.hasOwnProperty("quantity"))
                if (!$util.isInteger(message.quantity) && !(message.quantity && $util.isInteger(message.quantity.low) && $util.isInteger(message.quantity.high)))
                    return "quantity: integer|Long expected";
            if (message.reissuable != null && message.hasOwnProperty("reissuable"))
                if (typeof message.reissuable !== "boolean")
                    return "reissuable: boolean expected";
            if (message.fee != null && message.hasOwnProperty("fee"))
                if (!$util.isInteger(message.fee) && !(message.fee && $util.isInteger(message.fee.low) && $util.isInteger(message.fee.high)))
                    return "fee: integer|Long expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            if (message.proofs != null && message.hasOwnProperty("proofs")) {
                if (!Array.isArray(message.proofs))
                    return "proofs: array expected";
                for (var i = 0; i < message.proofs.length; ++i)
                    if (!(message.proofs[i] && typeof message.proofs[i].length === "number" || $util.isString(message.proofs[i])))
                        return "proofs: buffer[] expected";
            }
            return null;
        };

        /**
         * Creates a ReissueTransaction message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof wavesenterprise.ReissueTransaction
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {wavesenterprise.ReissueTransaction} ReissueTransaction
         */
        ReissueTransaction.fromObject = function fromObject(object) {
            if (object instanceof $root.wavesenterprise.ReissueTransaction)
                return object;
            var message = new $root.wavesenterprise.ReissueTransaction();
            if (object.id != null)
                if (typeof object.id === "string")
                    $util.base64.decode(object.id, message.id = $util.newBuffer($util.base64.length(object.id)), 0);
                else if (object.id.length)
                    message.id = object.id;
            if (object.chainId != null)
                message.chainId = object.chainId | 0;
            if (object.senderPublicKey != null)
                if (typeof object.senderPublicKey === "string")
                    $util.base64.decode(object.senderPublicKey, message.senderPublicKey = $util.newBuffer($util.base64.length(object.senderPublicKey)), 0);
                else if (object.senderPublicKey.length)
                    message.senderPublicKey = object.senderPublicKey;
            if (object.assetId != null)
                if (typeof object.assetId === "string")
                    $util.base64.decode(object.assetId, message.assetId = $util.newBuffer($util.base64.length(object.assetId)), 0);
                else if (object.assetId.length)
                    message.assetId = object.assetId;
            if (object.quantity != null)
                if ($util.Long)
                    (message.quantity = $util.Long.fromValue(object.quantity)).unsigned = false;
                else if (typeof object.quantity === "string")
                    message.quantity = parseInt(object.quantity, 10);
                else if (typeof object.quantity === "number")
                    message.quantity = object.quantity;
                else if (typeof object.quantity === "object")
                    message.quantity = new $util.LongBits(object.quantity.low >>> 0, object.quantity.high >>> 0).toNumber();
            if (object.reissuable != null)
                message.reissuable = Boolean(object.reissuable);
            if (object.fee != null)
                if ($util.Long)
                    (message.fee = $util.Long.fromValue(object.fee)).unsigned = false;
                else if (typeof object.fee === "string")
                    message.fee = parseInt(object.fee, 10);
                else if (typeof object.fee === "number")
                    message.fee = object.fee;
                else if (typeof object.fee === "object")
                    message.fee = new $util.LongBits(object.fee.low >>> 0, object.fee.high >>> 0).toNumber();
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            if (object.proofs) {
                if (!Array.isArray(object.proofs))
                    throw TypeError(".wavesenterprise.ReissueTransaction.proofs: array expected");
                message.proofs = [];
                for (var i = 0; i < object.proofs.length; ++i)
                    if (typeof object.proofs[i] === "string")
                        $util.base64.decode(object.proofs[i], message.proofs[i] = $util.newBuffer($util.base64.length(object.proofs[i])), 0);
                    else if (object.proofs[i].length)
                        message.proofs[i] = object.proofs[i];
            }
            return message;
        };

        /**
         * Creates a plain object from a ReissueTransaction message. Also converts values to other types if specified.
         * @function toObject
         * @memberof wavesenterprise.ReissueTransaction
         * @static
         * @param {wavesenterprise.ReissueTransaction} message ReissueTransaction
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ReissueTransaction.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.proofs = [];
            if (options.defaults) {
                if (options.bytes === String)
                    object.id = "";
                else {
                    object.id = [];
                    if (options.bytes !== Array)
                        object.id = $util.newBuffer(object.id);
                }
                object.chainId = 0;
                if (options.bytes === String)
                    object.senderPublicKey = "";
                else {
                    object.senderPublicKey = [];
                    if (options.bytes !== Array)
                        object.senderPublicKey = $util.newBuffer(object.senderPublicKey);
                }
                if (options.bytes === String)
                    object.assetId = "";
                else {
                    object.assetId = [];
                    if (options.bytes !== Array)
                        object.assetId = $util.newBuffer(object.assetId);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.quantity = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.quantity = options.longs === String ? "0" : 0;
                object.reissuable = false;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.fee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.fee = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = options.bytes === String ? $util.base64.encode(message.id, 0, message.id.length) : options.bytes === Array ? Array.prototype.slice.call(message.id) : message.id;
            if (message.chainId != null && message.hasOwnProperty("chainId"))
                object.chainId = message.chainId;
            if (message.senderPublicKey != null && message.hasOwnProperty("senderPublicKey"))
                object.senderPublicKey = options.bytes === String ? $util.base64.encode(message.senderPublicKey, 0, message.senderPublicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.senderPublicKey) : message.senderPublicKey;
            if (message.assetId != null && message.hasOwnProperty("assetId"))
                object.assetId = options.bytes === String ? $util.base64.encode(message.assetId, 0, message.assetId.length) : options.bytes === Array ? Array.prototype.slice.call(message.assetId) : message.assetId;
            if (message.quantity != null && message.hasOwnProperty("quantity"))
                if (typeof message.quantity === "number")
                    object.quantity = options.longs === String ? String(message.quantity) : message.quantity;
                else
                    object.quantity = options.longs === String ? $util.Long.prototype.toString.call(message.quantity) : options.longs === Number ? new $util.LongBits(message.quantity.low >>> 0, message.quantity.high >>> 0).toNumber() : message.quantity;
            if (message.reissuable != null && message.hasOwnProperty("reissuable"))
                object.reissuable = message.reissuable;
            if (message.fee != null && message.hasOwnProperty("fee"))
                if (typeof message.fee === "number")
                    object.fee = options.longs === String ? String(message.fee) : message.fee;
                else
                    object.fee = options.longs === String ? $util.Long.prototype.toString.call(message.fee) : options.longs === Number ? new $util.LongBits(message.fee.low >>> 0, message.fee.high >>> 0).toNumber() : message.fee;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            if (message.proofs && message.proofs.length) {
                object.proofs = [];
                for (var j = 0; j < message.proofs.length; ++j)
                    object.proofs[j] = options.bytes === String ? $util.base64.encode(message.proofs[j], 0, message.proofs[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.proofs[j]) : message.proofs[j];
            }
            return object;
        };

        /**
         * Converts this ReissueTransaction to JSON.
         * @function toJSON
         * @memberof wavesenterprise.ReissueTransaction
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ReissueTransaction.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ReissueTransaction;
    })();

    wavesenterprise.BurnTransaction = (function() {

        /**
         * Properties of a BurnTransaction.
         * @memberof wavesenterprise
         * @interface IBurnTransaction
         * @property {Uint8Array|null} [id] BurnTransaction id
         * @property {number|null} [chainId] BurnTransaction chainId
         * @property {Uint8Array|null} [senderPublicKey] BurnTransaction senderPublicKey
         * @property {Uint8Array|null} [assetId] BurnTransaction assetId
         * @property {number|Long|null} [amount] BurnTransaction amount
         * @property {number|Long|null} [fee] BurnTransaction fee
         * @property {number|Long|null} [timestamp] BurnTransaction timestamp
         * @property {Array.<Uint8Array>|null} [proofs] BurnTransaction proofs
         */

        /**
         * Constructs a new BurnTransaction.
         * @memberof wavesenterprise
         * @classdesc Represents a BurnTransaction.
         * @implements IBurnTransaction
         * @constructor
         * @param {wavesenterprise.IBurnTransaction=} [properties] Properties to set
         */
        function BurnTransaction(properties) {
            this.proofs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BurnTransaction id.
         * @member {Uint8Array} id
         * @memberof wavesenterprise.BurnTransaction
         * @instance
         */
        BurnTransaction.prototype.id = $util.newBuffer([]);

        /**
         * BurnTransaction chainId.
         * @member {number} chainId
         * @memberof wavesenterprise.BurnTransaction
         * @instance
         */
        BurnTransaction.prototype.chainId = 0;

        /**
         * BurnTransaction senderPublicKey.
         * @member {Uint8Array} senderPublicKey
         * @memberof wavesenterprise.BurnTransaction
         * @instance
         */
        BurnTransaction.prototype.senderPublicKey = $util.newBuffer([]);

        /**
         * BurnTransaction assetId.
         * @member {Uint8Array} assetId
         * @memberof wavesenterprise.BurnTransaction
         * @instance
         */
        BurnTransaction.prototype.assetId = $util.newBuffer([]);

        /**
         * BurnTransaction amount.
         * @member {number|Long} amount
         * @memberof wavesenterprise.BurnTransaction
         * @instance
         */
        BurnTransaction.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * BurnTransaction fee.
         * @member {number|Long} fee
         * @memberof wavesenterprise.BurnTransaction
         * @instance
         */
        BurnTransaction.prototype.fee = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * BurnTransaction timestamp.
         * @member {number|Long} timestamp
         * @memberof wavesenterprise.BurnTransaction
         * @instance
         */
        BurnTransaction.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * BurnTransaction proofs.
         * @member {Array.<Uint8Array>} proofs
         * @memberof wavesenterprise.BurnTransaction
         * @instance
         */
        BurnTransaction.prototype.proofs = $util.emptyArray;

        /**
         * Creates a new BurnTransaction instance using the specified properties.
         * @function create
         * @memberof wavesenterprise.BurnTransaction
         * @static
         * @param {wavesenterprise.IBurnTransaction=} [properties] Properties to set
         * @returns {wavesenterprise.BurnTransaction} BurnTransaction instance
         */
        BurnTransaction.create = function create(properties) {
            return new BurnTransaction(properties);
        };

        /**
         * Encodes the specified BurnTransaction message. Does not implicitly {@link wavesenterprise.BurnTransaction.verify|verify} messages.
         * @function encode
         * @memberof wavesenterprise.BurnTransaction
         * @static
         * @param {wavesenterprise.IBurnTransaction} message BurnTransaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BurnTransaction.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.id);
            if (message.chainId != null && Object.hasOwnProperty.call(message, "chainId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.chainId);
            if (message.senderPublicKey != null && Object.hasOwnProperty.call(message, "senderPublicKey"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.senderPublicKey);
            if (message.assetId != null && Object.hasOwnProperty.call(message, "assetId"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.assetId);
            if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.amount);
            if (message.fee != null && Object.hasOwnProperty.call(message, "fee"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.fee);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.timestamp);
            if (message.proofs != null && message.proofs.length)
                for (var i = 0; i < message.proofs.length; ++i)
                    writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.proofs[i]);
            return writer;
        };

        /**
         * Encodes the specified BurnTransaction message, length delimited. Does not implicitly {@link wavesenterprise.BurnTransaction.verify|verify} messages.
         * @function encodeDelimited
         * @memberof wavesenterprise.BurnTransaction
         * @static
         * @param {wavesenterprise.IBurnTransaction} message BurnTransaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BurnTransaction.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BurnTransaction message from the specified reader or buffer.
         * @function decode
         * @memberof wavesenterprise.BurnTransaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {wavesenterprise.BurnTransaction} BurnTransaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BurnTransaction.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.wavesenterprise.BurnTransaction();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.bytes();
                    break;
                case 2:
                    message.chainId = reader.int32();
                    break;
                case 3:
                    message.senderPublicKey = reader.bytes();
                    break;
                case 4:
                    message.assetId = reader.bytes();
                    break;
                case 5:
                    message.amount = reader.int64();
                    break;
                case 6:
                    message.fee = reader.int64();
                    break;
                case 7:
                    message.timestamp = reader.int64();
                    break;
                case 8:
                    if (!(message.proofs && message.proofs.length))
                        message.proofs = [];
                    message.proofs.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BurnTransaction message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof wavesenterprise.BurnTransaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {wavesenterprise.BurnTransaction} BurnTransaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BurnTransaction.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BurnTransaction message.
         * @function verify
         * @memberof wavesenterprise.BurnTransaction
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BurnTransaction.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!(message.id && typeof message.id.length === "number" || $util.isString(message.id)))
                    return "id: buffer expected";
            if (message.chainId != null && message.hasOwnProperty("chainId"))
                if (!$util.isInteger(message.chainId))
                    return "chainId: integer expected";
            if (message.senderPublicKey != null && message.hasOwnProperty("senderPublicKey"))
                if (!(message.senderPublicKey && typeof message.senderPublicKey.length === "number" || $util.isString(message.senderPublicKey)))
                    return "senderPublicKey: buffer expected";
            if (message.assetId != null && message.hasOwnProperty("assetId"))
                if (!(message.assetId && typeof message.assetId.length === "number" || $util.isString(message.assetId)))
                    return "assetId: buffer expected";
            if (message.amount != null && message.hasOwnProperty("amount"))
                if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                    return "amount: integer|Long expected";
            if (message.fee != null && message.hasOwnProperty("fee"))
                if (!$util.isInteger(message.fee) && !(message.fee && $util.isInteger(message.fee.low) && $util.isInteger(message.fee.high)))
                    return "fee: integer|Long expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            if (message.proofs != null && message.hasOwnProperty("proofs")) {
                if (!Array.isArray(message.proofs))
                    return "proofs: array expected";
                for (var i = 0; i < message.proofs.length; ++i)
                    if (!(message.proofs[i] && typeof message.proofs[i].length === "number" || $util.isString(message.proofs[i])))
                        return "proofs: buffer[] expected";
            }
            return null;
        };

        /**
         * Creates a BurnTransaction message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof wavesenterprise.BurnTransaction
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {wavesenterprise.BurnTransaction} BurnTransaction
         */
        BurnTransaction.fromObject = function fromObject(object) {
            if (object instanceof $root.wavesenterprise.BurnTransaction)
                return object;
            var message = new $root.wavesenterprise.BurnTransaction();
            if (object.id != null)
                if (typeof object.id === "string")
                    $util.base64.decode(object.id, message.id = $util.newBuffer($util.base64.length(object.id)), 0);
                else if (object.id.length)
                    message.id = object.id;
            if (object.chainId != null)
                message.chainId = object.chainId | 0;
            if (object.senderPublicKey != null)
                if (typeof object.senderPublicKey === "string")
                    $util.base64.decode(object.senderPublicKey, message.senderPublicKey = $util.newBuffer($util.base64.length(object.senderPublicKey)), 0);
                else if (object.senderPublicKey.length)
                    message.senderPublicKey = object.senderPublicKey;
            if (object.assetId != null)
                if (typeof object.assetId === "string")
                    $util.base64.decode(object.assetId, message.assetId = $util.newBuffer($util.base64.length(object.assetId)), 0);
                else if (object.assetId.length)
                    message.assetId = object.assetId;
            if (object.amount != null)
                if ($util.Long)
                    (message.amount = $util.Long.fromValue(object.amount)).unsigned = false;
                else if (typeof object.amount === "string")
                    message.amount = parseInt(object.amount, 10);
                else if (typeof object.amount === "number")
                    message.amount = object.amount;
                else if (typeof object.amount === "object")
                    message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber();
            if (object.fee != null)
                if ($util.Long)
                    (message.fee = $util.Long.fromValue(object.fee)).unsigned = false;
                else if (typeof object.fee === "string")
                    message.fee = parseInt(object.fee, 10);
                else if (typeof object.fee === "number")
                    message.fee = object.fee;
                else if (typeof object.fee === "object")
                    message.fee = new $util.LongBits(object.fee.low >>> 0, object.fee.high >>> 0).toNumber();
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            if (object.proofs) {
                if (!Array.isArray(object.proofs))
                    throw TypeError(".wavesenterprise.BurnTransaction.proofs: array expected");
                message.proofs = [];
                for (var i = 0; i < object.proofs.length; ++i)
                    if (typeof object.proofs[i] === "string")
                        $util.base64.decode(object.proofs[i], message.proofs[i] = $util.newBuffer($util.base64.length(object.proofs[i])), 0);
                    else if (object.proofs[i].length)
                        message.proofs[i] = object.proofs[i];
            }
            return message;
        };

        /**
         * Creates a plain object from a BurnTransaction message. Also converts values to other types if specified.
         * @function toObject
         * @memberof wavesenterprise.BurnTransaction
         * @static
         * @param {wavesenterprise.BurnTransaction} message BurnTransaction
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BurnTransaction.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.proofs = [];
            if (options.defaults) {
                if (options.bytes === String)
                    object.id = "";
                else {
                    object.id = [];
                    if (options.bytes !== Array)
                        object.id = $util.newBuffer(object.id);
                }
                object.chainId = 0;
                if (options.bytes === String)
                    object.senderPublicKey = "";
                else {
                    object.senderPublicKey = [];
                    if (options.bytes !== Array)
                        object.senderPublicKey = $util.newBuffer(object.senderPublicKey);
                }
                if (options.bytes === String)
                    object.assetId = "";
                else {
                    object.assetId = [];
                    if (options.bytes !== Array)
                        object.assetId = $util.newBuffer(object.assetId);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.amount = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.fee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.fee = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = options.bytes === String ? $util.base64.encode(message.id, 0, message.id.length) : options.bytes === Array ? Array.prototype.slice.call(message.id) : message.id;
            if (message.chainId != null && message.hasOwnProperty("chainId"))
                object.chainId = message.chainId;
            if (message.senderPublicKey != null && message.hasOwnProperty("senderPublicKey"))
                object.senderPublicKey = options.bytes === String ? $util.base64.encode(message.senderPublicKey, 0, message.senderPublicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.senderPublicKey) : message.senderPublicKey;
            if (message.assetId != null && message.hasOwnProperty("assetId"))
                object.assetId = options.bytes === String ? $util.base64.encode(message.assetId, 0, message.assetId.length) : options.bytes === Array ? Array.prototype.slice.call(message.assetId) : message.assetId;
            if (message.amount != null && message.hasOwnProperty("amount"))
                if (typeof message.amount === "number")
                    object.amount = options.longs === String ? String(message.amount) : message.amount;
                else
                    object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber() : message.amount;
            if (message.fee != null && message.hasOwnProperty("fee"))
                if (typeof message.fee === "number")
                    object.fee = options.longs === String ? String(message.fee) : message.fee;
                else
                    object.fee = options.longs === String ? $util.Long.prototype.toString.call(message.fee) : options.longs === Number ? new $util.LongBits(message.fee.low >>> 0, message.fee.high >>> 0).toNumber() : message.fee;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            if (message.proofs && message.proofs.length) {
                object.proofs = [];
                for (var j = 0; j < message.proofs.length; ++j)
                    object.proofs[j] = options.bytes === String ? $util.base64.encode(message.proofs[j], 0, message.proofs[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.proofs[j]) : message.proofs[j];
            }
            return object;
        };

        /**
         * Converts this BurnTransaction to JSON.
         * @function toJSON
         * @memberof wavesenterprise.BurnTransaction
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BurnTransaction.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BurnTransaction;
    })();

    wavesenterprise.LeaseTransaction = (function() {

        /**
         * Properties of a LeaseTransaction.
         * @memberof wavesenterprise
         * @interface ILeaseTransaction
         * @property {Uint8Array|null} [id] LeaseTransaction id
         * @property {google.protobuf.IBytesValue|null} [assetId] LeaseTransaction assetId
         * @property {Uint8Array|null} [senderPublicKey] LeaseTransaction senderPublicKey
         * @property {Uint8Array|null} [recipient] LeaseTransaction recipient
         * @property {number|Long|null} [amount] LeaseTransaction amount
         * @property {number|Long|null} [fee] LeaseTransaction fee
         * @property {number|Long|null} [timestamp] LeaseTransaction timestamp
         * @property {Array.<Uint8Array>|null} [proofs] LeaseTransaction proofs
         */

        /**
         * Constructs a new LeaseTransaction.
         * @memberof wavesenterprise
         * @classdesc Represents a LeaseTransaction.
         * @implements ILeaseTransaction
         * @constructor
         * @param {wavesenterprise.ILeaseTransaction=} [properties] Properties to set
         */
        function LeaseTransaction(properties) {
            this.proofs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LeaseTransaction id.
         * @member {Uint8Array} id
         * @memberof wavesenterprise.LeaseTransaction
         * @instance
         */
        LeaseTransaction.prototype.id = $util.newBuffer([]);

        /**
         * LeaseTransaction assetId.
         * @member {google.protobuf.IBytesValue|null|undefined} assetId
         * @memberof wavesenterprise.LeaseTransaction
         * @instance
         */
        LeaseTransaction.prototype.assetId = null;

        /**
         * LeaseTransaction senderPublicKey.
         * @member {Uint8Array} senderPublicKey
         * @memberof wavesenterprise.LeaseTransaction
         * @instance
         */
        LeaseTransaction.prototype.senderPublicKey = $util.newBuffer([]);

        /**
         * LeaseTransaction recipient.
         * @member {Uint8Array} recipient
         * @memberof wavesenterprise.LeaseTransaction
         * @instance
         */
        LeaseTransaction.prototype.recipient = $util.newBuffer([]);

        /**
         * LeaseTransaction amount.
         * @member {number|Long} amount
         * @memberof wavesenterprise.LeaseTransaction
         * @instance
         */
        LeaseTransaction.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * LeaseTransaction fee.
         * @member {number|Long} fee
         * @memberof wavesenterprise.LeaseTransaction
         * @instance
         */
        LeaseTransaction.prototype.fee = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * LeaseTransaction timestamp.
         * @member {number|Long} timestamp
         * @memberof wavesenterprise.LeaseTransaction
         * @instance
         */
        LeaseTransaction.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * LeaseTransaction proofs.
         * @member {Array.<Uint8Array>} proofs
         * @memberof wavesenterprise.LeaseTransaction
         * @instance
         */
        LeaseTransaction.prototype.proofs = $util.emptyArray;

        /**
         * Creates a new LeaseTransaction instance using the specified properties.
         * @function create
         * @memberof wavesenterprise.LeaseTransaction
         * @static
         * @param {wavesenterprise.ILeaseTransaction=} [properties] Properties to set
         * @returns {wavesenterprise.LeaseTransaction} LeaseTransaction instance
         */
        LeaseTransaction.create = function create(properties) {
            return new LeaseTransaction(properties);
        };

        /**
         * Encodes the specified LeaseTransaction message. Does not implicitly {@link wavesenterprise.LeaseTransaction.verify|verify} messages.
         * @function encode
         * @memberof wavesenterprise.LeaseTransaction
         * @static
         * @param {wavesenterprise.ILeaseTransaction} message LeaseTransaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LeaseTransaction.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.id);
            if (message.assetId != null && Object.hasOwnProperty.call(message, "assetId"))
                $root.google.protobuf.BytesValue.encode(message.assetId, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.senderPublicKey != null && Object.hasOwnProperty.call(message, "senderPublicKey"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.senderPublicKey);
            if (message.recipient != null && Object.hasOwnProperty.call(message, "recipient"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.recipient);
            if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.amount);
            if (message.fee != null && Object.hasOwnProperty.call(message, "fee"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.fee);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.timestamp);
            if (message.proofs != null && message.proofs.length)
                for (var i = 0; i < message.proofs.length; ++i)
                    writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.proofs[i]);
            return writer;
        };

        /**
         * Encodes the specified LeaseTransaction message, length delimited. Does not implicitly {@link wavesenterprise.LeaseTransaction.verify|verify} messages.
         * @function encodeDelimited
         * @memberof wavesenterprise.LeaseTransaction
         * @static
         * @param {wavesenterprise.ILeaseTransaction} message LeaseTransaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LeaseTransaction.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LeaseTransaction message from the specified reader or buffer.
         * @function decode
         * @memberof wavesenterprise.LeaseTransaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {wavesenterprise.LeaseTransaction} LeaseTransaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LeaseTransaction.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.wavesenterprise.LeaseTransaction();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.bytes();
                    break;
                case 2:
                    message.assetId = $root.google.protobuf.BytesValue.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.senderPublicKey = reader.bytes();
                    break;
                case 4:
                    message.recipient = reader.bytes();
                    break;
                case 5:
                    message.amount = reader.int64();
                    break;
                case 6:
                    message.fee = reader.int64();
                    break;
                case 7:
                    message.timestamp = reader.int64();
                    break;
                case 8:
                    if (!(message.proofs && message.proofs.length))
                        message.proofs = [];
                    message.proofs.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LeaseTransaction message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof wavesenterprise.LeaseTransaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {wavesenterprise.LeaseTransaction} LeaseTransaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LeaseTransaction.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LeaseTransaction message.
         * @function verify
         * @memberof wavesenterprise.LeaseTransaction
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LeaseTransaction.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!(message.id && typeof message.id.length === "number" || $util.isString(message.id)))
                    return "id: buffer expected";
            if (message.assetId != null && message.hasOwnProperty("assetId")) {
                var error = $root.google.protobuf.BytesValue.verify(message.assetId);
                if (error)
                    return "assetId." + error;
            }
            if (message.senderPublicKey != null && message.hasOwnProperty("senderPublicKey"))
                if (!(message.senderPublicKey && typeof message.senderPublicKey.length === "number" || $util.isString(message.senderPublicKey)))
                    return "senderPublicKey: buffer expected";
            if (message.recipient != null && message.hasOwnProperty("recipient"))
                if (!(message.recipient && typeof message.recipient.length === "number" || $util.isString(message.recipient)))
                    return "recipient: buffer expected";
            if (message.amount != null && message.hasOwnProperty("amount"))
                if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                    return "amount: integer|Long expected";
            if (message.fee != null && message.hasOwnProperty("fee"))
                if (!$util.isInteger(message.fee) && !(message.fee && $util.isInteger(message.fee.low) && $util.isInteger(message.fee.high)))
                    return "fee: integer|Long expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            if (message.proofs != null && message.hasOwnProperty("proofs")) {
                if (!Array.isArray(message.proofs))
                    return "proofs: array expected";
                for (var i = 0; i < message.proofs.length; ++i)
                    if (!(message.proofs[i] && typeof message.proofs[i].length === "number" || $util.isString(message.proofs[i])))
                        return "proofs: buffer[] expected";
            }
            return null;
        };

        /**
         * Creates a LeaseTransaction message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof wavesenterprise.LeaseTransaction
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {wavesenterprise.LeaseTransaction} LeaseTransaction
         */
        LeaseTransaction.fromObject = function fromObject(object) {
            if (object instanceof $root.wavesenterprise.LeaseTransaction)
                return object;
            var message = new $root.wavesenterprise.LeaseTransaction();
            if (object.id != null)
                if (typeof object.id === "string")
                    $util.base64.decode(object.id, message.id = $util.newBuffer($util.base64.length(object.id)), 0);
                else if (object.id.length)
                    message.id = object.id;
            if (object.assetId != null) {
                if (typeof object.assetId !== "object")
                    throw TypeError(".wavesenterprise.LeaseTransaction.assetId: object expected");
                message.assetId = $root.google.protobuf.BytesValue.fromObject(object.assetId);
            }
            if (object.senderPublicKey != null)
                if (typeof object.senderPublicKey === "string")
                    $util.base64.decode(object.senderPublicKey, message.senderPublicKey = $util.newBuffer($util.base64.length(object.senderPublicKey)), 0);
                else if (object.senderPublicKey.length)
                    message.senderPublicKey = object.senderPublicKey;
            if (object.recipient != null)
                if (typeof object.recipient === "string")
                    $util.base64.decode(object.recipient, message.recipient = $util.newBuffer($util.base64.length(object.recipient)), 0);
                else if (object.recipient.length)
                    message.recipient = object.recipient;
            if (object.amount != null)
                if ($util.Long)
                    (message.amount = $util.Long.fromValue(object.amount)).unsigned = false;
                else if (typeof object.amount === "string")
                    message.amount = parseInt(object.amount, 10);
                else if (typeof object.amount === "number")
                    message.amount = object.amount;
                else if (typeof object.amount === "object")
                    message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber();
            if (object.fee != null)
                if ($util.Long)
                    (message.fee = $util.Long.fromValue(object.fee)).unsigned = false;
                else if (typeof object.fee === "string")
                    message.fee = parseInt(object.fee, 10);
                else if (typeof object.fee === "number")
                    message.fee = object.fee;
                else if (typeof object.fee === "object")
                    message.fee = new $util.LongBits(object.fee.low >>> 0, object.fee.high >>> 0).toNumber();
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            if (object.proofs) {
                if (!Array.isArray(object.proofs))
                    throw TypeError(".wavesenterprise.LeaseTransaction.proofs: array expected");
                message.proofs = [];
                for (var i = 0; i < object.proofs.length; ++i)
                    if (typeof object.proofs[i] === "string")
                        $util.base64.decode(object.proofs[i], message.proofs[i] = $util.newBuffer($util.base64.length(object.proofs[i])), 0);
                    else if (object.proofs[i].length)
                        message.proofs[i] = object.proofs[i];
            }
            return message;
        };

        /**
         * Creates a plain object from a LeaseTransaction message. Also converts values to other types if specified.
         * @function toObject
         * @memberof wavesenterprise.LeaseTransaction
         * @static
         * @param {wavesenterprise.LeaseTransaction} message LeaseTransaction
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LeaseTransaction.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.proofs = [];
            if (options.defaults) {
                if (options.bytes === String)
                    object.id = "";
                else {
                    object.id = [];
                    if (options.bytes !== Array)
                        object.id = $util.newBuffer(object.id);
                }
                object.assetId = null;
                if (options.bytes === String)
                    object.senderPublicKey = "";
                else {
                    object.senderPublicKey = [];
                    if (options.bytes !== Array)
                        object.senderPublicKey = $util.newBuffer(object.senderPublicKey);
                }
                if (options.bytes === String)
                    object.recipient = "";
                else {
                    object.recipient = [];
                    if (options.bytes !== Array)
                        object.recipient = $util.newBuffer(object.recipient);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.amount = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.fee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.fee = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = options.bytes === String ? $util.base64.encode(message.id, 0, message.id.length) : options.bytes === Array ? Array.prototype.slice.call(message.id) : message.id;
            if (message.assetId != null && message.hasOwnProperty("assetId"))
                object.assetId = $root.google.protobuf.BytesValue.toObject(message.assetId, options);
            if (message.senderPublicKey != null && message.hasOwnProperty("senderPublicKey"))
                object.senderPublicKey = options.bytes === String ? $util.base64.encode(message.senderPublicKey, 0, message.senderPublicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.senderPublicKey) : message.senderPublicKey;
            if (message.recipient != null && message.hasOwnProperty("recipient"))
                object.recipient = options.bytes === String ? $util.base64.encode(message.recipient, 0, message.recipient.length) : options.bytes === Array ? Array.prototype.slice.call(message.recipient) : message.recipient;
            if (message.amount != null && message.hasOwnProperty("amount"))
                if (typeof message.amount === "number")
                    object.amount = options.longs === String ? String(message.amount) : message.amount;
                else
                    object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber() : message.amount;
            if (message.fee != null && message.hasOwnProperty("fee"))
                if (typeof message.fee === "number")
                    object.fee = options.longs === String ? String(message.fee) : message.fee;
                else
                    object.fee = options.longs === String ? $util.Long.prototype.toString.call(message.fee) : options.longs === Number ? new $util.LongBits(message.fee.low >>> 0, message.fee.high >>> 0).toNumber() : message.fee;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            if (message.proofs && message.proofs.length) {
                object.proofs = [];
                for (var j = 0; j < message.proofs.length; ++j)
                    object.proofs[j] = options.bytes === String ? $util.base64.encode(message.proofs[j], 0, message.proofs[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.proofs[j]) : message.proofs[j];
            }
            return object;
        };

        /**
         * Converts this LeaseTransaction to JSON.
         * @function toJSON
         * @memberof wavesenterprise.LeaseTransaction
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LeaseTransaction.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return LeaseTransaction;
    })();

    wavesenterprise.LeaseCancelTransaction = (function() {

        /**
         * Properties of a LeaseCancelTransaction.
         * @memberof wavesenterprise
         * @interface ILeaseCancelTransaction
         * @property {Uint8Array|null} [id] LeaseCancelTransaction id
         * @property {number|null} [chainId] LeaseCancelTransaction chainId
         * @property {Uint8Array|null} [senderPublicKey] LeaseCancelTransaction senderPublicKey
         * @property {number|Long|null} [fee] LeaseCancelTransaction fee
         * @property {number|Long|null} [timestamp] LeaseCancelTransaction timestamp
         * @property {Uint8Array|null} [leaseId] LeaseCancelTransaction leaseId
         * @property {Array.<Uint8Array>|null} [proofs] LeaseCancelTransaction proofs
         */

        /**
         * Constructs a new LeaseCancelTransaction.
         * @memberof wavesenterprise
         * @classdesc Represents a LeaseCancelTransaction.
         * @implements ILeaseCancelTransaction
         * @constructor
         * @param {wavesenterprise.ILeaseCancelTransaction=} [properties] Properties to set
         */
        function LeaseCancelTransaction(properties) {
            this.proofs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LeaseCancelTransaction id.
         * @member {Uint8Array} id
         * @memberof wavesenterprise.LeaseCancelTransaction
         * @instance
         */
        LeaseCancelTransaction.prototype.id = $util.newBuffer([]);

        /**
         * LeaseCancelTransaction chainId.
         * @member {number} chainId
         * @memberof wavesenterprise.LeaseCancelTransaction
         * @instance
         */
        LeaseCancelTransaction.prototype.chainId = 0;

        /**
         * LeaseCancelTransaction senderPublicKey.
         * @member {Uint8Array} senderPublicKey
         * @memberof wavesenterprise.LeaseCancelTransaction
         * @instance
         */
        LeaseCancelTransaction.prototype.senderPublicKey = $util.newBuffer([]);

        /**
         * LeaseCancelTransaction fee.
         * @member {number|Long} fee
         * @memberof wavesenterprise.LeaseCancelTransaction
         * @instance
         */
        LeaseCancelTransaction.prototype.fee = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * LeaseCancelTransaction timestamp.
         * @member {number|Long} timestamp
         * @memberof wavesenterprise.LeaseCancelTransaction
         * @instance
         */
        LeaseCancelTransaction.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * LeaseCancelTransaction leaseId.
         * @member {Uint8Array} leaseId
         * @memberof wavesenterprise.LeaseCancelTransaction
         * @instance
         */
        LeaseCancelTransaction.prototype.leaseId = $util.newBuffer([]);

        /**
         * LeaseCancelTransaction proofs.
         * @member {Array.<Uint8Array>} proofs
         * @memberof wavesenterprise.LeaseCancelTransaction
         * @instance
         */
        LeaseCancelTransaction.prototype.proofs = $util.emptyArray;

        /**
         * Creates a new LeaseCancelTransaction instance using the specified properties.
         * @function create
         * @memberof wavesenterprise.LeaseCancelTransaction
         * @static
         * @param {wavesenterprise.ILeaseCancelTransaction=} [properties] Properties to set
         * @returns {wavesenterprise.LeaseCancelTransaction} LeaseCancelTransaction instance
         */
        LeaseCancelTransaction.create = function create(properties) {
            return new LeaseCancelTransaction(properties);
        };

        /**
         * Encodes the specified LeaseCancelTransaction message. Does not implicitly {@link wavesenterprise.LeaseCancelTransaction.verify|verify} messages.
         * @function encode
         * @memberof wavesenterprise.LeaseCancelTransaction
         * @static
         * @param {wavesenterprise.ILeaseCancelTransaction} message LeaseCancelTransaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LeaseCancelTransaction.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.id);
            if (message.chainId != null && Object.hasOwnProperty.call(message, "chainId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.chainId);
            if (message.senderPublicKey != null && Object.hasOwnProperty.call(message, "senderPublicKey"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.senderPublicKey);
            if (message.fee != null && Object.hasOwnProperty.call(message, "fee"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.fee);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.timestamp);
            if (message.leaseId != null && Object.hasOwnProperty.call(message, "leaseId"))
                writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.leaseId);
            if (message.proofs != null && message.proofs.length)
                for (var i = 0; i < message.proofs.length; ++i)
                    writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.proofs[i]);
            return writer;
        };

        /**
         * Encodes the specified LeaseCancelTransaction message, length delimited. Does not implicitly {@link wavesenterprise.LeaseCancelTransaction.verify|verify} messages.
         * @function encodeDelimited
         * @memberof wavesenterprise.LeaseCancelTransaction
         * @static
         * @param {wavesenterprise.ILeaseCancelTransaction} message LeaseCancelTransaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LeaseCancelTransaction.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LeaseCancelTransaction message from the specified reader or buffer.
         * @function decode
         * @memberof wavesenterprise.LeaseCancelTransaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {wavesenterprise.LeaseCancelTransaction} LeaseCancelTransaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LeaseCancelTransaction.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.wavesenterprise.LeaseCancelTransaction();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.bytes();
                    break;
                case 2:
                    message.chainId = reader.int32();
                    break;
                case 3:
                    message.senderPublicKey = reader.bytes();
                    break;
                case 4:
                    message.fee = reader.int64();
                    break;
                case 5:
                    message.timestamp = reader.int64();
                    break;
                case 6:
                    message.leaseId = reader.bytes();
                    break;
                case 7:
                    if (!(message.proofs && message.proofs.length))
                        message.proofs = [];
                    message.proofs.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LeaseCancelTransaction message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof wavesenterprise.LeaseCancelTransaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {wavesenterprise.LeaseCancelTransaction} LeaseCancelTransaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LeaseCancelTransaction.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LeaseCancelTransaction message.
         * @function verify
         * @memberof wavesenterprise.LeaseCancelTransaction
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LeaseCancelTransaction.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!(message.id && typeof message.id.length === "number" || $util.isString(message.id)))
                    return "id: buffer expected";
            if (message.chainId != null && message.hasOwnProperty("chainId"))
                if (!$util.isInteger(message.chainId))
                    return "chainId: integer expected";
            if (message.senderPublicKey != null && message.hasOwnProperty("senderPublicKey"))
                if (!(message.senderPublicKey && typeof message.senderPublicKey.length === "number" || $util.isString(message.senderPublicKey)))
                    return "senderPublicKey: buffer expected";
            if (message.fee != null && message.hasOwnProperty("fee"))
                if (!$util.isInteger(message.fee) && !(message.fee && $util.isInteger(message.fee.low) && $util.isInteger(message.fee.high)))
                    return "fee: integer|Long expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            if (message.leaseId != null && message.hasOwnProperty("leaseId"))
                if (!(message.leaseId && typeof message.leaseId.length === "number" || $util.isString(message.leaseId)))
                    return "leaseId: buffer expected";
            if (message.proofs != null && message.hasOwnProperty("proofs")) {
                if (!Array.isArray(message.proofs))
                    return "proofs: array expected";
                for (var i = 0; i < message.proofs.length; ++i)
                    if (!(message.proofs[i] && typeof message.proofs[i].length === "number" || $util.isString(message.proofs[i])))
                        return "proofs: buffer[] expected";
            }
            return null;
        };

        /**
         * Creates a LeaseCancelTransaction message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof wavesenterprise.LeaseCancelTransaction
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {wavesenterprise.LeaseCancelTransaction} LeaseCancelTransaction
         */
        LeaseCancelTransaction.fromObject = function fromObject(object) {
            if (object instanceof $root.wavesenterprise.LeaseCancelTransaction)
                return object;
            var message = new $root.wavesenterprise.LeaseCancelTransaction();
            if (object.id != null)
                if (typeof object.id === "string")
                    $util.base64.decode(object.id, message.id = $util.newBuffer($util.base64.length(object.id)), 0);
                else if (object.id.length)
                    message.id = object.id;
            if (object.chainId != null)
                message.chainId = object.chainId | 0;
            if (object.senderPublicKey != null)
                if (typeof object.senderPublicKey === "string")
                    $util.base64.decode(object.senderPublicKey, message.senderPublicKey = $util.newBuffer($util.base64.length(object.senderPublicKey)), 0);
                else if (object.senderPublicKey.length)
                    message.senderPublicKey = object.senderPublicKey;
            if (object.fee != null)
                if ($util.Long)
                    (message.fee = $util.Long.fromValue(object.fee)).unsigned = false;
                else if (typeof object.fee === "string")
                    message.fee = parseInt(object.fee, 10);
                else if (typeof object.fee === "number")
                    message.fee = object.fee;
                else if (typeof object.fee === "object")
                    message.fee = new $util.LongBits(object.fee.low >>> 0, object.fee.high >>> 0).toNumber();
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            if (object.leaseId != null)
                if (typeof object.leaseId === "string")
                    $util.base64.decode(object.leaseId, message.leaseId = $util.newBuffer($util.base64.length(object.leaseId)), 0);
                else if (object.leaseId.length)
                    message.leaseId = object.leaseId;
            if (object.proofs) {
                if (!Array.isArray(object.proofs))
                    throw TypeError(".wavesenterprise.LeaseCancelTransaction.proofs: array expected");
                message.proofs = [];
                for (var i = 0; i < object.proofs.length; ++i)
                    if (typeof object.proofs[i] === "string")
                        $util.base64.decode(object.proofs[i], message.proofs[i] = $util.newBuffer($util.base64.length(object.proofs[i])), 0);
                    else if (object.proofs[i].length)
                        message.proofs[i] = object.proofs[i];
            }
            return message;
        };

        /**
         * Creates a plain object from a LeaseCancelTransaction message. Also converts values to other types if specified.
         * @function toObject
         * @memberof wavesenterprise.LeaseCancelTransaction
         * @static
         * @param {wavesenterprise.LeaseCancelTransaction} message LeaseCancelTransaction
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LeaseCancelTransaction.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.proofs = [];
            if (options.defaults) {
                if (options.bytes === String)
                    object.id = "";
                else {
                    object.id = [];
                    if (options.bytes !== Array)
                        object.id = $util.newBuffer(object.id);
                }
                object.chainId = 0;
                if (options.bytes === String)
                    object.senderPublicKey = "";
                else {
                    object.senderPublicKey = [];
                    if (options.bytes !== Array)
                        object.senderPublicKey = $util.newBuffer(object.senderPublicKey);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.fee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.fee = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.leaseId = "";
                else {
                    object.leaseId = [];
                    if (options.bytes !== Array)
                        object.leaseId = $util.newBuffer(object.leaseId);
                }
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = options.bytes === String ? $util.base64.encode(message.id, 0, message.id.length) : options.bytes === Array ? Array.prototype.slice.call(message.id) : message.id;
            if (message.chainId != null && message.hasOwnProperty("chainId"))
                object.chainId = message.chainId;
            if (message.senderPublicKey != null && message.hasOwnProperty("senderPublicKey"))
                object.senderPublicKey = options.bytes === String ? $util.base64.encode(message.senderPublicKey, 0, message.senderPublicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.senderPublicKey) : message.senderPublicKey;
            if (message.fee != null && message.hasOwnProperty("fee"))
                if (typeof message.fee === "number")
                    object.fee = options.longs === String ? String(message.fee) : message.fee;
                else
                    object.fee = options.longs === String ? $util.Long.prototype.toString.call(message.fee) : options.longs === Number ? new $util.LongBits(message.fee.low >>> 0, message.fee.high >>> 0).toNumber() : message.fee;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            if (message.leaseId != null && message.hasOwnProperty("leaseId"))
                object.leaseId = options.bytes === String ? $util.base64.encode(message.leaseId, 0, message.leaseId.length) : options.bytes === Array ? Array.prototype.slice.call(message.leaseId) : message.leaseId;
            if (message.proofs && message.proofs.length) {
                object.proofs = [];
                for (var j = 0; j < message.proofs.length; ++j)
                    object.proofs[j] = options.bytes === String ? $util.base64.encode(message.proofs[j], 0, message.proofs[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.proofs[j]) : message.proofs[j];
            }
            return object;
        };

        /**
         * Converts this LeaseCancelTransaction to JSON.
         * @function toJSON
         * @memberof wavesenterprise.LeaseCancelTransaction
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LeaseCancelTransaction.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return LeaseCancelTransaction;
    })();

    wavesenterprise.SponsorFeeTransaction = (function() {

        /**
         * Properties of a SponsorFeeTransaction.
         * @memberof wavesenterprise
         * @interface ISponsorFeeTransaction
         * @property {Uint8Array|null} [id] SponsorFeeTransaction id
         * @property {Uint8Array|null} [senderPublicKey] SponsorFeeTransaction senderPublicKey
         * @property {Uint8Array|null} [assetId] SponsorFeeTransaction assetId
         * @property {boolean|null} [isEnabled] SponsorFeeTransaction isEnabled
         * @property {number|Long|null} [fee] SponsorFeeTransaction fee
         * @property {number|Long|null} [timestamp] SponsorFeeTransaction timestamp
         * @property {Array.<Uint8Array>|null} [proofs] SponsorFeeTransaction proofs
         */

        /**
         * Constructs a new SponsorFeeTransaction.
         * @memberof wavesenterprise
         * @classdesc Represents a SponsorFeeTransaction.
         * @implements ISponsorFeeTransaction
         * @constructor
         * @param {wavesenterprise.ISponsorFeeTransaction=} [properties] Properties to set
         */
        function SponsorFeeTransaction(properties) {
            this.proofs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SponsorFeeTransaction id.
         * @member {Uint8Array} id
         * @memberof wavesenterprise.SponsorFeeTransaction
         * @instance
         */
        SponsorFeeTransaction.prototype.id = $util.newBuffer([]);

        /**
         * SponsorFeeTransaction senderPublicKey.
         * @member {Uint8Array} senderPublicKey
         * @memberof wavesenterprise.SponsorFeeTransaction
         * @instance
         */
        SponsorFeeTransaction.prototype.senderPublicKey = $util.newBuffer([]);

        /**
         * SponsorFeeTransaction assetId.
         * @member {Uint8Array} assetId
         * @memberof wavesenterprise.SponsorFeeTransaction
         * @instance
         */
        SponsorFeeTransaction.prototype.assetId = $util.newBuffer([]);

        /**
         * SponsorFeeTransaction isEnabled.
         * @member {boolean} isEnabled
         * @memberof wavesenterprise.SponsorFeeTransaction
         * @instance
         */
        SponsorFeeTransaction.prototype.isEnabled = false;

        /**
         * SponsorFeeTransaction fee.
         * @member {number|Long} fee
         * @memberof wavesenterprise.SponsorFeeTransaction
         * @instance
         */
        SponsorFeeTransaction.prototype.fee = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SponsorFeeTransaction timestamp.
         * @member {number|Long} timestamp
         * @memberof wavesenterprise.SponsorFeeTransaction
         * @instance
         */
        SponsorFeeTransaction.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SponsorFeeTransaction proofs.
         * @member {Array.<Uint8Array>} proofs
         * @memberof wavesenterprise.SponsorFeeTransaction
         * @instance
         */
        SponsorFeeTransaction.prototype.proofs = $util.emptyArray;

        /**
         * Creates a new SponsorFeeTransaction instance using the specified properties.
         * @function create
         * @memberof wavesenterprise.SponsorFeeTransaction
         * @static
         * @param {wavesenterprise.ISponsorFeeTransaction=} [properties] Properties to set
         * @returns {wavesenterprise.SponsorFeeTransaction} SponsorFeeTransaction instance
         */
        SponsorFeeTransaction.create = function create(properties) {
            return new SponsorFeeTransaction(properties);
        };

        /**
         * Encodes the specified SponsorFeeTransaction message. Does not implicitly {@link wavesenterprise.SponsorFeeTransaction.verify|verify} messages.
         * @function encode
         * @memberof wavesenterprise.SponsorFeeTransaction
         * @static
         * @param {wavesenterprise.ISponsorFeeTransaction} message SponsorFeeTransaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SponsorFeeTransaction.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.id);
            if (message.senderPublicKey != null && Object.hasOwnProperty.call(message, "senderPublicKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.senderPublicKey);
            if (message.assetId != null && Object.hasOwnProperty.call(message, "assetId"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.assetId);
            if (message.isEnabled != null && Object.hasOwnProperty.call(message, "isEnabled"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.isEnabled);
            if (message.fee != null && Object.hasOwnProperty.call(message, "fee"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.fee);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.timestamp);
            if (message.proofs != null && message.proofs.length)
                for (var i = 0; i < message.proofs.length; ++i)
                    writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.proofs[i]);
            return writer;
        };

        /**
         * Encodes the specified SponsorFeeTransaction message, length delimited. Does not implicitly {@link wavesenterprise.SponsorFeeTransaction.verify|verify} messages.
         * @function encodeDelimited
         * @memberof wavesenterprise.SponsorFeeTransaction
         * @static
         * @param {wavesenterprise.ISponsorFeeTransaction} message SponsorFeeTransaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SponsorFeeTransaction.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SponsorFeeTransaction message from the specified reader or buffer.
         * @function decode
         * @memberof wavesenterprise.SponsorFeeTransaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {wavesenterprise.SponsorFeeTransaction} SponsorFeeTransaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SponsorFeeTransaction.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.wavesenterprise.SponsorFeeTransaction();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.bytes();
                    break;
                case 2:
                    message.senderPublicKey = reader.bytes();
                    break;
                case 3:
                    message.assetId = reader.bytes();
                    break;
                case 4:
                    message.isEnabled = reader.bool();
                    break;
                case 5:
                    message.fee = reader.int64();
                    break;
                case 6:
                    message.timestamp = reader.int64();
                    break;
                case 7:
                    if (!(message.proofs && message.proofs.length))
                        message.proofs = [];
                    message.proofs.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SponsorFeeTransaction message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof wavesenterprise.SponsorFeeTransaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {wavesenterprise.SponsorFeeTransaction} SponsorFeeTransaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SponsorFeeTransaction.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SponsorFeeTransaction message.
         * @function verify
         * @memberof wavesenterprise.SponsorFeeTransaction
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SponsorFeeTransaction.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!(message.id && typeof message.id.length === "number" || $util.isString(message.id)))
                    return "id: buffer expected";
            if (message.senderPublicKey != null && message.hasOwnProperty("senderPublicKey"))
                if (!(message.senderPublicKey && typeof message.senderPublicKey.length === "number" || $util.isString(message.senderPublicKey)))
                    return "senderPublicKey: buffer expected";
            if (message.assetId != null && message.hasOwnProperty("assetId"))
                if (!(message.assetId && typeof message.assetId.length === "number" || $util.isString(message.assetId)))
                    return "assetId: buffer expected";
            if (message.isEnabled != null && message.hasOwnProperty("isEnabled"))
                if (typeof message.isEnabled !== "boolean")
                    return "isEnabled: boolean expected";
            if (message.fee != null && message.hasOwnProperty("fee"))
                if (!$util.isInteger(message.fee) && !(message.fee && $util.isInteger(message.fee.low) && $util.isInteger(message.fee.high)))
                    return "fee: integer|Long expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            if (message.proofs != null && message.hasOwnProperty("proofs")) {
                if (!Array.isArray(message.proofs))
                    return "proofs: array expected";
                for (var i = 0; i < message.proofs.length; ++i)
                    if (!(message.proofs[i] && typeof message.proofs[i].length === "number" || $util.isString(message.proofs[i])))
                        return "proofs: buffer[] expected";
            }
            return null;
        };

        /**
         * Creates a SponsorFeeTransaction message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof wavesenterprise.SponsorFeeTransaction
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {wavesenterprise.SponsorFeeTransaction} SponsorFeeTransaction
         */
        SponsorFeeTransaction.fromObject = function fromObject(object) {
            if (object instanceof $root.wavesenterprise.SponsorFeeTransaction)
                return object;
            var message = new $root.wavesenterprise.SponsorFeeTransaction();
            if (object.id != null)
                if (typeof object.id === "string")
                    $util.base64.decode(object.id, message.id = $util.newBuffer($util.base64.length(object.id)), 0);
                else if (object.id.length)
                    message.id = object.id;
            if (object.senderPublicKey != null)
                if (typeof object.senderPublicKey === "string")
                    $util.base64.decode(object.senderPublicKey, message.senderPublicKey = $util.newBuffer($util.base64.length(object.senderPublicKey)), 0);
                else if (object.senderPublicKey.length)
                    message.senderPublicKey = object.senderPublicKey;
            if (object.assetId != null)
                if (typeof object.assetId === "string")
                    $util.base64.decode(object.assetId, message.assetId = $util.newBuffer($util.base64.length(object.assetId)), 0);
                else if (object.assetId.length)
                    message.assetId = object.assetId;
            if (object.isEnabled != null)
                message.isEnabled = Boolean(object.isEnabled);
            if (object.fee != null)
                if ($util.Long)
                    (message.fee = $util.Long.fromValue(object.fee)).unsigned = false;
                else if (typeof object.fee === "string")
                    message.fee = parseInt(object.fee, 10);
                else if (typeof object.fee === "number")
                    message.fee = object.fee;
                else if (typeof object.fee === "object")
                    message.fee = new $util.LongBits(object.fee.low >>> 0, object.fee.high >>> 0).toNumber();
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            if (object.proofs) {
                if (!Array.isArray(object.proofs))
                    throw TypeError(".wavesenterprise.SponsorFeeTransaction.proofs: array expected");
                message.proofs = [];
                for (var i = 0; i < object.proofs.length; ++i)
                    if (typeof object.proofs[i] === "string")
                        $util.base64.decode(object.proofs[i], message.proofs[i] = $util.newBuffer($util.base64.length(object.proofs[i])), 0);
                    else if (object.proofs[i].length)
                        message.proofs[i] = object.proofs[i];
            }
            return message;
        };

        /**
         * Creates a plain object from a SponsorFeeTransaction message. Also converts values to other types if specified.
         * @function toObject
         * @memberof wavesenterprise.SponsorFeeTransaction
         * @static
         * @param {wavesenterprise.SponsorFeeTransaction} message SponsorFeeTransaction
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SponsorFeeTransaction.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.proofs = [];
            if (options.defaults) {
                if (options.bytes === String)
                    object.id = "";
                else {
                    object.id = [];
                    if (options.bytes !== Array)
                        object.id = $util.newBuffer(object.id);
                }
                if (options.bytes === String)
                    object.senderPublicKey = "";
                else {
                    object.senderPublicKey = [];
                    if (options.bytes !== Array)
                        object.senderPublicKey = $util.newBuffer(object.senderPublicKey);
                }
                if (options.bytes === String)
                    object.assetId = "";
                else {
                    object.assetId = [];
                    if (options.bytes !== Array)
                        object.assetId = $util.newBuffer(object.assetId);
                }
                object.isEnabled = false;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.fee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.fee = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = options.bytes === String ? $util.base64.encode(message.id, 0, message.id.length) : options.bytes === Array ? Array.prototype.slice.call(message.id) : message.id;
            if (message.senderPublicKey != null && message.hasOwnProperty("senderPublicKey"))
                object.senderPublicKey = options.bytes === String ? $util.base64.encode(message.senderPublicKey, 0, message.senderPublicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.senderPublicKey) : message.senderPublicKey;
            if (message.assetId != null && message.hasOwnProperty("assetId"))
                object.assetId = options.bytes === String ? $util.base64.encode(message.assetId, 0, message.assetId.length) : options.bytes === Array ? Array.prototype.slice.call(message.assetId) : message.assetId;
            if (message.isEnabled != null && message.hasOwnProperty("isEnabled"))
                object.isEnabled = message.isEnabled;
            if (message.fee != null && message.hasOwnProperty("fee"))
                if (typeof message.fee === "number")
                    object.fee = options.longs === String ? String(message.fee) : message.fee;
                else
                    object.fee = options.longs === String ? $util.Long.prototype.toString.call(message.fee) : options.longs === Number ? new $util.LongBits(message.fee.low >>> 0, message.fee.high >>> 0).toNumber() : message.fee;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            if (message.proofs && message.proofs.length) {
                object.proofs = [];
                for (var j = 0; j < message.proofs.length; ++j)
                    object.proofs[j] = options.bytes === String ? $util.base64.encode(message.proofs[j], 0, message.proofs[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.proofs[j]) : message.proofs[j];
            }
            return object;
        };

        /**
         * Converts this SponsorFeeTransaction to JSON.
         * @function toJSON
         * @memberof wavesenterprise.SponsorFeeTransaction
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SponsorFeeTransaction.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SponsorFeeTransaction;
    })();

    wavesenterprise.SetAssetScriptTransaction = (function() {

        /**
         * Properties of a SetAssetScriptTransaction.
         * @memberof wavesenterprise
         * @interface ISetAssetScriptTransaction
         * @property {Uint8Array|null} [id] SetAssetScriptTransaction id
         * @property {number|null} [chainId] SetAssetScriptTransaction chainId
         * @property {Uint8Array|null} [senderPublicKey] SetAssetScriptTransaction senderPublicKey
         * @property {Uint8Array|null} [assetId] SetAssetScriptTransaction assetId
         * @property {google.protobuf.IBytesValue|null} [script] SetAssetScriptTransaction script
         * @property {number|Long|null} [fee] SetAssetScriptTransaction fee
         * @property {number|Long|null} [timestamp] SetAssetScriptTransaction timestamp
         * @property {Array.<Uint8Array>|null} [proofs] SetAssetScriptTransaction proofs
         */

        /**
         * Constructs a new SetAssetScriptTransaction.
         * @memberof wavesenterprise
         * @classdesc Represents a SetAssetScriptTransaction.
         * @implements ISetAssetScriptTransaction
         * @constructor
         * @param {wavesenterprise.ISetAssetScriptTransaction=} [properties] Properties to set
         */
        function SetAssetScriptTransaction(properties) {
            this.proofs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SetAssetScriptTransaction id.
         * @member {Uint8Array} id
         * @memberof wavesenterprise.SetAssetScriptTransaction
         * @instance
         */
        SetAssetScriptTransaction.prototype.id = $util.newBuffer([]);

        /**
         * SetAssetScriptTransaction chainId.
         * @member {number} chainId
         * @memberof wavesenterprise.SetAssetScriptTransaction
         * @instance
         */
        SetAssetScriptTransaction.prototype.chainId = 0;

        /**
         * SetAssetScriptTransaction senderPublicKey.
         * @member {Uint8Array} senderPublicKey
         * @memberof wavesenterprise.SetAssetScriptTransaction
         * @instance
         */
        SetAssetScriptTransaction.prototype.senderPublicKey = $util.newBuffer([]);

        /**
         * SetAssetScriptTransaction assetId.
         * @member {Uint8Array} assetId
         * @memberof wavesenterprise.SetAssetScriptTransaction
         * @instance
         */
        SetAssetScriptTransaction.prototype.assetId = $util.newBuffer([]);

        /**
         * SetAssetScriptTransaction script.
         * @member {google.protobuf.IBytesValue|null|undefined} script
         * @memberof wavesenterprise.SetAssetScriptTransaction
         * @instance
         */
        SetAssetScriptTransaction.prototype.script = null;

        /**
         * SetAssetScriptTransaction fee.
         * @member {number|Long} fee
         * @memberof wavesenterprise.SetAssetScriptTransaction
         * @instance
         */
        SetAssetScriptTransaction.prototype.fee = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SetAssetScriptTransaction timestamp.
         * @member {number|Long} timestamp
         * @memberof wavesenterprise.SetAssetScriptTransaction
         * @instance
         */
        SetAssetScriptTransaction.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SetAssetScriptTransaction proofs.
         * @member {Array.<Uint8Array>} proofs
         * @memberof wavesenterprise.SetAssetScriptTransaction
         * @instance
         */
        SetAssetScriptTransaction.prototype.proofs = $util.emptyArray;

        /**
         * Creates a new SetAssetScriptTransaction instance using the specified properties.
         * @function create
         * @memberof wavesenterprise.SetAssetScriptTransaction
         * @static
         * @param {wavesenterprise.ISetAssetScriptTransaction=} [properties] Properties to set
         * @returns {wavesenterprise.SetAssetScriptTransaction} SetAssetScriptTransaction instance
         */
        SetAssetScriptTransaction.create = function create(properties) {
            return new SetAssetScriptTransaction(properties);
        };

        /**
         * Encodes the specified SetAssetScriptTransaction message. Does not implicitly {@link wavesenterprise.SetAssetScriptTransaction.verify|verify} messages.
         * @function encode
         * @memberof wavesenterprise.SetAssetScriptTransaction
         * @static
         * @param {wavesenterprise.ISetAssetScriptTransaction} message SetAssetScriptTransaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetAssetScriptTransaction.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.id);
            if (message.chainId != null && Object.hasOwnProperty.call(message, "chainId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.chainId);
            if (message.senderPublicKey != null && Object.hasOwnProperty.call(message, "senderPublicKey"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.senderPublicKey);
            if (message.assetId != null && Object.hasOwnProperty.call(message, "assetId"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.assetId);
            if (message.script != null && Object.hasOwnProperty.call(message, "script"))
                $root.google.protobuf.BytesValue.encode(message.script, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.fee != null && Object.hasOwnProperty.call(message, "fee"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.fee);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.timestamp);
            if (message.proofs != null && message.proofs.length)
                for (var i = 0; i < message.proofs.length; ++i)
                    writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.proofs[i]);
            return writer;
        };

        /**
         * Encodes the specified SetAssetScriptTransaction message, length delimited. Does not implicitly {@link wavesenterprise.SetAssetScriptTransaction.verify|verify} messages.
         * @function encodeDelimited
         * @memberof wavesenterprise.SetAssetScriptTransaction
         * @static
         * @param {wavesenterprise.ISetAssetScriptTransaction} message SetAssetScriptTransaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetAssetScriptTransaction.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SetAssetScriptTransaction message from the specified reader or buffer.
         * @function decode
         * @memberof wavesenterprise.SetAssetScriptTransaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {wavesenterprise.SetAssetScriptTransaction} SetAssetScriptTransaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetAssetScriptTransaction.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.wavesenterprise.SetAssetScriptTransaction();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.bytes();
                    break;
                case 2:
                    message.chainId = reader.int32();
                    break;
                case 3:
                    message.senderPublicKey = reader.bytes();
                    break;
                case 4:
                    message.assetId = reader.bytes();
                    break;
                case 5:
                    message.script = $root.google.protobuf.BytesValue.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.fee = reader.int64();
                    break;
                case 7:
                    message.timestamp = reader.int64();
                    break;
                case 8:
                    if (!(message.proofs && message.proofs.length))
                        message.proofs = [];
                    message.proofs.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SetAssetScriptTransaction message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof wavesenterprise.SetAssetScriptTransaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {wavesenterprise.SetAssetScriptTransaction} SetAssetScriptTransaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetAssetScriptTransaction.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SetAssetScriptTransaction message.
         * @function verify
         * @memberof wavesenterprise.SetAssetScriptTransaction
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SetAssetScriptTransaction.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!(message.id && typeof message.id.length === "number" || $util.isString(message.id)))
                    return "id: buffer expected";
            if (message.chainId != null && message.hasOwnProperty("chainId"))
                if (!$util.isInteger(message.chainId))
                    return "chainId: integer expected";
            if (message.senderPublicKey != null && message.hasOwnProperty("senderPublicKey"))
                if (!(message.senderPublicKey && typeof message.senderPublicKey.length === "number" || $util.isString(message.senderPublicKey)))
                    return "senderPublicKey: buffer expected";
            if (message.assetId != null && message.hasOwnProperty("assetId"))
                if (!(message.assetId && typeof message.assetId.length === "number" || $util.isString(message.assetId)))
                    return "assetId: buffer expected";
            if (message.script != null && message.hasOwnProperty("script")) {
                var error = $root.google.protobuf.BytesValue.verify(message.script);
                if (error)
                    return "script." + error;
            }
            if (message.fee != null && message.hasOwnProperty("fee"))
                if (!$util.isInteger(message.fee) && !(message.fee && $util.isInteger(message.fee.low) && $util.isInteger(message.fee.high)))
                    return "fee: integer|Long expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            if (message.proofs != null && message.hasOwnProperty("proofs")) {
                if (!Array.isArray(message.proofs))
                    return "proofs: array expected";
                for (var i = 0; i < message.proofs.length; ++i)
                    if (!(message.proofs[i] && typeof message.proofs[i].length === "number" || $util.isString(message.proofs[i])))
                        return "proofs: buffer[] expected";
            }
            return null;
        };

        /**
         * Creates a SetAssetScriptTransaction message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof wavesenterprise.SetAssetScriptTransaction
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {wavesenterprise.SetAssetScriptTransaction} SetAssetScriptTransaction
         */
        SetAssetScriptTransaction.fromObject = function fromObject(object) {
            if (object instanceof $root.wavesenterprise.SetAssetScriptTransaction)
                return object;
            var message = new $root.wavesenterprise.SetAssetScriptTransaction();
            if (object.id != null)
                if (typeof object.id === "string")
                    $util.base64.decode(object.id, message.id = $util.newBuffer($util.base64.length(object.id)), 0);
                else if (object.id.length)
                    message.id = object.id;
            if (object.chainId != null)
                message.chainId = object.chainId | 0;
            if (object.senderPublicKey != null)
                if (typeof object.senderPublicKey === "string")
                    $util.base64.decode(object.senderPublicKey, message.senderPublicKey = $util.newBuffer($util.base64.length(object.senderPublicKey)), 0);
                else if (object.senderPublicKey.length)
                    message.senderPublicKey = object.senderPublicKey;
            if (object.assetId != null)
                if (typeof object.assetId === "string")
                    $util.base64.decode(object.assetId, message.assetId = $util.newBuffer($util.base64.length(object.assetId)), 0);
                else if (object.assetId.length)
                    message.assetId = object.assetId;
            if (object.script != null) {
                if (typeof object.script !== "object")
                    throw TypeError(".wavesenterprise.SetAssetScriptTransaction.script: object expected");
                message.script = $root.google.protobuf.BytesValue.fromObject(object.script);
            }
            if (object.fee != null)
                if ($util.Long)
                    (message.fee = $util.Long.fromValue(object.fee)).unsigned = false;
                else if (typeof object.fee === "string")
                    message.fee = parseInt(object.fee, 10);
                else if (typeof object.fee === "number")
                    message.fee = object.fee;
                else if (typeof object.fee === "object")
                    message.fee = new $util.LongBits(object.fee.low >>> 0, object.fee.high >>> 0).toNumber();
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            if (object.proofs) {
                if (!Array.isArray(object.proofs))
                    throw TypeError(".wavesenterprise.SetAssetScriptTransaction.proofs: array expected");
                message.proofs = [];
                for (var i = 0; i < object.proofs.length; ++i)
                    if (typeof object.proofs[i] === "string")
                        $util.base64.decode(object.proofs[i], message.proofs[i] = $util.newBuffer($util.base64.length(object.proofs[i])), 0);
                    else if (object.proofs[i].length)
                        message.proofs[i] = object.proofs[i];
            }
            return message;
        };

        /**
         * Creates a plain object from a SetAssetScriptTransaction message. Also converts values to other types if specified.
         * @function toObject
         * @memberof wavesenterprise.SetAssetScriptTransaction
         * @static
         * @param {wavesenterprise.SetAssetScriptTransaction} message SetAssetScriptTransaction
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SetAssetScriptTransaction.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.proofs = [];
            if (options.defaults) {
                if (options.bytes === String)
                    object.id = "";
                else {
                    object.id = [];
                    if (options.bytes !== Array)
                        object.id = $util.newBuffer(object.id);
                }
                object.chainId = 0;
                if (options.bytes === String)
                    object.senderPublicKey = "";
                else {
                    object.senderPublicKey = [];
                    if (options.bytes !== Array)
                        object.senderPublicKey = $util.newBuffer(object.senderPublicKey);
                }
                if (options.bytes === String)
                    object.assetId = "";
                else {
                    object.assetId = [];
                    if (options.bytes !== Array)
                        object.assetId = $util.newBuffer(object.assetId);
                }
                object.script = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.fee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.fee = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = options.bytes === String ? $util.base64.encode(message.id, 0, message.id.length) : options.bytes === Array ? Array.prototype.slice.call(message.id) : message.id;
            if (message.chainId != null && message.hasOwnProperty("chainId"))
                object.chainId = message.chainId;
            if (message.senderPublicKey != null && message.hasOwnProperty("senderPublicKey"))
                object.senderPublicKey = options.bytes === String ? $util.base64.encode(message.senderPublicKey, 0, message.senderPublicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.senderPublicKey) : message.senderPublicKey;
            if (message.assetId != null && message.hasOwnProperty("assetId"))
                object.assetId = options.bytes === String ? $util.base64.encode(message.assetId, 0, message.assetId.length) : options.bytes === Array ? Array.prototype.slice.call(message.assetId) : message.assetId;
            if (message.script != null && message.hasOwnProperty("script"))
                object.script = $root.google.protobuf.BytesValue.toObject(message.script, options);
            if (message.fee != null && message.hasOwnProperty("fee"))
                if (typeof message.fee === "number")
                    object.fee = options.longs === String ? String(message.fee) : message.fee;
                else
                    object.fee = options.longs === String ? $util.Long.prototype.toString.call(message.fee) : options.longs === Number ? new $util.LongBits(message.fee.low >>> 0, message.fee.high >>> 0).toNumber() : message.fee;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            if (message.proofs && message.proofs.length) {
                object.proofs = [];
                for (var j = 0; j < message.proofs.length; ++j)
                    object.proofs[j] = options.bytes === String ? $util.base64.encode(message.proofs[j], 0, message.proofs[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.proofs[j]) : message.proofs[j];
            }
            return object;
        };

        /**
         * Converts this SetAssetScriptTransaction to JSON.
         * @function toJSON
         * @memberof wavesenterprise.SetAssetScriptTransaction
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SetAssetScriptTransaction.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SetAssetScriptTransaction;
    })();

    wavesenterprise.DataTransaction = (function() {

        /**
         * Properties of a DataTransaction.
         * @memberof wavesenterprise
         * @interface IDataTransaction
         * @property {Uint8Array|null} [id] DataTransaction id
         * @property {Uint8Array|null} [senderPublicKey] DataTransaction senderPublicKey
         * @property {Uint8Array|null} [authorPublicKey] DataTransaction authorPublicKey
         * @property {Array.<wavesenterprise.IDataEntry>|null} [data] DataTransaction data
         * @property {number|Long|null} [timestamp] DataTransaction timestamp
         * @property {number|Long|null} [fee] DataTransaction fee
         * @property {google.protobuf.IBytesValue|null} [feeAssetId] DataTransaction feeAssetId
         * @property {Array.<Uint8Array>|null} [proofs] DataTransaction proofs
         */

        /**
         * Constructs a new DataTransaction.
         * @memberof wavesenterprise
         * @classdesc Represents a DataTransaction.
         * @implements IDataTransaction
         * @constructor
         * @param {wavesenterprise.IDataTransaction=} [properties] Properties to set
         */
        function DataTransaction(properties) {
            this.data = [];
            this.proofs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DataTransaction id.
         * @member {Uint8Array} id
         * @memberof wavesenterprise.DataTransaction
         * @instance
         */
        DataTransaction.prototype.id = $util.newBuffer([]);

        /**
         * DataTransaction senderPublicKey.
         * @member {Uint8Array} senderPublicKey
         * @memberof wavesenterprise.DataTransaction
         * @instance
         */
        DataTransaction.prototype.senderPublicKey = $util.newBuffer([]);

        /**
         * DataTransaction authorPublicKey.
         * @member {Uint8Array} authorPublicKey
         * @memberof wavesenterprise.DataTransaction
         * @instance
         */
        DataTransaction.prototype.authorPublicKey = $util.newBuffer([]);

        /**
         * DataTransaction data.
         * @member {Array.<wavesenterprise.IDataEntry>} data
         * @memberof wavesenterprise.DataTransaction
         * @instance
         */
        DataTransaction.prototype.data = $util.emptyArray;

        /**
         * DataTransaction timestamp.
         * @member {number|Long} timestamp
         * @memberof wavesenterprise.DataTransaction
         * @instance
         */
        DataTransaction.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * DataTransaction fee.
         * @member {number|Long} fee
         * @memberof wavesenterprise.DataTransaction
         * @instance
         */
        DataTransaction.prototype.fee = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * DataTransaction feeAssetId.
         * @member {google.protobuf.IBytesValue|null|undefined} feeAssetId
         * @memberof wavesenterprise.DataTransaction
         * @instance
         */
        DataTransaction.prototype.feeAssetId = null;

        /**
         * DataTransaction proofs.
         * @member {Array.<Uint8Array>} proofs
         * @memberof wavesenterprise.DataTransaction
         * @instance
         */
        DataTransaction.prototype.proofs = $util.emptyArray;

        /**
         * Creates a new DataTransaction instance using the specified properties.
         * @function create
         * @memberof wavesenterprise.DataTransaction
         * @static
         * @param {wavesenterprise.IDataTransaction=} [properties] Properties to set
         * @returns {wavesenterprise.DataTransaction} DataTransaction instance
         */
        DataTransaction.create = function create(properties) {
            return new DataTransaction(properties);
        };

        /**
         * Encodes the specified DataTransaction message. Does not implicitly {@link wavesenterprise.DataTransaction.verify|verify} messages.
         * @function encode
         * @memberof wavesenterprise.DataTransaction
         * @static
         * @param {wavesenterprise.IDataTransaction} message DataTransaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DataTransaction.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.id);
            if (message.senderPublicKey != null && Object.hasOwnProperty.call(message, "senderPublicKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.senderPublicKey);
            if (message.authorPublicKey != null && Object.hasOwnProperty.call(message, "authorPublicKey"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.authorPublicKey);
            if (message.data != null && message.data.length)
                for (var i = 0; i < message.data.length; ++i)
                    $root.wavesenterprise.DataEntry.encode(message.data[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.timestamp);
            if (message.fee != null && Object.hasOwnProperty.call(message, "fee"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.fee);
            if (message.feeAssetId != null && Object.hasOwnProperty.call(message, "feeAssetId"))
                $root.google.protobuf.BytesValue.encode(message.feeAssetId, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.proofs != null && message.proofs.length)
                for (var i = 0; i < message.proofs.length; ++i)
                    writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.proofs[i]);
            return writer;
        };

        /**
         * Encodes the specified DataTransaction message, length delimited. Does not implicitly {@link wavesenterprise.DataTransaction.verify|verify} messages.
         * @function encodeDelimited
         * @memberof wavesenterprise.DataTransaction
         * @static
         * @param {wavesenterprise.IDataTransaction} message DataTransaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DataTransaction.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DataTransaction message from the specified reader or buffer.
         * @function decode
         * @memberof wavesenterprise.DataTransaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {wavesenterprise.DataTransaction} DataTransaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DataTransaction.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.wavesenterprise.DataTransaction();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.bytes();
                    break;
                case 2:
                    message.senderPublicKey = reader.bytes();
                    break;
                case 3:
                    message.authorPublicKey = reader.bytes();
                    break;
                case 4:
                    if (!(message.data && message.data.length))
                        message.data = [];
                    message.data.push($root.wavesenterprise.DataEntry.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.timestamp = reader.int64();
                    break;
                case 6:
                    message.fee = reader.int64();
                    break;
                case 7:
                    message.feeAssetId = $root.google.protobuf.BytesValue.decode(reader, reader.uint32());
                    break;
                case 8:
                    if (!(message.proofs && message.proofs.length))
                        message.proofs = [];
                    message.proofs.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DataTransaction message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof wavesenterprise.DataTransaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {wavesenterprise.DataTransaction} DataTransaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DataTransaction.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DataTransaction message.
         * @function verify
         * @memberof wavesenterprise.DataTransaction
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DataTransaction.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!(message.id && typeof message.id.length === "number" || $util.isString(message.id)))
                    return "id: buffer expected";
            if (message.senderPublicKey != null && message.hasOwnProperty("senderPublicKey"))
                if (!(message.senderPublicKey && typeof message.senderPublicKey.length === "number" || $util.isString(message.senderPublicKey)))
                    return "senderPublicKey: buffer expected";
            if (message.authorPublicKey != null && message.hasOwnProperty("authorPublicKey"))
                if (!(message.authorPublicKey && typeof message.authorPublicKey.length === "number" || $util.isString(message.authorPublicKey)))
                    return "authorPublicKey: buffer expected";
            if (message.data != null && message.hasOwnProperty("data")) {
                if (!Array.isArray(message.data))
                    return "data: array expected";
                for (var i = 0; i < message.data.length; ++i) {
                    var error = $root.wavesenterprise.DataEntry.verify(message.data[i]);
                    if (error)
                        return "data." + error;
                }
            }
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            if (message.fee != null && message.hasOwnProperty("fee"))
                if (!$util.isInteger(message.fee) && !(message.fee && $util.isInteger(message.fee.low) && $util.isInteger(message.fee.high)))
                    return "fee: integer|Long expected";
            if (message.feeAssetId != null && message.hasOwnProperty("feeAssetId")) {
                var error = $root.google.protobuf.BytesValue.verify(message.feeAssetId);
                if (error)
                    return "feeAssetId." + error;
            }
            if (message.proofs != null && message.hasOwnProperty("proofs")) {
                if (!Array.isArray(message.proofs))
                    return "proofs: array expected";
                for (var i = 0; i < message.proofs.length; ++i)
                    if (!(message.proofs[i] && typeof message.proofs[i].length === "number" || $util.isString(message.proofs[i])))
                        return "proofs: buffer[] expected";
            }
            return null;
        };

        /**
         * Creates a DataTransaction message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof wavesenterprise.DataTransaction
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {wavesenterprise.DataTransaction} DataTransaction
         */
        DataTransaction.fromObject = function fromObject(object) {
            if (object instanceof $root.wavesenterprise.DataTransaction)
                return object;
            var message = new $root.wavesenterprise.DataTransaction();
            if (object.id != null)
                if (typeof object.id === "string")
                    $util.base64.decode(object.id, message.id = $util.newBuffer($util.base64.length(object.id)), 0);
                else if (object.id.length)
                    message.id = object.id;
            if (object.senderPublicKey != null)
                if (typeof object.senderPublicKey === "string")
                    $util.base64.decode(object.senderPublicKey, message.senderPublicKey = $util.newBuffer($util.base64.length(object.senderPublicKey)), 0);
                else if (object.senderPublicKey.length)
                    message.senderPublicKey = object.senderPublicKey;
            if (object.authorPublicKey != null)
                if (typeof object.authorPublicKey === "string")
                    $util.base64.decode(object.authorPublicKey, message.authorPublicKey = $util.newBuffer($util.base64.length(object.authorPublicKey)), 0);
                else if (object.authorPublicKey.length)
                    message.authorPublicKey = object.authorPublicKey;
            if (object.data) {
                if (!Array.isArray(object.data))
                    throw TypeError(".wavesenterprise.DataTransaction.data: array expected");
                message.data = [];
                for (var i = 0; i < object.data.length; ++i) {
                    if (typeof object.data[i] !== "object")
                        throw TypeError(".wavesenterprise.DataTransaction.data: object expected");
                    message.data[i] = $root.wavesenterprise.DataEntry.fromObject(object.data[i]);
                }
            }
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            if (object.fee != null)
                if ($util.Long)
                    (message.fee = $util.Long.fromValue(object.fee)).unsigned = false;
                else if (typeof object.fee === "string")
                    message.fee = parseInt(object.fee, 10);
                else if (typeof object.fee === "number")
                    message.fee = object.fee;
                else if (typeof object.fee === "object")
                    message.fee = new $util.LongBits(object.fee.low >>> 0, object.fee.high >>> 0).toNumber();
            if (object.feeAssetId != null) {
                if (typeof object.feeAssetId !== "object")
                    throw TypeError(".wavesenterprise.DataTransaction.feeAssetId: object expected");
                message.feeAssetId = $root.google.protobuf.BytesValue.fromObject(object.feeAssetId);
            }
            if (object.proofs) {
                if (!Array.isArray(object.proofs))
                    throw TypeError(".wavesenterprise.DataTransaction.proofs: array expected");
                message.proofs = [];
                for (var i = 0; i < object.proofs.length; ++i)
                    if (typeof object.proofs[i] === "string")
                        $util.base64.decode(object.proofs[i], message.proofs[i] = $util.newBuffer($util.base64.length(object.proofs[i])), 0);
                    else if (object.proofs[i].length)
                        message.proofs[i] = object.proofs[i];
            }
            return message;
        };

        /**
         * Creates a plain object from a DataTransaction message. Also converts values to other types if specified.
         * @function toObject
         * @memberof wavesenterprise.DataTransaction
         * @static
         * @param {wavesenterprise.DataTransaction} message DataTransaction
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DataTransaction.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.data = [];
                object.proofs = [];
            }
            if (options.defaults) {
                if (options.bytes === String)
                    object.id = "";
                else {
                    object.id = [];
                    if (options.bytes !== Array)
                        object.id = $util.newBuffer(object.id);
                }
                if (options.bytes === String)
                    object.senderPublicKey = "";
                else {
                    object.senderPublicKey = [];
                    if (options.bytes !== Array)
                        object.senderPublicKey = $util.newBuffer(object.senderPublicKey);
                }
                if (options.bytes === String)
                    object.authorPublicKey = "";
                else {
                    object.authorPublicKey = [];
                    if (options.bytes !== Array)
                        object.authorPublicKey = $util.newBuffer(object.authorPublicKey);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.fee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.fee = options.longs === String ? "0" : 0;
                object.feeAssetId = null;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = options.bytes === String ? $util.base64.encode(message.id, 0, message.id.length) : options.bytes === Array ? Array.prototype.slice.call(message.id) : message.id;
            if (message.senderPublicKey != null && message.hasOwnProperty("senderPublicKey"))
                object.senderPublicKey = options.bytes === String ? $util.base64.encode(message.senderPublicKey, 0, message.senderPublicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.senderPublicKey) : message.senderPublicKey;
            if (message.authorPublicKey != null && message.hasOwnProperty("authorPublicKey"))
                object.authorPublicKey = options.bytes === String ? $util.base64.encode(message.authorPublicKey, 0, message.authorPublicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.authorPublicKey) : message.authorPublicKey;
            if (message.data && message.data.length) {
                object.data = [];
                for (var j = 0; j < message.data.length; ++j)
                    object.data[j] = $root.wavesenterprise.DataEntry.toObject(message.data[j], options);
            }
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            if (message.fee != null && message.hasOwnProperty("fee"))
                if (typeof message.fee === "number")
                    object.fee = options.longs === String ? String(message.fee) : message.fee;
                else
                    object.fee = options.longs === String ? $util.Long.prototype.toString.call(message.fee) : options.longs === Number ? new $util.LongBits(message.fee.low >>> 0, message.fee.high >>> 0).toNumber() : message.fee;
            if (message.feeAssetId != null && message.hasOwnProperty("feeAssetId"))
                object.feeAssetId = $root.google.protobuf.BytesValue.toObject(message.feeAssetId, options);
            if (message.proofs && message.proofs.length) {
                object.proofs = [];
                for (var j = 0; j < message.proofs.length; ++j)
                    object.proofs[j] = options.bytes === String ? $util.base64.encode(message.proofs[j], 0, message.proofs[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.proofs[j]) : message.proofs[j];
            }
            return object;
        };

        /**
         * Converts this DataTransaction to JSON.
         * @function toJSON
         * @memberof wavesenterprise.DataTransaction
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DataTransaction.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DataTransaction;
    })();

    wavesenterprise.DataEntry = (function() {

        /**
         * Properties of a DataEntry.
         * @memberof wavesenterprise
         * @interface IDataEntry
         * @property {string|null} [key] DataEntry key
         * @property {number|Long|null} [intValue] DataEntry intValue
         * @property {boolean|null} [boolValue] DataEntry boolValue
         * @property {Uint8Array|null} [binaryValue] DataEntry binaryValue
         * @property {string|null} [stringValue] DataEntry stringValue
         */

        /**
         * Constructs a new DataEntry.
         * @memberof wavesenterprise
         * @classdesc Represents a DataEntry.
         * @implements IDataEntry
         * @constructor
         * @param {wavesenterprise.IDataEntry=} [properties] Properties to set
         */
        function DataEntry(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DataEntry key.
         * @member {string} key
         * @memberof wavesenterprise.DataEntry
         * @instance
         */
        DataEntry.prototype.key = "";

        /**
         * DataEntry intValue.
         * @member {number|Long|null|undefined} intValue
         * @memberof wavesenterprise.DataEntry
         * @instance
         */
        DataEntry.prototype.intValue = null;

        /**
         * DataEntry boolValue.
         * @member {boolean|null|undefined} boolValue
         * @memberof wavesenterprise.DataEntry
         * @instance
         */
        DataEntry.prototype.boolValue = null;

        /**
         * DataEntry binaryValue.
         * @member {Uint8Array|null|undefined} binaryValue
         * @memberof wavesenterprise.DataEntry
         * @instance
         */
        DataEntry.prototype.binaryValue = null;

        /**
         * DataEntry stringValue.
         * @member {string|null|undefined} stringValue
         * @memberof wavesenterprise.DataEntry
         * @instance
         */
        DataEntry.prototype.stringValue = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * DataEntry value.
         * @member {"intValue"|"boolValue"|"binaryValue"|"stringValue"|undefined} value
         * @memberof wavesenterprise.DataEntry
         * @instance
         */
        Object.defineProperty(DataEntry.prototype, "value", {
            get: $util.oneOfGetter($oneOfFields = ["intValue", "boolValue", "binaryValue", "stringValue"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new DataEntry instance using the specified properties.
         * @function create
         * @memberof wavesenterprise.DataEntry
         * @static
         * @param {wavesenterprise.IDataEntry=} [properties] Properties to set
         * @returns {wavesenterprise.DataEntry} DataEntry instance
         */
        DataEntry.create = function create(properties) {
            return new DataEntry(properties);
        };

        /**
         * Encodes the specified DataEntry message. Does not implicitly {@link wavesenterprise.DataEntry.verify|verify} messages.
         * @function encode
         * @memberof wavesenterprise.DataEntry
         * @static
         * @param {wavesenterprise.IDataEntry} message DataEntry message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DataEntry.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.key);
            if (message.intValue != null && Object.hasOwnProperty.call(message, "intValue"))
                writer.uint32(/* id 10, wireType 0 =*/80).int64(message.intValue);
            if (message.boolValue != null && Object.hasOwnProperty.call(message, "boolValue"))
                writer.uint32(/* id 11, wireType 0 =*/88).bool(message.boolValue);
            if (message.binaryValue != null && Object.hasOwnProperty.call(message, "binaryValue"))
                writer.uint32(/* id 12, wireType 2 =*/98).bytes(message.binaryValue);
            if (message.stringValue != null && Object.hasOwnProperty.call(message, "stringValue"))
                writer.uint32(/* id 13, wireType 2 =*/106).string(message.stringValue);
            return writer;
        };

        /**
         * Encodes the specified DataEntry message, length delimited. Does not implicitly {@link wavesenterprise.DataEntry.verify|verify} messages.
         * @function encodeDelimited
         * @memberof wavesenterprise.DataEntry
         * @static
         * @param {wavesenterprise.IDataEntry} message DataEntry message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DataEntry.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DataEntry message from the specified reader or buffer.
         * @function decode
         * @memberof wavesenterprise.DataEntry
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {wavesenterprise.DataEntry} DataEntry
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DataEntry.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.wavesenterprise.DataEntry();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 10:
                    message.intValue = reader.int64();
                    break;
                case 11:
                    message.boolValue = reader.bool();
                    break;
                case 12:
                    message.binaryValue = reader.bytes();
                    break;
                case 13:
                    message.stringValue = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DataEntry message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof wavesenterprise.DataEntry
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {wavesenterprise.DataEntry} DataEntry
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DataEntry.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DataEntry message.
         * @function verify
         * @memberof wavesenterprise.DataEntry
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DataEntry.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.key != null && message.hasOwnProperty("key"))
                if (!$util.isString(message.key))
                    return "key: string expected";
            if (message.intValue != null && message.hasOwnProperty("intValue")) {
                properties.value = 1;
                if (!$util.isInteger(message.intValue) && !(message.intValue && $util.isInteger(message.intValue.low) && $util.isInteger(message.intValue.high)))
                    return "intValue: integer|Long expected";
            }
            if (message.boolValue != null && message.hasOwnProperty("boolValue")) {
                if (properties.value === 1)
                    return "value: multiple values";
                properties.value = 1;
                if (typeof message.boolValue !== "boolean")
                    return "boolValue: boolean expected";
            }
            if (message.binaryValue != null && message.hasOwnProperty("binaryValue")) {
                if (properties.value === 1)
                    return "value: multiple values";
                properties.value = 1;
                if (!(message.binaryValue && typeof message.binaryValue.length === "number" || $util.isString(message.binaryValue)))
                    return "binaryValue: buffer expected";
            }
            if (message.stringValue != null && message.hasOwnProperty("stringValue")) {
                if (properties.value === 1)
                    return "value: multiple values";
                properties.value = 1;
                if (!$util.isString(message.stringValue))
                    return "stringValue: string expected";
            }
            return null;
        };

        /**
         * Creates a DataEntry message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof wavesenterprise.DataEntry
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {wavesenterprise.DataEntry} DataEntry
         */
        DataEntry.fromObject = function fromObject(object) {
            if (object instanceof $root.wavesenterprise.DataEntry)
                return object;
            var message = new $root.wavesenterprise.DataEntry();
            if (object.key != null)
                message.key = String(object.key);
            if (object.intValue != null)
                if ($util.Long)
                    (message.intValue = $util.Long.fromValue(object.intValue)).unsigned = false;
                else if (typeof object.intValue === "string")
                    message.intValue = parseInt(object.intValue, 10);
                else if (typeof object.intValue === "number")
                    message.intValue = object.intValue;
                else if (typeof object.intValue === "object")
                    message.intValue = new $util.LongBits(object.intValue.low >>> 0, object.intValue.high >>> 0).toNumber();
            if (object.boolValue != null)
                message.boolValue = Boolean(object.boolValue);
            if (object.binaryValue != null)
                if (typeof object.binaryValue === "string")
                    $util.base64.decode(object.binaryValue, message.binaryValue = $util.newBuffer($util.base64.length(object.binaryValue)), 0);
                else if (object.binaryValue.length)
                    message.binaryValue = object.binaryValue;
            if (object.stringValue != null)
                message.stringValue = String(object.stringValue);
            return message;
        };

        /**
         * Creates a plain object from a DataEntry message. Also converts values to other types if specified.
         * @function toObject
         * @memberof wavesenterprise.DataEntry
         * @static
         * @param {wavesenterprise.DataEntry} message DataEntry
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DataEntry.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.key = "";
            if (message.key != null && message.hasOwnProperty("key"))
                object.key = message.key;
            if (message.intValue != null && message.hasOwnProperty("intValue")) {
                if (typeof message.intValue === "number")
                    object.intValue = options.longs === String ? String(message.intValue) : message.intValue;
                else
                    object.intValue = options.longs === String ? $util.Long.prototype.toString.call(message.intValue) : options.longs === Number ? new $util.LongBits(message.intValue.low >>> 0, message.intValue.high >>> 0).toNumber() : message.intValue;
                if (options.oneofs)
                    object.value = "intValue";
            }
            if (message.boolValue != null && message.hasOwnProperty("boolValue")) {
                object.boolValue = message.boolValue;
                if (options.oneofs)
                    object.value = "boolValue";
            }
            if (message.binaryValue != null && message.hasOwnProperty("binaryValue")) {
                object.binaryValue = options.bytes === String ? $util.base64.encode(message.binaryValue, 0, message.binaryValue.length) : options.bytes === Array ? Array.prototype.slice.call(message.binaryValue) : message.binaryValue;
                if (options.oneofs)
                    object.value = "binaryValue";
            }
            if (message.stringValue != null && message.hasOwnProperty("stringValue")) {
                object.stringValue = message.stringValue;
                if (options.oneofs)
                    object.value = "stringValue";
            }
            return object;
        };

        /**
         * Converts this DataEntry to JSON.
         * @function toJSON
         * @memberof wavesenterprise.DataEntry
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DataEntry.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DataEntry;
    })();

    wavesenterprise.TransferTransaction = (function() {

        /**
         * Properties of a TransferTransaction.
         * @memberof wavesenterprise
         * @interface ITransferTransaction
         * @property {Uint8Array|null} [id] TransferTransaction id
         * @property {Uint8Array|null} [senderPublicKey] TransferTransaction senderPublicKey
         * @property {google.protobuf.IBytesValue|null} [assetId] TransferTransaction assetId
         * @property {google.protobuf.IBytesValue|null} [feeAssetId] TransferTransaction feeAssetId
         * @property {number|Long|null} [timestamp] TransferTransaction timestamp
         * @property {number|Long|null} [amount] TransferTransaction amount
         * @property {number|Long|null} [fee] TransferTransaction fee
         * @property {Uint8Array|null} [recipient] TransferTransaction recipient
         * @property {Uint8Array|null} [attachment] TransferTransaction attachment
         * @property {wavesenterprise.IAtomicBadge|null} [atomicBadge] TransferTransaction atomicBadge
         * @property {Array.<Uint8Array>|null} [proofs] TransferTransaction proofs
         */

        /**
         * Constructs a new TransferTransaction.
         * @memberof wavesenterprise
         * @classdesc Represents a TransferTransaction.
         * @implements ITransferTransaction
         * @constructor
         * @param {wavesenterprise.ITransferTransaction=} [properties] Properties to set
         */
        function TransferTransaction(properties) {
            this.proofs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TransferTransaction id.
         * @member {Uint8Array} id
         * @memberof wavesenterprise.TransferTransaction
         * @instance
         */
        TransferTransaction.prototype.id = $util.newBuffer([]);

        /**
         * TransferTransaction senderPublicKey.
         * @member {Uint8Array} senderPublicKey
         * @memberof wavesenterprise.TransferTransaction
         * @instance
         */
        TransferTransaction.prototype.senderPublicKey = $util.newBuffer([]);

        /**
         * TransferTransaction assetId.
         * @member {google.protobuf.IBytesValue|null|undefined} assetId
         * @memberof wavesenterprise.TransferTransaction
         * @instance
         */
        TransferTransaction.prototype.assetId = null;

        /**
         * TransferTransaction feeAssetId.
         * @member {google.protobuf.IBytesValue|null|undefined} feeAssetId
         * @memberof wavesenterprise.TransferTransaction
         * @instance
         */
        TransferTransaction.prototype.feeAssetId = null;

        /**
         * TransferTransaction timestamp.
         * @member {number|Long} timestamp
         * @memberof wavesenterprise.TransferTransaction
         * @instance
         */
        TransferTransaction.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * TransferTransaction amount.
         * @member {number|Long} amount
         * @memberof wavesenterprise.TransferTransaction
         * @instance
         */
        TransferTransaction.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * TransferTransaction fee.
         * @member {number|Long} fee
         * @memberof wavesenterprise.TransferTransaction
         * @instance
         */
        TransferTransaction.prototype.fee = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * TransferTransaction recipient.
         * @member {Uint8Array} recipient
         * @memberof wavesenterprise.TransferTransaction
         * @instance
         */
        TransferTransaction.prototype.recipient = $util.newBuffer([]);

        /**
         * TransferTransaction attachment.
         * @member {Uint8Array} attachment
         * @memberof wavesenterprise.TransferTransaction
         * @instance
         */
        TransferTransaction.prototype.attachment = $util.newBuffer([]);

        /**
         * TransferTransaction atomicBadge.
         * @member {wavesenterprise.IAtomicBadge|null|undefined} atomicBadge
         * @memberof wavesenterprise.TransferTransaction
         * @instance
         */
        TransferTransaction.prototype.atomicBadge = null;

        /**
         * TransferTransaction proofs.
         * @member {Array.<Uint8Array>} proofs
         * @memberof wavesenterprise.TransferTransaction
         * @instance
         */
        TransferTransaction.prototype.proofs = $util.emptyArray;

        /**
         * Creates a new TransferTransaction instance using the specified properties.
         * @function create
         * @memberof wavesenterprise.TransferTransaction
         * @static
         * @param {wavesenterprise.ITransferTransaction=} [properties] Properties to set
         * @returns {wavesenterprise.TransferTransaction} TransferTransaction instance
         */
        TransferTransaction.create = function create(properties) {
            return new TransferTransaction(properties);
        };

        /**
         * Encodes the specified TransferTransaction message. Does not implicitly {@link wavesenterprise.TransferTransaction.verify|verify} messages.
         * @function encode
         * @memberof wavesenterprise.TransferTransaction
         * @static
         * @param {wavesenterprise.ITransferTransaction} message TransferTransaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransferTransaction.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.id);
            if (message.senderPublicKey != null && Object.hasOwnProperty.call(message, "senderPublicKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.senderPublicKey);
            if (message.assetId != null && Object.hasOwnProperty.call(message, "assetId"))
                $root.google.protobuf.BytesValue.encode(message.assetId, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.feeAssetId != null && Object.hasOwnProperty.call(message, "feeAssetId"))
                $root.google.protobuf.BytesValue.encode(message.feeAssetId, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.timestamp);
            if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.amount);
            if (message.fee != null && Object.hasOwnProperty.call(message, "fee"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.fee);
            if (message.recipient != null && Object.hasOwnProperty.call(message, "recipient"))
                writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.recipient);
            if (message.attachment != null && Object.hasOwnProperty.call(message, "attachment"))
                writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.attachment);
            if (message.atomicBadge != null && Object.hasOwnProperty.call(message, "atomicBadge"))
                $root.wavesenterprise.AtomicBadge.encode(message.atomicBadge, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.proofs != null && message.proofs.length)
                for (var i = 0; i < message.proofs.length; ++i)
                    writer.uint32(/* id 11, wireType 2 =*/90).bytes(message.proofs[i]);
            return writer;
        };

        /**
         * Encodes the specified TransferTransaction message, length delimited. Does not implicitly {@link wavesenterprise.TransferTransaction.verify|verify} messages.
         * @function encodeDelimited
         * @memberof wavesenterprise.TransferTransaction
         * @static
         * @param {wavesenterprise.ITransferTransaction} message TransferTransaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransferTransaction.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TransferTransaction message from the specified reader or buffer.
         * @function decode
         * @memberof wavesenterprise.TransferTransaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {wavesenterprise.TransferTransaction} TransferTransaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransferTransaction.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.wavesenterprise.TransferTransaction();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.bytes();
                    break;
                case 2:
                    message.senderPublicKey = reader.bytes();
                    break;
                case 3:
                    message.assetId = $root.google.protobuf.BytesValue.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.feeAssetId = $root.google.protobuf.BytesValue.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.timestamp = reader.int64();
                    break;
                case 6:
                    message.amount = reader.int64();
                    break;
                case 7:
                    message.fee = reader.int64();
                    break;
                case 8:
                    message.recipient = reader.bytes();
                    break;
                case 9:
                    message.attachment = reader.bytes();
                    break;
                case 10:
                    message.atomicBadge = $root.wavesenterprise.AtomicBadge.decode(reader, reader.uint32());
                    break;
                case 11:
                    if (!(message.proofs && message.proofs.length))
                        message.proofs = [];
                    message.proofs.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TransferTransaction message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof wavesenterprise.TransferTransaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {wavesenterprise.TransferTransaction} TransferTransaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransferTransaction.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TransferTransaction message.
         * @function verify
         * @memberof wavesenterprise.TransferTransaction
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TransferTransaction.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!(message.id && typeof message.id.length === "number" || $util.isString(message.id)))
                    return "id: buffer expected";
            if (message.senderPublicKey != null && message.hasOwnProperty("senderPublicKey"))
                if (!(message.senderPublicKey && typeof message.senderPublicKey.length === "number" || $util.isString(message.senderPublicKey)))
                    return "senderPublicKey: buffer expected";
            if (message.assetId != null && message.hasOwnProperty("assetId")) {
                var error = $root.google.protobuf.BytesValue.verify(message.assetId);
                if (error)
                    return "assetId." + error;
            }
            if (message.feeAssetId != null && message.hasOwnProperty("feeAssetId")) {
                var error = $root.google.protobuf.BytesValue.verify(message.feeAssetId);
                if (error)
                    return "feeAssetId." + error;
            }
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            if (message.amount != null && message.hasOwnProperty("amount"))
                if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                    return "amount: integer|Long expected";
            if (message.fee != null && message.hasOwnProperty("fee"))
                if (!$util.isInteger(message.fee) && !(message.fee && $util.isInteger(message.fee.low) && $util.isInteger(message.fee.high)))
                    return "fee: integer|Long expected";
            if (message.recipient != null && message.hasOwnProperty("recipient"))
                if (!(message.recipient && typeof message.recipient.length === "number" || $util.isString(message.recipient)))
                    return "recipient: buffer expected";
            if (message.attachment != null && message.hasOwnProperty("attachment"))
                if (!(message.attachment && typeof message.attachment.length === "number" || $util.isString(message.attachment)))
                    return "attachment: buffer expected";
            if (message.atomicBadge != null && message.hasOwnProperty("atomicBadge")) {
                var error = $root.wavesenterprise.AtomicBadge.verify(message.atomicBadge);
                if (error)
                    return "atomicBadge." + error;
            }
            if (message.proofs != null && message.hasOwnProperty("proofs")) {
                if (!Array.isArray(message.proofs))
                    return "proofs: array expected";
                for (var i = 0; i < message.proofs.length; ++i)
                    if (!(message.proofs[i] && typeof message.proofs[i].length === "number" || $util.isString(message.proofs[i])))
                        return "proofs: buffer[] expected";
            }
            return null;
        };

        /**
         * Creates a TransferTransaction message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof wavesenterprise.TransferTransaction
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {wavesenterprise.TransferTransaction} TransferTransaction
         */
        TransferTransaction.fromObject = function fromObject(object) {
            if (object instanceof $root.wavesenterprise.TransferTransaction)
                return object;
            var message = new $root.wavesenterprise.TransferTransaction();
            if (object.id != null)
                if (typeof object.id === "string")
                    $util.base64.decode(object.id, message.id = $util.newBuffer($util.base64.length(object.id)), 0);
                else if (object.id.length)
                    message.id = object.id;
            if (object.senderPublicKey != null)
                if (typeof object.senderPublicKey === "string")
                    $util.base64.decode(object.senderPublicKey, message.senderPublicKey = $util.newBuffer($util.base64.length(object.senderPublicKey)), 0);
                else if (object.senderPublicKey.length)
                    message.senderPublicKey = object.senderPublicKey;
            if (object.assetId != null) {
                if (typeof object.assetId !== "object")
                    throw TypeError(".wavesenterprise.TransferTransaction.assetId: object expected");
                message.assetId = $root.google.protobuf.BytesValue.fromObject(object.assetId);
            }
            if (object.feeAssetId != null) {
                if (typeof object.feeAssetId !== "object")
                    throw TypeError(".wavesenterprise.TransferTransaction.feeAssetId: object expected");
                message.feeAssetId = $root.google.protobuf.BytesValue.fromObject(object.feeAssetId);
            }
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            if (object.amount != null)
                if ($util.Long)
                    (message.amount = $util.Long.fromValue(object.amount)).unsigned = false;
                else if (typeof object.amount === "string")
                    message.amount = parseInt(object.amount, 10);
                else if (typeof object.amount === "number")
                    message.amount = object.amount;
                else if (typeof object.amount === "object")
                    message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber();
            if (object.fee != null)
                if ($util.Long)
                    (message.fee = $util.Long.fromValue(object.fee)).unsigned = false;
                else if (typeof object.fee === "string")
                    message.fee = parseInt(object.fee, 10);
                else if (typeof object.fee === "number")
                    message.fee = object.fee;
                else if (typeof object.fee === "object")
                    message.fee = new $util.LongBits(object.fee.low >>> 0, object.fee.high >>> 0).toNumber();
            if (object.recipient != null)
                if (typeof object.recipient === "string")
                    $util.base64.decode(object.recipient, message.recipient = $util.newBuffer($util.base64.length(object.recipient)), 0);
                else if (object.recipient.length)
                    message.recipient = object.recipient;
            if (object.attachment != null)
                if (typeof object.attachment === "string")
                    $util.base64.decode(object.attachment, message.attachment = $util.newBuffer($util.base64.length(object.attachment)), 0);
                else if (object.attachment.length)
                    message.attachment = object.attachment;
            if (object.atomicBadge != null) {
                if (typeof object.atomicBadge !== "object")
                    throw TypeError(".wavesenterprise.TransferTransaction.atomicBadge: object expected");
                message.atomicBadge = $root.wavesenterprise.AtomicBadge.fromObject(object.atomicBadge);
            }
            if (object.proofs) {
                if (!Array.isArray(object.proofs))
                    throw TypeError(".wavesenterprise.TransferTransaction.proofs: array expected");
                message.proofs = [];
                for (var i = 0; i < object.proofs.length; ++i)
                    if (typeof object.proofs[i] === "string")
                        $util.base64.decode(object.proofs[i], message.proofs[i] = $util.newBuffer($util.base64.length(object.proofs[i])), 0);
                    else if (object.proofs[i].length)
                        message.proofs[i] = object.proofs[i];
            }
            return message;
        };

        /**
         * Creates a plain object from a TransferTransaction message. Also converts values to other types if specified.
         * @function toObject
         * @memberof wavesenterprise.TransferTransaction
         * @static
         * @param {wavesenterprise.TransferTransaction} message TransferTransaction
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TransferTransaction.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.proofs = [];
            if (options.defaults) {
                if (options.bytes === String)
                    object.id = "";
                else {
                    object.id = [];
                    if (options.bytes !== Array)
                        object.id = $util.newBuffer(object.id);
                }
                if (options.bytes === String)
                    object.senderPublicKey = "";
                else {
                    object.senderPublicKey = [];
                    if (options.bytes !== Array)
                        object.senderPublicKey = $util.newBuffer(object.senderPublicKey);
                }
                object.assetId = null;
                object.feeAssetId = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.amount = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.fee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.fee = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.recipient = "";
                else {
                    object.recipient = [];
                    if (options.bytes !== Array)
                        object.recipient = $util.newBuffer(object.recipient);
                }
                if (options.bytes === String)
                    object.attachment = "";
                else {
                    object.attachment = [];
                    if (options.bytes !== Array)
                        object.attachment = $util.newBuffer(object.attachment);
                }
                object.atomicBadge = null;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = options.bytes === String ? $util.base64.encode(message.id, 0, message.id.length) : options.bytes === Array ? Array.prototype.slice.call(message.id) : message.id;
            if (message.senderPublicKey != null && message.hasOwnProperty("senderPublicKey"))
                object.senderPublicKey = options.bytes === String ? $util.base64.encode(message.senderPublicKey, 0, message.senderPublicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.senderPublicKey) : message.senderPublicKey;
            if (message.assetId != null && message.hasOwnProperty("assetId"))
                object.assetId = $root.google.protobuf.BytesValue.toObject(message.assetId, options);
            if (message.feeAssetId != null && message.hasOwnProperty("feeAssetId"))
                object.feeAssetId = $root.google.protobuf.BytesValue.toObject(message.feeAssetId, options);
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            if (message.amount != null && message.hasOwnProperty("amount"))
                if (typeof message.amount === "number")
                    object.amount = options.longs === String ? String(message.amount) : message.amount;
                else
                    object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber() : message.amount;
            if (message.fee != null && message.hasOwnProperty("fee"))
                if (typeof message.fee === "number")
                    object.fee = options.longs === String ? String(message.fee) : message.fee;
                else
                    object.fee = options.longs === String ? $util.Long.prototype.toString.call(message.fee) : options.longs === Number ? new $util.LongBits(message.fee.low >>> 0, message.fee.high >>> 0).toNumber() : message.fee;
            if (message.recipient != null && message.hasOwnProperty("recipient"))
                object.recipient = options.bytes === String ? $util.base64.encode(message.recipient, 0, message.recipient.length) : options.bytes === Array ? Array.prototype.slice.call(message.recipient) : message.recipient;
            if (message.attachment != null && message.hasOwnProperty("attachment"))
                object.attachment = options.bytes === String ? $util.base64.encode(message.attachment, 0, message.attachment.length) : options.bytes === Array ? Array.prototype.slice.call(message.attachment) : message.attachment;
            if (message.atomicBadge != null && message.hasOwnProperty("atomicBadge"))
                object.atomicBadge = $root.wavesenterprise.AtomicBadge.toObject(message.atomicBadge, options);
            if (message.proofs && message.proofs.length) {
                object.proofs = [];
                for (var j = 0; j < message.proofs.length; ++j)
                    object.proofs[j] = options.bytes === String ? $util.base64.encode(message.proofs[j], 0, message.proofs[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.proofs[j]) : message.proofs[j];
            }
            return object;
        };

        /**
         * Converts this TransferTransaction to JSON.
         * @function toJSON
         * @memberof wavesenterprise.TransferTransaction
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TransferTransaction.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TransferTransaction;
    })();

    wavesenterprise.AtomicBadge = (function() {

        /**
         * Properties of an AtomicBadge.
         * @memberof wavesenterprise
         * @interface IAtomicBadge
         * @property {google.protobuf.IBytesValue|null} [trustedSender] AtomicBadge trustedSender
         */

        /**
         * Constructs a new AtomicBadge.
         * @memberof wavesenterprise
         * @classdesc Represents an AtomicBadge.
         * @implements IAtomicBadge
         * @constructor
         * @param {wavesenterprise.IAtomicBadge=} [properties] Properties to set
         */
        function AtomicBadge(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AtomicBadge trustedSender.
         * @member {google.protobuf.IBytesValue|null|undefined} trustedSender
         * @memberof wavesenterprise.AtomicBadge
         * @instance
         */
        AtomicBadge.prototype.trustedSender = null;

        /**
         * Creates a new AtomicBadge instance using the specified properties.
         * @function create
         * @memberof wavesenterprise.AtomicBadge
         * @static
         * @param {wavesenterprise.IAtomicBadge=} [properties] Properties to set
         * @returns {wavesenterprise.AtomicBadge} AtomicBadge instance
         */
        AtomicBadge.create = function create(properties) {
            return new AtomicBadge(properties);
        };

        /**
         * Encodes the specified AtomicBadge message. Does not implicitly {@link wavesenterprise.AtomicBadge.verify|verify} messages.
         * @function encode
         * @memberof wavesenterprise.AtomicBadge
         * @static
         * @param {wavesenterprise.IAtomicBadge} message AtomicBadge message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AtomicBadge.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.trustedSender != null && Object.hasOwnProperty.call(message, "trustedSender"))
                $root.google.protobuf.BytesValue.encode(message.trustedSender, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified AtomicBadge message, length delimited. Does not implicitly {@link wavesenterprise.AtomicBadge.verify|verify} messages.
         * @function encodeDelimited
         * @memberof wavesenterprise.AtomicBadge
         * @static
         * @param {wavesenterprise.IAtomicBadge} message AtomicBadge message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AtomicBadge.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AtomicBadge message from the specified reader or buffer.
         * @function decode
         * @memberof wavesenterprise.AtomicBadge
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {wavesenterprise.AtomicBadge} AtomicBadge
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AtomicBadge.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.wavesenterprise.AtomicBadge();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.trustedSender = $root.google.protobuf.BytesValue.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AtomicBadge message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof wavesenterprise.AtomicBadge
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {wavesenterprise.AtomicBadge} AtomicBadge
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AtomicBadge.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AtomicBadge message.
         * @function verify
         * @memberof wavesenterprise.AtomicBadge
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AtomicBadge.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.trustedSender != null && message.hasOwnProperty("trustedSender")) {
                var error = $root.google.protobuf.BytesValue.verify(message.trustedSender);
                if (error)
                    return "trustedSender." + error;
            }
            return null;
        };

        /**
         * Creates an AtomicBadge message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof wavesenterprise.AtomicBadge
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {wavesenterprise.AtomicBadge} AtomicBadge
         */
        AtomicBadge.fromObject = function fromObject(object) {
            if (object instanceof $root.wavesenterprise.AtomicBadge)
                return object;
            var message = new $root.wavesenterprise.AtomicBadge();
            if (object.trustedSender != null) {
                if (typeof object.trustedSender !== "object")
                    throw TypeError(".wavesenterprise.AtomicBadge.trustedSender: object expected");
                message.trustedSender = $root.google.protobuf.BytesValue.fromObject(object.trustedSender);
            }
            return message;
        };

        /**
         * Creates a plain object from an AtomicBadge message. Also converts values to other types if specified.
         * @function toObject
         * @memberof wavesenterprise.AtomicBadge
         * @static
         * @param {wavesenterprise.AtomicBadge} message AtomicBadge
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AtomicBadge.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.trustedSender = null;
            if (message.trustedSender != null && message.hasOwnProperty("trustedSender"))
                object.trustedSender = $root.google.protobuf.BytesValue.toObject(message.trustedSender, options);
            return object;
        };

        /**
         * Converts this AtomicBadge to JSON.
         * @function toJSON
         * @memberof wavesenterprise.AtomicBadge
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AtomicBadge.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AtomicBadge;
    })();

    wavesenterprise.MassTransferTransaction = (function() {

        /**
         * Properties of a MassTransferTransaction.
         * @memberof wavesenterprise
         * @interface IMassTransferTransaction
         * @property {Uint8Array|null} [id] MassTransferTransaction id
         * @property {Uint8Array|null} [senderPublicKey] MassTransferTransaction senderPublicKey
         * @property {google.protobuf.IBytesValue|null} [assetId] MassTransferTransaction assetId
         * @property {Array.<wavesenterprise.ITransfer>|null} [transfers] MassTransferTransaction transfers
         * @property {number|Long|null} [timestamp] MassTransferTransaction timestamp
         * @property {number|Long|null} [fee] MassTransferTransaction fee
         * @property {Uint8Array|null} [attachment] MassTransferTransaction attachment
         * @property {google.protobuf.IBytesValue|null} [feeAssetId] MassTransferTransaction feeAssetId
         * @property {Array.<Uint8Array>|null} [proofs] MassTransferTransaction proofs
         */

        /**
         * Constructs a new MassTransferTransaction.
         * @memberof wavesenterprise
         * @classdesc Represents a MassTransferTransaction.
         * @implements IMassTransferTransaction
         * @constructor
         * @param {wavesenterprise.IMassTransferTransaction=} [properties] Properties to set
         */
        function MassTransferTransaction(properties) {
            this.transfers = [];
            this.proofs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MassTransferTransaction id.
         * @member {Uint8Array} id
         * @memberof wavesenterprise.MassTransferTransaction
         * @instance
         */
        MassTransferTransaction.prototype.id = $util.newBuffer([]);

        /**
         * MassTransferTransaction senderPublicKey.
         * @member {Uint8Array} senderPublicKey
         * @memberof wavesenterprise.MassTransferTransaction
         * @instance
         */
        MassTransferTransaction.prototype.senderPublicKey = $util.newBuffer([]);

        /**
         * MassTransferTransaction assetId.
         * @member {google.protobuf.IBytesValue|null|undefined} assetId
         * @memberof wavesenterprise.MassTransferTransaction
         * @instance
         */
        MassTransferTransaction.prototype.assetId = null;

        /**
         * MassTransferTransaction transfers.
         * @member {Array.<wavesenterprise.ITransfer>} transfers
         * @memberof wavesenterprise.MassTransferTransaction
         * @instance
         */
        MassTransferTransaction.prototype.transfers = $util.emptyArray;

        /**
         * MassTransferTransaction timestamp.
         * @member {number|Long} timestamp
         * @memberof wavesenterprise.MassTransferTransaction
         * @instance
         */
        MassTransferTransaction.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * MassTransferTransaction fee.
         * @member {number|Long} fee
         * @memberof wavesenterprise.MassTransferTransaction
         * @instance
         */
        MassTransferTransaction.prototype.fee = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * MassTransferTransaction attachment.
         * @member {Uint8Array} attachment
         * @memberof wavesenterprise.MassTransferTransaction
         * @instance
         */
        MassTransferTransaction.prototype.attachment = $util.newBuffer([]);

        /**
         * MassTransferTransaction feeAssetId.
         * @member {google.protobuf.IBytesValue|null|undefined} feeAssetId
         * @memberof wavesenterprise.MassTransferTransaction
         * @instance
         */
        MassTransferTransaction.prototype.feeAssetId = null;

        /**
         * MassTransferTransaction proofs.
         * @member {Array.<Uint8Array>} proofs
         * @memberof wavesenterprise.MassTransferTransaction
         * @instance
         */
        MassTransferTransaction.prototype.proofs = $util.emptyArray;

        /**
         * Creates a new MassTransferTransaction instance using the specified properties.
         * @function create
         * @memberof wavesenterprise.MassTransferTransaction
         * @static
         * @param {wavesenterprise.IMassTransferTransaction=} [properties] Properties to set
         * @returns {wavesenterprise.MassTransferTransaction} MassTransferTransaction instance
         */
        MassTransferTransaction.create = function create(properties) {
            return new MassTransferTransaction(properties);
        };

        /**
         * Encodes the specified MassTransferTransaction message. Does not implicitly {@link wavesenterprise.MassTransferTransaction.verify|verify} messages.
         * @function encode
         * @memberof wavesenterprise.MassTransferTransaction
         * @static
         * @param {wavesenterprise.IMassTransferTransaction} message MassTransferTransaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MassTransferTransaction.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.id);
            if (message.senderPublicKey != null && Object.hasOwnProperty.call(message, "senderPublicKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.senderPublicKey);
            if (message.assetId != null && Object.hasOwnProperty.call(message, "assetId"))
                $root.google.protobuf.BytesValue.encode(message.assetId, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.transfers != null && message.transfers.length)
                for (var i = 0; i < message.transfers.length; ++i)
                    $root.wavesenterprise.Transfer.encode(message.transfers[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.timestamp);
            if (message.fee != null && Object.hasOwnProperty.call(message, "fee"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.fee);
            if (message.attachment != null && Object.hasOwnProperty.call(message, "attachment"))
                writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.attachment);
            if (message.feeAssetId != null && Object.hasOwnProperty.call(message, "feeAssetId"))
                $root.google.protobuf.BytesValue.encode(message.feeAssetId, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.proofs != null && message.proofs.length)
                for (var i = 0; i < message.proofs.length; ++i)
                    writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.proofs[i]);
            return writer;
        };

        /**
         * Encodes the specified MassTransferTransaction message, length delimited. Does not implicitly {@link wavesenterprise.MassTransferTransaction.verify|verify} messages.
         * @function encodeDelimited
         * @memberof wavesenterprise.MassTransferTransaction
         * @static
         * @param {wavesenterprise.IMassTransferTransaction} message MassTransferTransaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MassTransferTransaction.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MassTransferTransaction message from the specified reader or buffer.
         * @function decode
         * @memberof wavesenterprise.MassTransferTransaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {wavesenterprise.MassTransferTransaction} MassTransferTransaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MassTransferTransaction.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.wavesenterprise.MassTransferTransaction();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.bytes();
                    break;
                case 2:
                    message.senderPublicKey = reader.bytes();
                    break;
                case 3:
                    message.assetId = $root.google.protobuf.BytesValue.decode(reader, reader.uint32());
                    break;
                case 4:
                    if (!(message.transfers && message.transfers.length))
                        message.transfers = [];
                    message.transfers.push($root.wavesenterprise.Transfer.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.timestamp = reader.int64();
                    break;
                case 6:
                    message.fee = reader.int64();
                    break;
                case 7:
                    message.attachment = reader.bytes();
                    break;
                case 8:
                    message.feeAssetId = $root.google.protobuf.BytesValue.decode(reader, reader.uint32());
                    break;
                case 9:
                    if (!(message.proofs && message.proofs.length))
                        message.proofs = [];
                    message.proofs.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MassTransferTransaction message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof wavesenterprise.MassTransferTransaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {wavesenterprise.MassTransferTransaction} MassTransferTransaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MassTransferTransaction.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MassTransferTransaction message.
         * @function verify
         * @memberof wavesenterprise.MassTransferTransaction
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MassTransferTransaction.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!(message.id && typeof message.id.length === "number" || $util.isString(message.id)))
                    return "id: buffer expected";
            if (message.senderPublicKey != null && message.hasOwnProperty("senderPublicKey"))
                if (!(message.senderPublicKey && typeof message.senderPublicKey.length === "number" || $util.isString(message.senderPublicKey)))
                    return "senderPublicKey: buffer expected";
            if (message.assetId != null && message.hasOwnProperty("assetId")) {
                var error = $root.google.protobuf.BytesValue.verify(message.assetId);
                if (error)
                    return "assetId." + error;
            }
            if (message.transfers != null && message.hasOwnProperty("transfers")) {
                if (!Array.isArray(message.transfers))
                    return "transfers: array expected";
                for (var i = 0; i < message.transfers.length; ++i) {
                    var error = $root.wavesenterprise.Transfer.verify(message.transfers[i]);
                    if (error)
                        return "transfers." + error;
                }
            }
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            if (message.fee != null && message.hasOwnProperty("fee"))
                if (!$util.isInteger(message.fee) && !(message.fee && $util.isInteger(message.fee.low) && $util.isInteger(message.fee.high)))
                    return "fee: integer|Long expected";
            if (message.attachment != null && message.hasOwnProperty("attachment"))
                if (!(message.attachment && typeof message.attachment.length === "number" || $util.isString(message.attachment)))
                    return "attachment: buffer expected";
            if (message.feeAssetId != null && message.hasOwnProperty("feeAssetId")) {
                var error = $root.google.protobuf.BytesValue.verify(message.feeAssetId);
                if (error)
                    return "feeAssetId." + error;
            }
            if (message.proofs != null && message.hasOwnProperty("proofs")) {
                if (!Array.isArray(message.proofs))
                    return "proofs: array expected";
                for (var i = 0; i < message.proofs.length; ++i)
                    if (!(message.proofs[i] && typeof message.proofs[i].length === "number" || $util.isString(message.proofs[i])))
                        return "proofs: buffer[] expected";
            }
            return null;
        };

        /**
         * Creates a MassTransferTransaction message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof wavesenterprise.MassTransferTransaction
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {wavesenterprise.MassTransferTransaction} MassTransferTransaction
         */
        MassTransferTransaction.fromObject = function fromObject(object) {
            if (object instanceof $root.wavesenterprise.MassTransferTransaction)
                return object;
            var message = new $root.wavesenterprise.MassTransferTransaction();
            if (object.id != null)
                if (typeof object.id === "string")
                    $util.base64.decode(object.id, message.id = $util.newBuffer($util.base64.length(object.id)), 0);
                else if (object.id.length)
                    message.id = object.id;
            if (object.senderPublicKey != null)
                if (typeof object.senderPublicKey === "string")
                    $util.base64.decode(object.senderPublicKey, message.senderPublicKey = $util.newBuffer($util.base64.length(object.senderPublicKey)), 0);
                else if (object.senderPublicKey.length)
                    message.senderPublicKey = object.senderPublicKey;
            if (object.assetId != null) {
                if (typeof object.assetId !== "object")
                    throw TypeError(".wavesenterprise.MassTransferTransaction.assetId: object expected");
                message.assetId = $root.google.protobuf.BytesValue.fromObject(object.assetId);
            }
            if (object.transfers) {
                if (!Array.isArray(object.transfers))
                    throw TypeError(".wavesenterprise.MassTransferTransaction.transfers: array expected");
                message.transfers = [];
                for (var i = 0; i < object.transfers.length; ++i) {
                    if (typeof object.transfers[i] !== "object")
                        throw TypeError(".wavesenterprise.MassTransferTransaction.transfers: object expected");
                    message.transfers[i] = $root.wavesenterprise.Transfer.fromObject(object.transfers[i]);
                }
            }
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            if (object.fee != null)
                if ($util.Long)
                    (message.fee = $util.Long.fromValue(object.fee)).unsigned = false;
                else if (typeof object.fee === "string")
                    message.fee = parseInt(object.fee, 10);
                else if (typeof object.fee === "number")
                    message.fee = object.fee;
                else if (typeof object.fee === "object")
                    message.fee = new $util.LongBits(object.fee.low >>> 0, object.fee.high >>> 0).toNumber();
            if (object.attachment != null)
                if (typeof object.attachment === "string")
                    $util.base64.decode(object.attachment, message.attachment = $util.newBuffer($util.base64.length(object.attachment)), 0);
                else if (object.attachment.length)
                    message.attachment = object.attachment;
            if (object.feeAssetId != null) {
                if (typeof object.feeAssetId !== "object")
                    throw TypeError(".wavesenterprise.MassTransferTransaction.feeAssetId: object expected");
                message.feeAssetId = $root.google.protobuf.BytesValue.fromObject(object.feeAssetId);
            }
            if (object.proofs) {
                if (!Array.isArray(object.proofs))
                    throw TypeError(".wavesenterprise.MassTransferTransaction.proofs: array expected");
                message.proofs = [];
                for (var i = 0; i < object.proofs.length; ++i)
                    if (typeof object.proofs[i] === "string")
                        $util.base64.decode(object.proofs[i], message.proofs[i] = $util.newBuffer($util.base64.length(object.proofs[i])), 0);
                    else if (object.proofs[i].length)
                        message.proofs[i] = object.proofs[i];
            }
            return message;
        };

        /**
         * Creates a plain object from a MassTransferTransaction message. Also converts values to other types if specified.
         * @function toObject
         * @memberof wavesenterprise.MassTransferTransaction
         * @static
         * @param {wavesenterprise.MassTransferTransaction} message MassTransferTransaction
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MassTransferTransaction.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.transfers = [];
                object.proofs = [];
            }
            if (options.defaults) {
                if (options.bytes === String)
                    object.id = "";
                else {
                    object.id = [];
                    if (options.bytes !== Array)
                        object.id = $util.newBuffer(object.id);
                }
                if (options.bytes === String)
                    object.senderPublicKey = "";
                else {
                    object.senderPublicKey = [];
                    if (options.bytes !== Array)
                        object.senderPublicKey = $util.newBuffer(object.senderPublicKey);
                }
                object.assetId = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.fee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.fee = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.attachment = "";
                else {
                    object.attachment = [];
                    if (options.bytes !== Array)
                        object.attachment = $util.newBuffer(object.attachment);
                }
                object.feeAssetId = null;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = options.bytes === String ? $util.base64.encode(message.id, 0, message.id.length) : options.bytes === Array ? Array.prototype.slice.call(message.id) : message.id;
            if (message.senderPublicKey != null && message.hasOwnProperty("senderPublicKey"))
                object.senderPublicKey = options.bytes === String ? $util.base64.encode(message.senderPublicKey, 0, message.senderPublicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.senderPublicKey) : message.senderPublicKey;
            if (message.assetId != null && message.hasOwnProperty("assetId"))
                object.assetId = $root.google.protobuf.BytesValue.toObject(message.assetId, options);
            if (message.transfers && message.transfers.length) {
                object.transfers = [];
                for (var j = 0; j < message.transfers.length; ++j)
                    object.transfers[j] = $root.wavesenterprise.Transfer.toObject(message.transfers[j], options);
            }
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            if (message.fee != null && message.hasOwnProperty("fee"))
                if (typeof message.fee === "number")
                    object.fee = options.longs === String ? String(message.fee) : message.fee;
                else
                    object.fee = options.longs === String ? $util.Long.prototype.toString.call(message.fee) : options.longs === Number ? new $util.LongBits(message.fee.low >>> 0, message.fee.high >>> 0).toNumber() : message.fee;
            if (message.attachment != null && message.hasOwnProperty("attachment"))
                object.attachment = options.bytes === String ? $util.base64.encode(message.attachment, 0, message.attachment.length) : options.bytes === Array ? Array.prototype.slice.call(message.attachment) : message.attachment;
            if (message.feeAssetId != null && message.hasOwnProperty("feeAssetId"))
                object.feeAssetId = $root.google.protobuf.BytesValue.toObject(message.feeAssetId, options);
            if (message.proofs && message.proofs.length) {
                object.proofs = [];
                for (var j = 0; j < message.proofs.length; ++j)
                    object.proofs[j] = options.bytes === String ? $util.base64.encode(message.proofs[j], 0, message.proofs[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.proofs[j]) : message.proofs[j];
            }
            return object;
        };

        /**
         * Converts this MassTransferTransaction to JSON.
         * @function toJSON
         * @memberof wavesenterprise.MassTransferTransaction
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MassTransferTransaction.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MassTransferTransaction;
    })();

    wavesenterprise.Transfer = (function() {

        /**
         * Properties of a Transfer.
         * @memberof wavesenterprise
         * @interface ITransfer
         * @property {Uint8Array|null} [recipient] Transfer recipient
         * @property {number|Long|null} [amount] Transfer amount
         */

        /**
         * Constructs a new Transfer.
         * @memberof wavesenterprise
         * @classdesc Represents a Transfer.
         * @implements ITransfer
         * @constructor
         * @param {wavesenterprise.ITransfer=} [properties] Properties to set
         */
        function Transfer(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Transfer recipient.
         * @member {Uint8Array} recipient
         * @memberof wavesenterprise.Transfer
         * @instance
         */
        Transfer.prototype.recipient = $util.newBuffer([]);

        /**
         * Transfer amount.
         * @member {number|Long} amount
         * @memberof wavesenterprise.Transfer
         * @instance
         */
        Transfer.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new Transfer instance using the specified properties.
         * @function create
         * @memberof wavesenterprise.Transfer
         * @static
         * @param {wavesenterprise.ITransfer=} [properties] Properties to set
         * @returns {wavesenterprise.Transfer} Transfer instance
         */
        Transfer.create = function create(properties) {
            return new Transfer(properties);
        };

        /**
         * Encodes the specified Transfer message. Does not implicitly {@link wavesenterprise.Transfer.verify|verify} messages.
         * @function encode
         * @memberof wavesenterprise.Transfer
         * @static
         * @param {wavesenterprise.ITransfer} message Transfer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Transfer.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.recipient != null && Object.hasOwnProperty.call(message, "recipient"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.recipient);
            if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.amount);
            return writer;
        };

        /**
         * Encodes the specified Transfer message, length delimited. Does not implicitly {@link wavesenterprise.Transfer.verify|verify} messages.
         * @function encodeDelimited
         * @memberof wavesenterprise.Transfer
         * @static
         * @param {wavesenterprise.ITransfer} message Transfer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Transfer.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Transfer message from the specified reader or buffer.
         * @function decode
         * @memberof wavesenterprise.Transfer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {wavesenterprise.Transfer} Transfer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Transfer.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.wavesenterprise.Transfer();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.recipient = reader.bytes();
                    break;
                case 2:
                    message.amount = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Transfer message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof wavesenterprise.Transfer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {wavesenterprise.Transfer} Transfer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Transfer.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Transfer message.
         * @function verify
         * @memberof wavesenterprise.Transfer
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Transfer.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.recipient != null && message.hasOwnProperty("recipient"))
                if (!(message.recipient && typeof message.recipient.length === "number" || $util.isString(message.recipient)))
                    return "recipient: buffer expected";
            if (message.amount != null && message.hasOwnProperty("amount"))
                if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                    return "amount: integer|Long expected";
            return null;
        };

        /**
         * Creates a Transfer message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof wavesenterprise.Transfer
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {wavesenterprise.Transfer} Transfer
         */
        Transfer.fromObject = function fromObject(object) {
            if (object instanceof $root.wavesenterprise.Transfer)
                return object;
            var message = new $root.wavesenterprise.Transfer();
            if (object.recipient != null)
                if (typeof object.recipient === "string")
                    $util.base64.decode(object.recipient, message.recipient = $util.newBuffer($util.base64.length(object.recipient)), 0);
                else if (object.recipient.length)
                    message.recipient = object.recipient;
            if (object.amount != null)
                if ($util.Long)
                    (message.amount = $util.Long.fromValue(object.amount)).unsigned = false;
                else if (typeof object.amount === "string")
                    message.amount = parseInt(object.amount, 10);
                else if (typeof object.amount === "number")
                    message.amount = object.amount;
                else if (typeof object.amount === "object")
                    message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a Transfer message. Also converts values to other types if specified.
         * @function toObject
         * @memberof wavesenterprise.Transfer
         * @static
         * @param {wavesenterprise.Transfer} message Transfer
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Transfer.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.recipient = "";
                else {
                    object.recipient = [];
                    if (options.bytes !== Array)
                        object.recipient = $util.newBuffer(object.recipient);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.amount = options.longs === String ? "0" : 0;
            }
            if (message.recipient != null && message.hasOwnProperty("recipient"))
                object.recipient = options.bytes === String ? $util.base64.encode(message.recipient, 0, message.recipient.length) : options.bytes === Array ? Array.prototype.slice.call(message.recipient) : message.recipient;
            if (message.amount != null && message.hasOwnProperty("amount"))
                if (typeof message.amount === "number")
                    object.amount = options.longs === String ? String(message.amount) : message.amount;
                else
                    object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber() : message.amount;
            return object;
        };

        /**
         * Converts this Transfer to JSON.
         * @function toJSON
         * @memberof wavesenterprise.Transfer
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Transfer.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Transfer;
    })();

    wavesenterprise.PermitTransaction = (function() {

        /**
         * Properties of a PermitTransaction.
         * @memberof wavesenterprise
         * @interface IPermitTransaction
         * @property {Uint8Array|null} [id] PermitTransaction id
         * @property {Uint8Array|null} [senderPublicKey] PermitTransaction senderPublicKey
         * @property {Uint8Array|null} [target] PermitTransaction target
         * @property {number|Long|null} [timestamp] PermitTransaction timestamp
         * @property {number|Long|null} [fee] PermitTransaction fee
         * @property {wavesenterprise.IPermissionOp|null} [permissionOp] PermitTransaction permissionOp
         * @property {wavesenterprise.IAtomicBadge|null} [atomicBadge] PermitTransaction atomicBadge
         * @property {Array.<Uint8Array>|null} [proofs] PermitTransaction proofs
         */

        /**
         * Constructs a new PermitTransaction.
         * @memberof wavesenterprise
         * @classdesc Represents a PermitTransaction.
         * @implements IPermitTransaction
         * @constructor
         * @param {wavesenterprise.IPermitTransaction=} [properties] Properties to set
         */
        function PermitTransaction(properties) {
            this.proofs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PermitTransaction id.
         * @member {Uint8Array} id
         * @memberof wavesenterprise.PermitTransaction
         * @instance
         */
        PermitTransaction.prototype.id = $util.newBuffer([]);

        /**
         * PermitTransaction senderPublicKey.
         * @member {Uint8Array} senderPublicKey
         * @memberof wavesenterprise.PermitTransaction
         * @instance
         */
        PermitTransaction.prototype.senderPublicKey = $util.newBuffer([]);

        /**
         * PermitTransaction target.
         * @member {Uint8Array} target
         * @memberof wavesenterprise.PermitTransaction
         * @instance
         */
        PermitTransaction.prototype.target = $util.newBuffer([]);

        /**
         * PermitTransaction timestamp.
         * @member {number|Long} timestamp
         * @memberof wavesenterprise.PermitTransaction
         * @instance
         */
        PermitTransaction.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * PermitTransaction fee.
         * @member {number|Long} fee
         * @memberof wavesenterprise.PermitTransaction
         * @instance
         */
        PermitTransaction.prototype.fee = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * PermitTransaction permissionOp.
         * @member {wavesenterprise.IPermissionOp|null|undefined} permissionOp
         * @memberof wavesenterprise.PermitTransaction
         * @instance
         */
        PermitTransaction.prototype.permissionOp = null;

        /**
         * PermitTransaction atomicBadge.
         * @member {wavesenterprise.IAtomicBadge|null|undefined} atomicBadge
         * @memberof wavesenterprise.PermitTransaction
         * @instance
         */
        PermitTransaction.prototype.atomicBadge = null;

        /**
         * PermitTransaction proofs.
         * @member {Array.<Uint8Array>} proofs
         * @memberof wavesenterprise.PermitTransaction
         * @instance
         */
        PermitTransaction.prototype.proofs = $util.emptyArray;

        /**
         * Creates a new PermitTransaction instance using the specified properties.
         * @function create
         * @memberof wavesenterprise.PermitTransaction
         * @static
         * @param {wavesenterprise.IPermitTransaction=} [properties] Properties to set
         * @returns {wavesenterprise.PermitTransaction} PermitTransaction instance
         */
        PermitTransaction.create = function create(properties) {
            return new PermitTransaction(properties);
        };

        /**
         * Encodes the specified PermitTransaction message. Does not implicitly {@link wavesenterprise.PermitTransaction.verify|verify} messages.
         * @function encode
         * @memberof wavesenterprise.PermitTransaction
         * @static
         * @param {wavesenterprise.IPermitTransaction} message PermitTransaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PermitTransaction.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.id);
            if (message.senderPublicKey != null && Object.hasOwnProperty.call(message, "senderPublicKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.senderPublicKey);
            if (message.target != null && Object.hasOwnProperty.call(message, "target"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.target);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.timestamp);
            if (message.fee != null && Object.hasOwnProperty.call(message, "fee"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.fee);
            if (message.permissionOp != null && Object.hasOwnProperty.call(message, "permissionOp"))
                $root.wavesenterprise.PermissionOp.encode(message.permissionOp, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.atomicBadge != null && Object.hasOwnProperty.call(message, "atomicBadge"))
                $root.wavesenterprise.AtomicBadge.encode(message.atomicBadge, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.proofs != null && message.proofs.length)
                for (var i = 0; i < message.proofs.length; ++i)
                    writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.proofs[i]);
            return writer;
        };

        /**
         * Encodes the specified PermitTransaction message, length delimited. Does not implicitly {@link wavesenterprise.PermitTransaction.verify|verify} messages.
         * @function encodeDelimited
         * @memberof wavesenterprise.PermitTransaction
         * @static
         * @param {wavesenterprise.IPermitTransaction} message PermitTransaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PermitTransaction.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PermitTransaction message from the specified reader or buffer.
         * @function decode
         * @memberof wavesenterprise.PermitTransaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {wavesenterprise.PermitTransaction} PermitTransaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PermitTransaction.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.wavesenterprise.PermitTransaction();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.bytes();
                    break;
                case 2:
                    message.senderPublicKey = reader.bytes();
                    break;
                case 3:
                    message.target = reader.bytes();
                    break;
                case 4:
                    message.timestamp = reader.int64();
                    break;
                case 5:
                    message.fee = reader.int64();
                    break;
                case 6:
                    message.permissionOp = $root.wavesenterprise.PermissionOp.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.atomicBadge = $root.wavesenterprise.AtomicBadge.decode(reader, reader.uint32());
                    break;
                case 8:
                    if (!(message.proofs && message.proofs.length))
                        message.proofs = [];
                    message.proofs.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PermitTransaction message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof wavesenterprise.PermitTransaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {wavesenterprise.PermitTransaction} PermitTransaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PermitTransaction.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PermitTransaction message.
         * @function verify
         * @memberof wavesenterprise.PermitTransaction
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PermitTransaction.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!(message.id && typeof message.id.length === "number" || $util.isString(message.id)))
                    return "id: buffer expected";
            if (message.senderPublicKey != null && message.hasOwnProperty("senderPublicKey"))
                if (!(message.senderPublicKey && typeof message.senderPublicKey.length === "number" || $util.isString(message.senderPublicKey)))
                    return "senderPublicKey: buffer expected";
            if (message.target != null && message.hasOwnProperty("target"))
                if (!(message.target && typeof message.target.length === "number" || $util.isString(message.target)))
                    return "target: buffer expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            if (message.fee != null && message.hasOwnProperty("fee"))
                if (!$util.isInteger(message.fee) && !(message.fee && $util.isInteger(message.fee.low) && $util.isInteger(message.fee.high)))
                    return "fee: integer|Long expected";
            if (message.permissionOp != null && message.hasOwnProperty("permissionOp")) {
                var error = $root.wavesenterprise.PermissionOp.verify(message.permissionOp);
                if (error)
                    return "permissionOp." + error;
            }
            if (message.atomicBadge != null && message.hasOwnProperty("atomicBadge")) {
                var error = $root.wavesenterprise.AtomicBadge.verify(message.atomicBadge);
                if (error)
                    return "atomicBadge." + error;
            }
            if (message.proofs != null && message.hasOwnProperty("proofs")) {
                if (!Array.isArray(message.proofs))
                    return "proofs: array expected";
                for (var i = 0; i < message.proofs.length; ++i)
                    if (!(message.proofs[i] && typeof message.proofs[i].length === "number" || $util.isString(message.proofs[i])))
                        return "proofs: buffer[] expected";
            }
            return null;
        };

        /**
         * Creates a PermitTransaction message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof wavesenterprise.PermitTransaction
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {wavesenterprise.PermitTransaction} PermitTransaction
         */
        PermitTransaction.fromObject = function fromObject(object) {
            if (object instanceof $root.wavesenterprise.PermitTransaction)
                return object;
            var message = new $root.wavesenterprise.PermitTransaction();
            if (object.id != null)
                if (typeof object.id === "string")
                    $util.base64.decode(object.id, message.id = $util.newBuffer($util.base64.length(object.id)), 0);
                else if (object.id.length)
                    message.id = object.id;
            if (object.senderPublicKey != null)
                if (typeof object.senderPublicKey === "string")
                    $util.base64.decode(object.senderPublicKey, message.senderPublicKey = $util.newBuffer($util.base64.length(object.senderPublicKey)), 0);
                else if (object.senderPublicKey.length)
                    message.senderPublicKey = object.senderPublicKey;
            if (object.target != null)
                if (typeof object.target === "string")
                    $util.base64.decode(object.target, message.target = $util.newBuffer($util.base64.length(object.target)), 0);
                else if (object.target.length)
                    message.target = object.target;
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            if (object.fee != null)
                if ($util.Long)
                    (message.fee = $util.Long.fromValue(object.fee)).unsigned = false;
                else if (typeof object.fee === "string")
                    message.fee = parseInt(object.fee, 10);
                else if (typeof object.fee === "number")
                    message.fee = object.fee;
                else if (typeof object.fee === "object")
                    message.fee = new $util.LongBits(object.fee.low >>> 0, object.fee.high >>> 0).toNumber();
            if (object.permissionOp != null) {
                if (typeof object.permissionOp !== "object")
                    throw TypeError(".wavesenterprise.PermitTransaction.permissionOp: object expected");
                message.permissionOp = $root.wavesenterprise.PermissionOp.fromObject(object.permissionOp);
            }
            if (object.atomicBadge != null) {
                if (typeof object.atomicBadge !== "object")
                    throw TypeError(".wavesenterprise.PermitTransaction.atomicBadge: object expected");
                message.atomicBadge = $root.wavesenterprise.AtomicBadge.fromObject(object.atomicBadge);
            }
            if (object.proofs) {
                if (!Array.isArray(object.proofs))
                    throw TypeError(".wavesenterprise.PermitTransaction.proofs: array expected");
                message.proofs = [];
                for (var i = 0; i < object.proofs.length; ++i)
                    if (typeof object.proofs[i] === "string")
                        $util.base64.decode(object.proofs[i], message.proofs[i] = $util.newBuffer($util.base64.length(object.proofs[i])), 0);
                    else if (object.proofs[i].length)
                        message.proofs[i] = object.proofs[i];
            }
            return message;
        };

        /**
         * Creates a plain object from a PermitTransaction message. Also converts values to other types if specified.
         * @function toObject
         * @memberof wavesenterprise.PermitTransaction
         * @static
         * @param {wavesenterprise.PermitTransaction} message PermitTransaction
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PermitTransaction.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.proofs = [];
            if (options.defaults) {
                if (options.bytes === String)
                    object.id = "";
                else {
                    object.id = [];
                    if (options.bytes !== Array)
                        object.id = $util.newBuffer(object.id);
                }
                if (options.bytes === String)
                    object.senderPublicKey = "";
                else {
                    object.senderPublicKey = [];
                    if (options.bytes !== Array)
                        object.senderPublicKey = $util.newBuffer(object.senderPublicKey);
                }
                if (options.bytes === String)
                    object.target = "";
                else {
                    object.target = [];
                    if (options.bytes !== Array)
                        object.target = $util.newBuffer(object.target);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.fee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.fee = options.longs === String ? "0" : 0;
                object.permissionOp = null;
                object.atomicBadge = null;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = options.bytes === String ? $util.base64.encode(message.id, 0, message.id.length) : options.bytes === Array ? Array.prototype.slice.call(message.id) : message.id;
            if (message.senderPublicKey != null && message.hasOwnProperty("senderPublicKey"))
                object.senderPublicKey = options.bytes === String ? $util.base64.encode(message.senderPublicKey, 0, message.senderPublicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.senderPublicKey) : message.senderPublicKey;
            if (message.target != null && message.hasOwnProperty("target"))
                object.target = options.bytes === String ? $util.base64.encode(message.target, 0, message.target.length) : options.bytes === Array ? Array.prototype.slice.call(message.target) : message.target;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            if (message.fee != null && message.hasOwnProperty("fee"))
                if (typeof message.fee === "number")
                    object.fee = options.longs === String ? String(message.fee) : message.fee;
                else
                    object.fee = options.longs === String ? $util.Long.prototype.toString.call(message.fee) : options.longs === Number ? new $util.LongBits(message.fee.low >>> 0, message.fee.high >>> 0).toNumber() : message.fee;
            if (message.permissionOp != null && message.hasOwnProperty("permissionOp"))
                object.permissionOp = $root.wavesenterprise.PermissionOp.toObject(message.permissionOp, options);
            if (message.atomicBadge != null && message.hasOwnProperty("atomicBadge"))
                object.atomicBadge = $root.wavesenterprise.AtomicBadge.toObject(message.atomicBadge, options);
            if (message.proofs && message.proofs.length) {
                object.proofs = [];
                for (var j = 0; j < message.proofs.length; ++j)
                    object.proofs[j] = options.bytes === String ? $util.base64.encode(message.proofs[j], 0, message.proofs[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.proofs[j]) : message.proofs[j];
            }
            return object;
        };

        /**
         * Converts this PermitTransaction to JSON.
         * @function toJSON
         * @memberof wavesenterprise.PermitTransaction
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PermitTransaction.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PermitTransaction;
    })();

    wavesenterprise.PermissionOp = (function() {

        /**
         * Properties of a PermissionOp.
         * @memberof wavesenterprise
         * @interface IPermissionOp
         * @property {wavesenterprise.OpType|null} [opType] PermissionOp opType
         * @property {wavesenterprise.IRole|null} [role] PermissionOp role
         * @property {number|Long|null} [timestamp] PermissionOp timestamp
         * @property {google.protobuf.IInt64Value|null} [dueTimestamp] PermissionOp dueTimestamp
         */

        /**
         * Constructs a new PermissionOp.
         * @memberof wavesenterprise
         * @classdesc Represents a PermissionOp.
         * @implements IPermissionOp
         * @constructor
         * @param {wavesenterprise.IPermissionOp=} [properties] Properties to set
         */
        function PermissionOp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PermissionOp opType.
         * @member {wavesenterprise.OpType} opType
         * @memberof wavesenterprise.PermissionOp
         * @instance
         */
        PermissionOp.prototype.opType = 0;

        /**
         * PermissionOp role.
         * @member {wavesenterprise.IRole|null|undefined} role
         * @memberof wavesenterprise.PermissionOp
         * @instance
         */
        PermissionOp.prototype.role = null;

        /**
         * PermissionOp timestamp.
         * @member {number|Long} timestamp
         * @memberof wavesenterprise.PermissionOp
         * @instance
         */
        PermissionOp.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * PermissionOp dueTimestamp.
         * @member {google.protobuf.IInt64Value|null|undefined} dueTimestamp
         * @memberof wavesenterprise.PermissionOp
         * @instance
         */
        PermissionOp.prototype.dueTimestamp = null;

        /**
         * Creates a new PermissionOp instance using the specified properties.
         * @function create
         * @memberof wavesenterprise.PermissionOp
         * @static
         * @param {wavesenterprise.IPermissionOp=} [properties] Properties to set
         * @returns {wavesenterprise.PermissionOp} PermissionOp instance
         */
        PermissionOp.create = function create(properties) {
            return new PermissionOp(properties);
        };

        /**
         * Encodes the specified PermissionOp message. Does not implicitly {@link wavesenterprise.PermissionOp.verify|verify} messages.
         * @function encode
         * @memberof wavesenterprise.PermissionOp
         * @static
         * @param {wavesenterprise.IPermissionOp} message PermissionOp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PermissionOp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.opType != null && Object.hasOwnProperty.call(message, "opType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.opType);
            if (message.role != null && Object.hasOwnProperty.call(message, "role"))
                $root.wavesenterprise.Role.encode(message.role, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.timestamp);
            if (message.dueTimestamp != null && Object.hasOwnProperty.call(message, "dueTimestamp"))
                $root.google.protobuf.Int64Value.encode(message.dueTimestamp, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified PermissionOp message, length delimited. Does not implicitly {@link wavesenterprise.PermissionOp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof wavesenterprise.PermissionOp
         * @static
         * @param {wavesenterprise.IPermissionOp} message PermissionOp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PermissionOp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PermissionOp message from the specified reader or buffer.
         * @function decode
         * @memberof wavesenterprise.PermissionOp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {wavesenterprise.PermissionOp} PermissionOp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PermissionOp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.wavesenterprise.PermissionOp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.opType = reader.int32();
                    break;
                case 2:
                    message.role = $root.wavesenterprise.Role.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.timestamp = reader.int64();
                    break;
                case 4:
                    message.dueTimestamp = $root.google.protobuf.Int64Value.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PermissionOp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof wavesenterprise.PermissionOp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {wavesenterprise.PermissionOp} PermissionOp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PermissionOp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PermissionOp message.
         * @function verify
         * @memberof wavesenterprise.PermissionOp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PermissionOp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.opType != null && message.hasOwnProperty("opType"))
                switch (message.opType) {
                default:
                    return "opType: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.role != null && message.hasOwnProperty("role")) {
                var error = $root.wavesenterprise.Role.verify(message.role);
                if (error)
                    return "role." + error;
            }
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            if (message.dueTimestamp != null && message.hasOwnProperty("dueTimestamp")) {
                var error = $root.google.protobuf.Int64Value.verify(message.dueTimestamp);
                if (error)
                    return "dueTimestamp." + error;
            }
            return null;
        };

        /**
         * Creates a PermissionOp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof wavesenterprise.PermissionOp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {wavesenterprise.PermissionOp} PermissionOp
         */
        PermissionOp.fromObject = function fromObject(object) {
            if (object instanceof $root.wavesenterprise.PermissionOp)
                return object;
            var message = new $root.wavesenterprise.PermissionOp();
            switch (object.opType) {
            case "UNKNOWN_OP_TYPE":
            case 0:
                message.opType = 0;
                break;
            case "ADD":
            case 1:
                message.opType = 1;
                break;
            case "REMOVE":
            case 2:
                message.opType = 2;
                break;
            }
            if (object.role != null) {
                if (typeof object.role !== "object")
                    throw TypeError(".wavesenterprise.PermissionOp.role: object expected");
                message.role = $root.wavesenterprise.Role.fromObject(object.role);
            }
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            if (object.dueTimestamp != null) {
                if (typeof object.dueTimestamp !== "object")
                    throw TypeError(".wavesenterprise.PermissionOp.dueTimestamp: object expected");
                message.dueTimestamp = $root.google.protobuf.Int64Value.fromObject(object.dueTimestamp);
            }
            return message;
        };

        /**
         * Creates a plain object from a PermissionOp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof wavesenterprise.PermissionOp
         * @static
         * @param {wavesenterprise.PermissionOp} message PermissionOp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PermissionOp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.opType = options.enums === String ? "UNKNOWN_OP_TYPE" : 0;
                object.role = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
                object.dueTimestamp = null;
            }
            if (message.opType != null && message.hasOwnProperty("opType"))
                object.opType = options.enums === String ? $root.wavesenterprise.OpType[message.opType] : message.opType;
            if (message.role != null && message.hasOwnProperty("role"))
                object.role = $root.wavesenterprise.Role.toObject(message.role, options);
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            if (message.dueTimestamp != null && message.hasOwnProperty("dueTimestamp"))
                object.dueTimestamp = $root.google.protobuf.Int64Value.toObject(message.dueTimestamp, options);
            return object;
        };

        /**
         * Converts this PermissionOp to JSON.
         * @function toJSON
         * @memberof wavesenterprise.PermissionOp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PermissionOp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PermissionOp;
    })();

    wavesenterprise.CreatePolicyTransaction = (function() {

        /**
         * Properties of a CreatePolicyTransaction.
         * @memberof wavesenterprise
         * @interface ICreatePolicyTransaction
         * @property {Uint8Array|null} [id] CreatePolicyTransaction id
         * @property {Uint8Array|null} [senderPublicKey] CreatePolicyTransaction senderPublicKey
         * @property {string|null} [policyName] CreatePolicyTransaction policyName
         * @property {string|null} [description] CreatePolicyTransaction description
         * @property {Array.<Uint8Array>|null} [recipients] CreatePolicyTransaction recipients
         * @property {Array.<Uint8Array>|null} [owners] CreatePolicyTransaction owners
         * @property {number|Long|null} [timestamp] CreatePolicyTransaction timestamp
         * @property {number|Long|null} [fee] CreatePolicyTransaction fee
         * @property {google.protobuf.IBytesValue|null} [feeAssetId] CreatePolicyTransaction feeAssetId
         * @property {wavesenterprise.IAtomicBadge|null} [atomicBadge] CreatePolicyTransaction atomicBadge
         * @property {Array.<Uint8Array>|null} [proofs] CreatePolicyTransaction proofs
         */

        /**
         * Constructs a new CreatePolicyTransaction.
         * @memberof wavesenterprise
         * @classdesc Represents a CreatePolicyTransaction.
         * @implements ICreatePolicyTransaction
         * @constructor
         * @param {wavesenterprise.ICreatePolicyTransaction=} [properties] Properties to set
         */
        function CreatePolicyTransaction(properties) {
            this.recipients = [];
            this.owners = [];
            this.proofs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CreatePolicyTransaction id.
         * @member {Uint8Array} id
         * @memberof wavesenterprise.CreatePolicyTransaction
         * @instance
         */
        CreatePolicyTransaction.prototype.id = $util.newBuffer([]);

        /**
         * CreatePolicyTransaction senderPublicKey.
         * @member {Uint8Array} senderPublicKey
         * @memberof wavesenterprise.CreatePolicyTransaction
         * @instance
         */
        CreatePolicyTransaction.prototype.senderPublicKey = $util.newBuffer([]);

        /**
         * CreatePolicyTransaction policyName.
         * @member {string} policyName
         * @memberof wavesenterprise.CreatePolicyTransaction
         * @instance
         */
        CreatePolicyTransaction.prototype.policyName = "";

        /**
         * CreatePolicyTransaction description.
         * @member {string} description
         * @memberof wavesenterprise.CreatePolicyTransaction
         * @instance
         */
        CreatePolicyTransaction.prototype.description = "";

        /**
         * CreatePolicyTransaction recipients.
         * @member {Array.<Uint8Array>} recipients
         * @memberof wavesenterprise.CreatePolicyTransaction
         * @instance
         */
        CreatePolicyTransaction.prototype.recipients = $util.emptyArray;

        /**
         * CreatePolicyTransaction owners.
         * @member {Array.<Uint8Array>} owners
         * @memberof wavesenterprise.CreatePolicyTransaction
         * @instance
         */
        CreatePolicyTransaction.prototype.owners = $util.emptyArray;

        /**
         * CreatePolicyTransaction timestamp.
         * @member {number|Long} timestamp
         * @memberof wavesenterprise.CreatePolicyTransaction
         * @instance
         */
        CreatePolicyTransaction.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * CreatePolicyTransaction fee.
         * @member {number|Long} fee
         * @memberof wavesenterprise.CreatePolicyTransaction
         * @instance
         */
        CreatePolicyTransaction.prototype.fee = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * CreatePolicyTransaction feeAssetId.
         * @member {google.protobuf.IBytesValue|null|undefined} feeAssetId
         * @memberof wavesenterprise.CreatePolicyTransaction
         * @instance
         */
        CreatePolicyTransaction.prototype.feeAssetId = null;

        /**
         * CreatePolicyTransaction atomicBadge.
         * @member {wavesenterprise.IAtomicBadge|null|undefined} atomicBadge
         * @memberof wavesenterprise.CreatePolicyTransaction
         * @instance
         */
        CreatePolicyTransaction.prototype.atomicBadge = null;

        /**
         * CreatePolicyTransaction proofs.
         * @member {Array.<Uint8Array>} proofs
         * @memberof wavesenterprise.CreatePolicyTransaction
         * @instance
         */
        CreatePolicyTransaction.prototype.proofs = $util.emptyArray;

        /**
         * Creates a new CreatePolicyTransaction instance using the specified properties.
         * @function create
         * @memberof wavesenterprise.CreatePolicyTransaction
         * @static
         * @param {wavesenterprise.ICreatePolicyTransaction=} [properties] Properties to set
         * @returns {wavesenterprise.CreatePolicyTransaction} CreatePolicyTransaction instance
         */
        CreatePolicyTransaction.create = function create(properties) {
            return new CreatePolicyTransaction(properties);
        };

        /**
         * Encodes the specified CreatePolicyTransaction message. Does not implicitly {@link wavesenterprise.CreatePolicyTransaction.verify|verify} messages.
         * @function encode
         * @memberof wavesenterprise.CreatePolicyTransaction
         * @static
         * @param {wavesenterprise.ICreatePolicyTransaction} message CreatePolicyTransaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreatePolicyTransaction.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.id);
            if (message.senderPublicKey != null && Object.hasOwnProperty.call(message, "senderPublicKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.senderPublicKey);
            if (message.policyName != null && Object.hasOwnProperty.call(message, "policyName"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.policyName);
            if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.description);
            if (message.recipients != null && message.recipients.length)
                for (var i = 0; i < message.recipients.length; ++i)
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.recipients[i]);
            if (message.owners != null && message.owners.length)
                for (var i = 0; i < message.owners.length; ++i)
                    writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.owners[i]);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.timestamp);
            if (message.fee != null && Object.hasOwnProperty.call(message, "fee"))
                writer.uint32(/* id 8, wireType 0 =*/64).int64(message.fee);
            if (message.feeAssetId != null && Object.hasOwnProperty.call(message, "feeAssetId"))
                $root.google.protobuf.BytesValue.encode(message.feeAssetId, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.atomicBadge != null && Object.hasOwnProperty.call(message, "atomicBadge"))
                $root.wavesenterprise.AtomicBadge.encode(message.atomicBadge, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.proofs != null && message.proofs.length)
                for (var i = 0; i < message.proofs.length; ++i)
                    writer.uint32(/* id 11, wireType 2 =*/90).bytes(message.proofs[i]);
            return writer;
        };

        /**
         * Encodes the specified CreatePolicyTransaction message, length delimited. Does not implicitly {@link wavesenterprise.CreatePolicyTransaction.verify|verify} messages.
         * @function encodeDelimited
         * @memberof wavesenterprise.CreatePolicyTransaction
         * @static
         * @param {wavesenterprise.ICreatePolicyTransaction} message CreatePolicyTransaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreatePolicyTransaction.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CreatePolicyTransaction message from the specified reader or buffer.
         * @function decode
         * @memberof wavesenterprise.CreatePolicyTransaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {wavesenterprise.CreatePolicyTransaction} CreatePolicyTransaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreatePolicyTransaction.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.wavesenterprise.CreatePolicyTransaction();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.bytes();
                    break;
                case 2:
                    message.senderPublicKey = reader.bytes();
                    break;
                case 3:
                    message.policyName = reader.string();
                    break;
                case 4:
                    message.description = reader.string();
                    break;
                case 5:
                    if (!(message.recipients && message.recipients.length))
                        message.recipients = [];
                    message.recipients.push(reader.bytes());
                    break;
                case 6:
                    if (!(message.owners && message.owners.length))
                        message.owners = [];
                    message.owners.push(reader.bytes());
                    break;
                case 7:
                    message.timestamp = reader.int64();
                    break;
                case 8:
                    message.fee = reader.int64();
                    break;
                case 9:
                    message.feeAssetId = $root.google.protobuf.BytesValue.decode(reader, reader.uint32());
                    break;
                case 10:
                    message.atomicBadge = $root.wavesenterprise.AtomicBadge.decode(reader, reader.uint32());
                    break;
                case 11:
                    if (!(message.proofs && message.proofs.length))
                        message.proofs = [];
                    message.proofs.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CreatePolicyTransaction message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof wavesenterprise.CreatePolicyTransaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {wavesenterprise.CreatePolicyTransaction} CreatePolicyTransaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreatePolicyTransaction.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CreatePolicyTransaction message.
         * @function verify
         * @memberof wavesenterprise.CreatePolicyTransaction
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CreatePolicyTransaction.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!(message.id && typeof message.id.length === "number" || $util.isString(message.id)))
                    return "id: buffer expected";
            if (message.senderPublicKey != null && message.hasOwnProperty("senderPublicKey"))
                if (!(message.senderPublicKey && typeof message.senderPublicKey.length === "number" || $util.isString(message.senderPublicKey)))
                    return "senderPublicKey: buffer expected";
            if (message.policyName != null && message.hasOwnProperty("policyName"))
                if (!$util.isString(message.policyName))
                    return "policyName: string expected";
            if (message.description != null && message.hasOwnProperty("description"))
                if (!$util.isString(message.description))
                    return "description: string expected";
            if (message.recipients != null && message.hasOwnProperty("recipients")) {
                if (!Array.isArray(message.recipients))
                    return "recipients: array expected";
                for (var i = 0; i < message.recipients.length; ++i)
                    if (!(message.recipients[i] && typeof message.recipients[i].length === "number" || $util.isString(message.recipients[i])))
                        return "recipients: buffer[] expected";
            }
            if (message.owners != null && message.hasOwnProperty("owners")) {
                if (!Array.isArray(message.owners))
                    return "owners: array expected";
                for (var i = 0; i < message.owners.length; ++i)
                    if (!(message.owners[i] && typeof message.owners[i].length === "number" || $util.isString(message.owners[i])))
                        return "owners: buffer[] expected";
            }
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            if (message.fee != null && message.hasOwnProperty("fee"))
                if (!$util.isInteger(message.fee) && !(message.fee && $util.isInteger(message.fee.low) && $util.isInteger(message.fee.high)))
                    return "fee: integer|Long expected";
            if (message.feeAssetId != null && message.hasOwnProperty("feeAssetId")) {
                var error = $root.google.protobuf.BytesValue.verify(message.feeAssetId);
                if (error)
                    return "feeAssetId." + error;
            }
            if (message.atomicBadge != null && message.hasOwnProperty("atomicBadge")) {
                var error = $root.wavesenterprise.AtomicBadge.verify(message.atomicBadge);
                if (error)
                    return "atomicBadge." + error;
            }
            if (message.proofs != null && message.hasOwnProperty("proofs")) {
                if (!Array.isArray(message.proofs))
                    return "proofs: array expected";
                for (var i = 0; i < message.proofs.length; ++i)
                    if (!(message.proofs[i] && typeof message.proofs[i].length === "number" || $util.isString(message.proofs[i])))
                        return "proofs: buffer[] expected";
            }
            return null;
        };

        /**
         * Creates a CreatePolicyTransaction message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof wavesenterprise.CreatePolicyTransaction
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {wavesenterprise.CreatePolicyTransaction} CreatePolicyTransaction
         */
        CreatePolicyTransaction.fromObject = function fromObject(object) {
            if (object instanceof $root.wavesenterprise.CreatePolicyTransaction)
                return object;
            var message = new $root.wavesenterprise.CreatePolicyTransaction();
            if (object.id != null)
                if (typeof object.id === "string")
                    $util.base64.decode(object.id, message.id = $util.newBuffer($util.base64.length(object.id)), 0);
                else if (object.id.length)
                    message.id = object.id;
            if (object.senderPublicKey != null)
                if (typeof object.senderPublicKey === "string")
                    $util.base64.decode(object.senderPublicKey, message.senderPublicKey = $util.newBuffer($util.base64.length(object.senderPublicKey)), 0);
                else if (object.senderPublicKey.length)
                    message.senderPublicKey = object.senderPublicKey;
            if (object.policyName != null)
                message.policyName = String(object.policyName);
            if (object.description != null)
                message.description = String(object.description);
            if (object.recipients) {
                if (!Array.isArray(object.recipients))
                    throw TypeError(".wavesenterprise.CreatePolicyTransaction.recipients: array expected");
                message.recipients = [];
                for (var i = 0; i < object.recipients.length; ++i)
                    if (typeof object.recipients[i] === "string")
                        $util.base64.decode(object.recipients[i], message.recipients[i] = $util.newBuffer($util.base64.length(object.recipients[i])), 0);
                    else if (object.recipients[i].length)
                        message.recipients[i] = object.recipients[i];
            }
            if (object.owners) {
                if (!Array.isArray(object.owners))
                    throw TypeError(".wavesenterprise.CreatePolicyTransaction.owners: array expected");
                message.owners = [];
                for (var i = 0; i < object.owners.length; ++i)
                    if (typeof object.owners[i] === "string")
                        $util.base64.decode(object.owners[i], message.owners[i] = $util.newBuffer($util.base64.length(object.owners[i])), 0);
                    else if (object.owners[i].length)
                        message.owners[i] = object.owners[i];
            }
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            if (object.fee != null)
                if ($util.Long)
                    (message.fee = $util.Long.fromValue(object.fee)).unsigned = false;
                else if (typeof object.fee === "string")
                    message.fee = parseInt(object.fee, 10);
                else if (typeof object.fee === "number")
                    message.fee = object.fee;
                else if (typeof object.fee === "object")
                    message.fee = new $util.LongBits(object.fee.low >>> 0, object.fee.high >>> 0).toNumber();
            if (object.feeAssetId != null) {
                if (typeof object.feeAssetId !== "object")
                    throw TypeError(".wavesenterprise.CreatePolicyTransaction.feeAssetId: object expected");
                message.feeAssetId = $root.google.protobuf.BytesValue.fromObject(object.feeAssetId);
            }
            if (object.atomicBadge != null) {
                if (typeof object.atomicBadge !== "object")
                    throw TypeError(".wavesenterprise.CreatePolicyTransaction.atomicBadge: object expected");
                message.atomicBadge = $root.wavesenterprise.AtomicBadge.fromObject(object.atomicBadge);
            }
            if (object.proofs) {
                if (!Array.isArray(object.proofs))
                    throw TypeError(".wavesenterprise.CreatePolicyTransaction.proofs: array expected");
                message.proofs = [];
                for (var i = 0; i < object.proofs.length; ++i)
                    if (typeof object.proofs[i] === "string")
                        $util.base64.decode(object.proofs[i], message.proofs[i] = $util.newBuffer($util.base64.length(object.proofs[i])), 0);
                    else if (object.proofs[i].length)
                        message.proofs[i] = object.proofs[i];
            }
            return message;
        };

        /**
         * Creates a plain object from a CreatePolicyTransaction message. Also converts values to other types if specified.
         * @function toObject
         * @memberof wavesenterprise.CreatePolicyTransaction
         * @static
         * @param {wavesenterprise.CreatePolicyTransaction} message CreatePolicyTransaction
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CreatePolicyTransaction.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.recipients = [];
                object.owners = [];
                object.proofs = [];
            }
            if (options.defaults) {
                if (options.bytes === String)
                    object.id = "";
                else {
                    object.id = [];
                    if (options.bytes !== Array)
                        object.id = $util.newBuffer(object.id);
                }
                if (options.bytes === String)
                    object.senderPublicKey = "";
                else {
                    object.senderPublicKey = [];
                    if (options.bytes !== Array)
                        object.senderPublicKey = $util.newBuffer(object.senderPublicKey);
                }
                object.policyName = "";
                object.description = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.fee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.fee = options.longs === String ? "0" : 0;
                object.feeAssetId = null;
                object.atomicBadge = null;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = options.bytes === String ? $util.base64.encode(message.id, 0, message.id.length) : options.bytes === Array ? Array.prototype.slice.call(message.id) : message.id;
            if (message.senderPublicKey != null && message.hasOwnProperty("senderPublicKey"))
                object.senderPublicKey = options.bytes === String ? $util.base64.encode(message.senderPublicKey, 0, message.senderPublicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.senderPublicKey) : message.senderPublicKey;
            if (message.policyName != null && message.hasOwnProperty("policyName"))
                object.policyName = message.policyName;
            if (message.description != null && message.hasOwnProperty("description"))
                object.description = message.description;
            if (message.recipients && message.recipients.length) {
                object.recipients = [];
                for (var j = 0; j < message.recipients.length; ++j)
                    object.recipients[j] = options.bytes === String ? $util.base64.encode(message.recipients[j], 0, message.recipients[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.recipients[j]) : message.recipients[j];
            }
            if (message.owners && message.owners.length) {
                object.owners = [];
                for (var j = 0; j < message.owners.length; ++j)
                    object.owners[j] = options.bytes === String ? $util.base64.encode(message.owners[j], 0, message.owners[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.owners[j]) : message.owners[j];
            }
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            if (message.fee != null && message.hasOwnProperty("fee"))
                if (typeof message.fee === "number")
                    object.fee = options.longs === String ? String(message.fee) : message.fee;
                else
                    object.fee = options.longs === String ? $util.Long.prototype.toString.call(message.fee) : options.longs === Number ? new $util.LongBits(message.fee.low >>> 0, message.fee.high >>> 0).toNumber() : message.fee;
            if (message.feeAssetId != null && message.hasOwnProperty("feeAssetId"))
                object.feeAssetId = $root.google.protobuf.BytesValue.toObject(message.feeAssetId, options);
            if (message.atomicBadge != null && message.hasOwnProperty("atomicBadge"))
                object.atomicBadge = $root.wavesenterprise.AtomicBadge.toObject(message.atomicBadge, options);
            if (message.proofs && message.proofs.length) {
                object.proofs = [];
                for (var j = 0; j < message.proofs.length; ++j)
                    object.proofs[j] = options.bytes === String ? $util.base64.encode(message.proofs[j], 0, message.proofs[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.proofs[j]) : message.proofs[j];
            }
            return object;
        };

        /**
         * Converts this CreatePolicyTransaction to JSON.
         * @function toJSON
         * @memberof wavesenterprise.CreatePolicyTransaction
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CreatePolicyTransaction.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CreatePolicyTransaction;
    })();

    wavesenterprise.UpdatePolicyTransaction = (function() {

        /**
         * Properties of an UpdatePolicyTransaction.
         * @memberof wavesenterprise
         * @interface IUpdatePolicyTransaction
         * @property {Uint8Array|null} [id] UpdatePolicyTransaction id
         * @property {Uint8Array|null} [senderPublicKey] UpdatePolicyTransaction senderPublicKey
         * @property {Uint8Array|null} [policyId] UpdatePolicyTransaction policyId
         * @property {Array.<Uint8Array>|null} [recipients] UpdatePolicyTransaction recipients
         * @property {Array.<Uint8Array>|null} [owners] UpdatePolicyTransaction owners
         * @property {wavesenterprise.OpType|null} [opType] UpdatePolicyTransaction opType
         * @property {number|Long|null} [timestamp] UpdatePolicyTransaction timestamp
         * @property {number|Long|null} [fee] UpdatePolicyTransaction fee
         * @property {google.protobuf.IBytesValue|null} [feeAssetId] UpdatePolicyTransaction feeAssetId
         * @property {wavesenterprise.IAtomicBadge|null} [atomicBadge] UpdatePolicyTransaction atomicBadge
         * @property {Array.<Uint8Array>|null} [proofs] UpdatePolicyTransaction proofs
         */

        /**
         * Constructs a new UpdatePolicyTransaction.
         * @memberof wavesenterprise
         * @classdesc Represents an UpdatePolicyTransaction.
         * @implements IUpdatePolicyTransaction
         * @constructor
         * @param {wavesenterprise.IUpdatePolicyTransaction=} [properties] Properties to set
         */
        function UpdatePolicyTransaction(properties) {
            this.recipients = [];
            this.owners = [];
            this.proofs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpdatePolicyTransaction id.
         * @member {Uint8Array} id
         * @memberof wavesenterprise.UpdatePolicyTransaction
         * @instance
         */
        UpdatePolicyTransaction.prototype.id = $util.newBuffer([]);

        /**
         * UpdatePolicyTransaction senderPublicKey.
         * @member {Uint8Array} senderPublicKey
         * @memberof wavesenterprise.UpdatePolicyTransaction
         * @instance
         */
        UpdatePolicyTransaction.prototype.senderPublicKey = $util.newBuffer([]);

        /**
         * UpdatePolicyTransaction policyId.
         * @member {Uint8Array} policyId
         * @memberof wavesenterprise.UpdatePolicyTransaction
         * @instance
         */
        UpdatePolicyTransaction.prototype.policyId = $util.newBuffer([]);

        /**
         * UpdatePolicyTransaction recipients.
         * @member {Array.<Uint8Array>} recipients
         * @memberof wavesenterprise.UpdatePolicyTransaction
         * @instance
         */
        UpdatePolicyTransaction.prototype.recipients = $util.emptyArray;

        /**
         * UpdatePolicyTransaction owners.
         * @member {Array.<Uint8Array>} owners
         * @memberof wavesenterprise.UpdatePolicyTransaction
         * @instance
         */
        UpdatePolicyTransaction.prototype.owners = $util.emptyArray;

        /**
         * UpdatePolicyTransaction opType.
         * @member {wavesenterprise.OpType} opType
         * @memberof wavesenterprise.UpdatePolicyTransaction
         * @instance
         */
        UpdatePolicyTransaction.prototype.opType = 0;

        /**
         * UpdatePolicyTransaction timestamp.
         * @member {number|Long} timestamp
         * @memberof wavesenterprise.UpdatePolicyTransaction
         * @instance
         */
        UpdatePolicyTransaction.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * UpdatePolicyTransaction fee.
         * @member {number|Long} fee
         * @memberof wavesenterprise.UpdatePolicyTransaction
         * @instance
         */
        UpdatePolicyTransaction.prototype.fee = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * UpdatePolicyTransaction feeAssetId.
         * @member {google.protobuf.IBytesValue|null|undefined} feeAssetId
         * @memberof wavesenterprise.UpdatePolicyTransaction
         * @instance
         */
        UpdatePolicyTransaction.prototype.feeAssetId = null;

        /**
         * UpdatePolicyTransaction atomicBadge.
         * @member {wavesenterprise.IAtomicBadge|null|undefined} atomicBadge
         * @memberof wavesenterprise.UpdatePolicyTransaction
         * @instance
         */
        UpdatePolicyTransaction.prototype.atomicBadge = null;

        /**
         * UpdatePolicyTransaction proofs.
         * @member {Array.<Uint8Array>} proofs
         * @memberof wavesenterprise.UpdatePolicyTransaction
         * @instance
         */
        UpdatePolicyTransaction.prototype.proofs = $util.emptyArray;

        /**
         * Creates a new UpdatePolicyTransaction instance using the specified properties.
         * @function create
         * @memberof wavesenterprise.UpdatePolicyTransaction
         * @static
         * @param {wavesenterprise.IUpdatePolicyTransaction=} [properties] Properties to set
         * @returns {wavesenterprise.UpdatePolicyTransaction} UpdatePolicyTransaction instance
         */
        UpdatePolicyTransaction.create = function create(properties) {
            return new UpdatePolicyTransaction(properties);
        };

        /**
         * Encodes the specified UpdatePolicyTransaction message. Does not implicitly {@link wavesenterprise.UpdatePolicyTransaction.verify|verify} messages.
         * @function encode
         * @memberof wavesenterprise.UpdatePolicyTransaction
         * @static
         * @param {wavesenterprise.IUpdatePolicyTransaction} message UpdatePolicyTransaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdatePolicyTransaction.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.id);
            if (message.senderPublicKey != null && Object.hasOwnProperty.call(message, "senderPublicKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.senderPublicKey);
            if (message.policyId != null && Object.hasOwnProperty.call(message, "policyId"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.policyId);
            if (message.recipients != null && message.recipients.length)
                for (var i = 0; i < message.recipients.length; ++i)
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.recipients[i]);
            if (message.owners != null && message.owners.length)
                for (var i = 0; i < message.owners.length; ++i)
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.owners[i]);
            if (message.opType != null && Object.hasOwnProperty.call(message, "opType"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.opType);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.timestamp);
            if (message.fee != null && Object.hasOwnProperty.call(message, "fee"))
                writer.uint32(/* id 8, wireType 0 =*/64).int64(message.fee);
            if (message.feeAssetId != null && Object.hasOwnProperty.call(message, "feeAssetId"))
                $root.google.protobuf.BytesValue.encode(message.feeAssetId, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.atomicBadge != null && Object.hasOwnProperty.call(message, "atomicBadge"))
                $root.wavesenterprise.AtomicBadge.encode(message.atomicBadge, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.proofs != null && message.proofs.length)
                for (var i = 0; i < message.proofs.length; ++i)
                    writer.uint32(/* id 11, wireType 2 =*/90).bytes(message.proofs[i]);
            return writer;
        };

        /**
         * Encodes the specified UpdatePolicyTransaction message, length delimited. Does not implicitly {@link wavesenterprise.UpdatePolicyTransaction.verify|verify} messages.
         * @function encodeDelimited
         * @memberof wavesenterprise.UpdatePolicyTransaction
         * @static
         * @param {wavesenterprise.IUpdatePolicyTransaction} message UpdatePolicyTransaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdatePolicyTransaction.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UpdatePolicyTransaction message from the specified reader or buffer.
         * @function decode
         * @memberof wavesenterprise.UpdatePolicyTransaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {wavesenterprise.UpdatePolicyTransaction} UpdatePolicyTransaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdatePolicyTransaction.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.wavesenterprise.UpdatePolicyTransaction();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.bytes();
                    break;
                case 2:
                    message.senderPublicKey = reader.bytes();
                    break;
                case 3:
                    message.policyId = reader.bytes();
                    break;
                case 4:
                    if (!(message.recipients && message.recipients.length))
                        message.recipients = [];
                    message.recipients.push(reader.bytes());
                    break;
                case 5:
                    if (!(message.owners && message.owners.length))
                        message.owners = [];
                    message.owners.push(reader.bytes());
                    break;
                case 6:
                    message.opType = reader.int32();
                    break;
                case 7:
                    message.timestamp = reader.int64();
                    break;
                case 8:
                    message.fee = reader.int64();
                    break;
                case 9:
                    message.feeAssetId = $root.google.protobuf.BytesValue.decode(reader, reader.uint32());
                    break;
                case 10:
                    message.atomicBadge = $root.wavesenterprise.AtomicBadge.decode(reader, reader.uint32());
                    break;
                case 11:
                    if (!(message.proofs && message.proofs.length))
                        message.proofs = [];
                    message.proofs.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UpdatePolicyTransaction message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof wavesenterprise.UpdatePolicyTransaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {wavesenterprise.UpdatePolicyTransaction} UpdatePolicyTransaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdatePolicyTransaction.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UpdatePolicyTransaction message.
         * @function verify
         * @memberof wavesenterprise.UpdatePolicyTransaction
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpdatePolicyTransaction.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!(message.id && typeof message.id.length === "number" || $util.isString(message.id)))
                    return "id: buffer expected";
            if (message.senderPublicKey != null && message.hasOwnProperty("senderPublicKey"))
                if (!(message.senderPublicKey && typeof message.senderPublicKey.length === "number" || $util.isString(message.senderPublicKey)))
                    return "senderPublicKey: buffer expected";
            if (message.policyId != null && message.hasOwnProperty("policyId"))
                if (!(message.policyId && typeof message.policyId.length === "number" || $util.isString(message.policyId)))
                    return "policyId: buffer expected";
            if (message.recipients != null && message.hasOwnProperty("recipients")) {
                if (!Array.isArray(message.recipients))
                    return "recipients: array expected";
                for (var i = 0; i < message.recipients.length; ++i)
                    if (!(message.recipients[i] && typeof message.recipients[i].length === "number" || $util.isString(message.recipients[i])))
                        return "recipients: buffer[] expected";
            }
            if (message.owners != null && message.hasOwnProperty("owners")) {
                if (!Array.isArray(message.owners))
                    return "owners: array expected";
                for (var i = 0; i < message.owners.length; ++i)
                    if (!(message.owners[i] && typeof message.owners[i].length === "number" || $util.isString(message.owners[i])))
                        return "owners: buffer[] expected";
            }
            if (message.opType != null && message.hasOwnProperty("opType"))
                switch (message.opType) {
                default:
                    return "opType: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            if (message.fee != null && message.hasOwnProperty("fee"))
                if (!$util.isInteger(message.fee) && !(message.fee && $util.isInteger(message.fee.low) && $util.isInteger(message.fee.high)))
                    return "fee: integer|Long expected";
            if (message.feeAssetId != null && message.hasOwnProperty("feeAssetId")) {
                var error = $root.google.protobuf.BytesValue.verify(message.feeAssetId);
                if (error)
                    return "feeAssetId." + error;
            }
            if (message.atomicBadge != null && message.hasOwnProperty("atomicBadge")) {
                var error = $root.wavesenterprise.AtomicBadge.verify(message.atomicBadge);
                if (error)
                    return "atomicBadge." + error;
            }
            if (message.proofs != null && message.hasOwnProperty("proofs")) {
                if (!Array.isArray(message.proofs))
                    return "proofs: array expected";
                for (var i = 0; i < message.proofs.length; ++i)
                    if (!(message.proofs[i] && typeof message.proofs[i].length === "number" || $util.isString(message.proofs[i])))
                        return "proofs: buffer[] expected";
            }
            return null;
        };

        /**
         * Creates an UpdatePolicyTransaction message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof wavesenterprise.UpdatePolicyTransaction
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {wavesenterprise.UpdatePolicyTransaction} UpdatePolicyTransaction
         */
        UpdatePolicyTransaction.fromObject = function fromObject(object) {
            if (object instanceof $root.wavesenterprise.UpdatePolicyTransaction)
                return object;
            var message = new $root.wavesenterprise.UpdatePolicyTransaction();
            if (object.id != null)
                if (typeof object.id === "string")
                    $util.base64.decode(object.id, message.id = $util.newBuffer($util.base64.length(object.id)), 0);
                else if (object.id.length)
                    message.id = object.id;
            if (object.senderPublicKey != null)
                if (typeof object.senderPublicKey === "string")
                    $util.base64.decode(object.senderPublicKey, message.senderPublicKey = $util.newBuffer($util.base64.length(object.senderPublicKey)), 0);
                else if (object.senderPublicKey.length)
                    message.senderPublicKey = object.senderPublicKey;
            if (object.policyId != null)
                if (typeof object.policyId === "string")
                    $util.base64.decode(object.policyId, message.policyId = $util.newBuffer($util.base64.length(object.policyId)), 0);
                else if (object.policyId.length)
                    message.policyId = object.policyId;
            if (object.recipients) {
                if (!Array.isArray(object.recipients))
                    throw TypeError(".wavesenterprise.UpdatePolicyTransaction.recipients: array expected");
                message.recipients = [];
                for (var i = 0; i < object.recipients.length; ++i)
                    if (typeof object.recipients[i] === "string")
                        $util.base64.decode(object.recipients[i], message.recipients[i] = $util.newBuffer($util.base64.length(object.recipients[i])), 0);
                    else if (object.recipients[i].length)
                        message.recipients[i] = object.recipients[i];
            }
            if (object.owners) {
                if (!Array.isArray(object.owners))
                    throw TypeError(".wavesenterprise.UpdatePolicyTransaction.owners: array expected");
                message.owners = [];
                for (var i = 0; i < object.owners.length; ++i)
                    if (typeof object.owners[i] === "string")
                        $util.base64.decode(object.owners[i], message.owners[i] = $util.newBuffer($util.base64.length(object.owners[i])), 0);
                    else if (object.owners[i].length)
                        message.owners[i] = object.owners[i];
            }
            switch (object.opType) {
            case "UNKNOWN_OP_TYPE":
            case 0:
                message.opType = 0;
                break;
            case "ADD":
            case 1:
                message.opType = 1;
                break;
            case "REMOVE":
            case 2:
                message.opType = 2;
                break;
            }
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            if (object.fee != null)
                if ($util.Long)
                    (message.fee = $util.Long.fromValue(object.fee)).unsigned = false;
                else if (typeof object.fee === "string")
                    message.fee = parseInt(object.fee, 10);
                else if (typeof object.fee === "number")
                    message.fee = object.fee;
                else if (typeof object.fee === "object")
                    message.fee = new $util.LongBits(object.fee.low >>> 0, object.fee.high >>> 0).toNumber();
            if (object.feeAssetId != null) {
                if (typeof object.feeAssetId !== "object")
                    throw TypeError(".wavesenterprise.UpdatePolicyTransaction.feeAssetId: object expected");
                message.feeAssetId = $root.google.protobuf.BytesValue.fromObject(object.feeAssetId);
            }
            if (object.atomicBadge != null) {
                if (typeof object.atomicBadge !== "object")
                    throw TypeError(".wavesenterprise.UpdatePolicyTransaction.atomicBadge: object expected");
                message.atomicBadge = $root.wavesenterprise.AtomicBadge.fromObject(object.atomicBadge);
            }
            if (object.proofs) {
                if (!Array.isArray(object.proofs))
                    throw TypeError(".wavesenterprise.UpdatePolicyTransaction.proofs: array expected");
                message.proofs = [];
                for (var i = 0; i < object.proofs.length; ++i)
                    if (typeof object.proofs[i] === "string")
                        $util.base64.decode(object.proofs[i], message.proofs[i] = $util.newBuffer($util.base64.length(object.proofs[i])), 0);
                    else if (object.proofs[i].length)
                        message.proofs[i] = object.proofs[i];
            }
            return message;
        };

        /**
         * Creates a plain object from an UpdatePolicyTransaction message. Also converts values to other types if specified.
         * @function toObject
         * @memberof wavesenterprise.UpdatePolicyTransaction
         * @static
         * @param {wavesenterprise.UpdatePolicyTransaction} message UpdatePolicyTransaction
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UpdatePolicyTransaction.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.recipients = [];
                object.owners = [];
                object.proofs = [];
            }
            if (options.defaults) {
                if (options.bytes === String)
                    object.id = "";
                else {
                    object.id = [];
                    if (options.bytes !== Array)
                        object.id = $util.newBuffer(object.id);
                }
                if (options.bytes === String)
                    object.senderPublicKey = "";
                else {
                    object.senderPublicKey = [];
                    if (options.bytes !== Array)
                        object.senderPublicKey = $util.newBuffer(object.senderPublicKey);
                }
                if (options.bytes === String)
                    object.policyId = "";
                else {
                    object.policyId = [];
                    if (options.bytes !== Array)
                        object.policyId = $util.newBuffer(object.policyId);
                }
                object.opType = options.enums === String ? "UNKNOWN_OP_TYPE" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.fee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.fee = options.longs === String ? "0" : 0;
                object.feeAssetId = null;
                object.atomicBadge = null;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = options.bytes === String ? $util.base64.encode(message.id, 0, message.id.length) : options.bytes === Array ? Array.prototype.slice.call(message.id) : message.id;
            if (message.senderPublicKey != null && message.hasOwnProperty("senderPublicKey"))
                object.senderPublicKey = options.bytes === String ? $util.base64.encode(message.senderPublicKey, 0, message.senderPublicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.senderPublicKey) : message.senderPublicKey;
            if (message.policyId != null && message.hasOwnProperty("policyId"))
                object.policyId = options.bytes === String ? $util.base64.encode(message.policyId, 0, message.policyId.length) : options.bytes === Array ? Array.prototype.slice.call(message.policyId) : message.policyId;
            if (message.recipients && message.recipients.length) {
                object.recipients = [];
                for (var j = 0; j < message.recipients.length; ++j)
                    object.recipients[j] = options.bytes === String ? $util.base64.encode(message.recipients[j], 0, message.recipients[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.recipients[j]) : message.recipients[j];
            }
            if (message.owners && message.owners.length) {
                object.owners = [];
                for (var j = 0; j < message.owners.length; ++j)
                    object.owners[j] = options.bytes === String ? $util.base64.encode(message.owners[j], 0, message.owners[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.owners[j]) : message.owners[j];
            }
            if (message.opType != null && message.hasOwnProperty("opType"))
                object.opType = options.enums === String ? $root.wavesenterprise.OpType[message.opType] : message.opType;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            if (message.fee != null && message.hasOwnProperty("fee"))
                if (typeof message.fee === "number")
                    object.fee = options.longs === String ? String(message.fee) : message.fee;
                else
                    object.fee = options.longs === String ? $util.Long.prototype.toString.call(message.fee) : options.longs === Number ? new $util.LongBits(message.fee.low >>> 0, message.fee.high >>> 0).toNumber() : message.fee;
            if (message.feeAssetId != null && message.hasOwnProperty("feeAssetId"))
                object.feeAssetId = $root.google.protobuf.BytesValue.toObject(message.feeAssetId, options);
            if (message.atomicBadge != null && message.hasOwnProperty("atomicBadge"))
                object.atomicBadge = $root.wavesenterprise.AtomicBadge.toObject(message.atomicBadge, options);
            if (message.proofs && message.proofs.length) {
                object.proofs = [];
                for (var j = 0; j < message.proofs.length; ++j)
                    object.proofs[j] = options.bytes === String ? $util.base64.encode(message.proofs[j], 0, message.proofs[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.proofs[j]) : message.proofs[j];
            }
            return object;
        };

        /**
         * Converts this UpdatePolicyTransaction to JSON.
         * @function toJSON
         * @memberof wavesenterprise.UpdatePolicyTransaction
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UpdatePolicyTransaction.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UpdatePolicyTransaction;
    })();

    wavesenterprise.PolicyDataHashTransaction = (function() {

        /**
         * Properties of a PolicyDataHashTransaction.
         * @memberof wavesenterprise
         * @interface IPolicyDataHashTransaction
         * @property {Uint8Array|null} [id] PolicyDataHashTransaction id
         * @property {Uint8Array|null} [senderPublicKey] PolicyDataHashTransaction senderPublicKey
         * @property {Uint8Array|null} [dataHash] PolicyDataHashTransaction dataHash
         * @property {Uint8Array|null} [policyId] PolicyDataHashTransaction policyId
         * @property {number|Long|null} [timestamp] PolicyDataHashTransaction timestamp
         * @property {number|Long|null} [fee] PolicyDataHashTransaction fee
         * @property {google.protobuf.IBytesValue|null} [feeAssetId] PolicyDataHashTransaction feeAssetId
         * @property {wavesenterprise.IAtomicBadge|null} [atomicBadge] PolicyDataHashTransaction atomicBadge
         * @property {Array.<Uint8Array>|null} [proofs] PolicyDataHashTransaction proofs
         */

        /**
         * Constructs a new PolicyDataHashTransaction.
         * @memberof wavesenterprise
         * @classdesc Represents a PolicyDataHashTransaction.
         * @implements IPolicyDataHashTransaction
         * @constructor
         * @param {wavesenterprise.IPolicyDataHashTransaction=} [properties] Properties to set
         */
        function PolicyDataHashTransaction(properties) {
            this.proofs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PolicyDataHashTransaction id.
         * @member {Uint8Array} id
         * @memberof wavesenterprise.PolicyDataHashTransaction
         * @instance
         */
        PolicyDataHashTransaction.prototype.id = $util.newBuffer([]);

        /**
         * PolicyDataHashTransaction senderPublicKey.
         * @member {Uint8Array} senderPublicKey
         * @memberof wavesenterprise.PolicyDataHashTransaction
         * @instance
         */
        PolicyDataHashTransaction.prototype.senderPublicKey = $util.newBuffer([]);

        /**
         * PolicyDataHashTransaction dataHash.
         * @member {Uint8Array} dataHash
         * @memberof wavesenterprise.PolicyDataHashTransaction
         * @instance
         */
        PolicyDataHashTransaction.prototype.dataHash = $util.newBuffer([]);

        /**
         * PolicyDataHashTransaction policyId.
         * @member {Uint8Array} policyId
         * @memberof wavesenterprise.PolicyDataHashTransaction
         * @instance
         */
        PolicyDataHashTransaction.prototype.policyId = $util.newBuffer([]);

        /**
         * PolicyDataHashTransaction timestamp.
         * @member {number|Long} timestamp
         * @memberof wavesenterprise.PolicyDataHashTransaction
         * @instance
         */
        PolicyDataHashTransaction.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * PolicyDataHashTransaction fee.
         * @member {number|Long} fee
         * @memberof wavesenterprise.PolicyDataHashTransaction
         * @instance
         */
        PolicyDataHashTransaction.prototype.fee = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * PolicyDataHashTransaction feeAssetId.
         * @member {google.protobuf.IBytesValue|null|undefined} feeAssetId
         * @memberof wavesenterprise.PolicyDataHashTransaction
         * @instance
         */
        PolicyDataHashTransaction.prototype.feeAssetId = null;

        /**
         * PolicyDataHashTransaction atomicBadge.
         * @member {wavesenterprise.IAtomicBadge|null|undefined} atomicBadge
         * @memberof wavesenterprise.PolicyDataHashTransaction
         * @instance
         */
        PolicyDataHashTransaction.prototype.atomicBadge = null;

        /**
         * PolicyDataHashTransaction proofs.
         * @member {Array.<Uint8Array>} proofs
         * @memberof wavesenterprise.PolicyDataHashTransaction
         * @instance
         */
        PolicyDataHashTransaction.prototype.proofs = $util.emptyArray;

        /**
         * Creates a new PolicyDataHashTransaction instance using the specified properties.
         * @function create
         * @memberof wavesenterprise.PolicyDataHashTransaction
         * @static
         * @param {wavesenterprise.IPolicyDataHashTransaction=} [properties] Properties to set
         * @returns {wavesenterprise.PolicyDataHashTransaction} PolicyDataHashTransaction instance
         */
        PolicyDataHashTransaction.create = function create(properties) {
            return new PolicyDataHashTransaction(properties);
        };

        /**
         * Encodes the specified PolicyDataHashTransaction message. Does not implicitly {@link wavesenterprise.PolicyDataHashTransaction.verify|verify} messages.
         * @function encode
         * @memberof wavesenterprise.PolicyDataHashTransaction
         * @static
         * @param {wavesenterprise.IPolicyDataHashTransaction} message PolicyDataHashTransaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PolicyDataHashTransaction.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.id);
            if (message.senderPublicKey != null && Object.hasOwnProperty.call(message, "senderPublicKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.senderPublicKey);
            if (message.dataHash != null && Object.hasOwnProperty.call(message, "dataHash"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.dataHash);
            if (message.policyId != null && Object.hasOwnProperty.call(message, "policyId"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.policyId);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.timestamp);
            if (message.fee != null && Object.hasOwnProperty.call(message, "fee"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.fee);
            if (message.feeAssetId != null && Object.hasOwnProperty.call(message, "feeAssetId"))
                $root.google.protobuf.BytesValue.encode(message.feeAssetId, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.atomicBadge != null && Object.hasOwnProperty.call(message, "atomicBadge"))
                $root.wavesenterprise.AtomicBadge.encode(message.atomicBadge, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.proofs != null && message.proofs.length)
                for (var i = 0; i < message.proofs.length; ++i)
                    writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.proofs[i]);
            return writer;
        };

        /**
         * Encodes the specified PolicyDataHashTransaction message, length delimited. Does not implicitly {@link wavesenterprise.PolicyDataHashTransaction.verify|verify} messages.
         * @function encodeDelimited
         * @memberof wavesenterprise.PolicyDataHashTransaction
         * @static
         * @param {wavesenterprise.IPolicyDataHashTransaction} message PolicyDataHashTransaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PolicyDataHashTransaction.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PolicyDataHashTransaction message from the specified reader or buffer.
         * @function decode
         * @memberof wavesenterprise.PolicyDataHashTransaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {wavesenterprise.PolicyDataHashTransaction} PolicyDataHashTransaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PolicyDataHashTransaction.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.wavesenterprise.PolicyDataHashTransaction();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.bytes();
                    break;
                case 2:
                    message.senderPublicKey = reader.bytes();
                    break;
                case 3:
                    message.dataHash = reader.bytes();
                    break;
                case 4:
                    message.policyId = reader.bytes();
                    break;
                case 5:
                    message.timestamp = reader.int64();
                    break;
                case 6:
                    message.fee = reader.int64();
                    break;
                case 7:
                    message.feeAssetId = $root.google.protobuf.BytesValue.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.atomicBadge = $root.wavesenterprise.AtomicBadge.decode(reader, reader.uint32());
                    break;
                case 9:
                    if (!(message.proofs && message.proofs.length))
                        message.proofs = [];
                    message.proofs.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PolicyDataHashTransaction message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof wavesenterprise.PolicyDataHashTransaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {wavesenterprise.PolicyDataHashTransaction} PolicyDataHashTransaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PolicyDataHashTransaction.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PolicyDataHashTransaction message.
         * @function verify
         * @memberof wavesenterprise.PolicyDataHashTransaction
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PolicyDataHashTransaction.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!(message.id && typeof message.id.length === "number" || $util.isString(message.id)))
                    return "id: buffer expected";
            if (message.senderPublicKey != null && message.hasOwnProperty("senderPublicKey"))
                if (!(message.senderPublicKey && typeof message.senderPublicKey.length === "number" || $util.isString(message.senderPublicKey)))
                    return "senderPublicKey: buffer expected";
            if (message.dataHash != null && message.hasOwnProperty("dataHash"))
                if (!(message.dataHash && typeof message.dataHash.length === "number" || $util.isString(message.dataHash)))
                    return "dataHash: buffer expected";
            if (message.policyId != null && message.hasOwnProperty("policyId"))
                if (!(message.policyId && typeof message.policyId.length === "number" || $util.isString(message.policyId)))
                    return "policyId: buffer expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            if (message.fee != null && message.hasOwnProperty("fee"))
                if (!$util.isInteger(message.fee) && !(message.fee && $util.isInteger(message.fee.low) && $util.isInteger(message.fee.high)))
                    return "fee: integer|Long expected";
            if (message.feeAssetId != null && message.hasOwnProperty("feeAssetId")) {
                var error = $root.google.protobuf.BytesValue.verify(message.feeAssetId);
                if (error)
                    return "feeAssetId." + error;
            }
            if (message.atomicBadge != null && message.hasOwnProperty("atomicBadge")) {
                var error = $root.wavesenterprise.AtomicBadge.verify(message.atomicBadge);
                if (error)
                    return "atomicBadge." + error;
            }
            if (message.proofs != null && message.hasOwnProperty("proofs")) {
                if (!Array.isArray(message.proofs))
                    return "proofs: array expected";
                for (var i = 0; i < message.proofs.length; ++i)
                    if (!(message.proofs[i] && typeof message.proofs[i].length === "number" || $util.isString(message.proofs[i])))
                        return "proofs: buffer[] expected";
            }
            return null;
        };

        /**
         * Creates a PolicyDataHashTransaction message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof wavesenterprise.PolicyDataHashTransaction
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {wavesenterprise.PolicyDataHashTransaction} PolicyDataHashTransaction
         */
        PolicyDataHashTransaction.fromObject = function fromObject(object) {
            if (object instanceof $root.wavesenterprise.PolicyDataHashTransaction)
                return object;
            var message = new $root.wavesenterprise.PolicyDataHashTransaction();
            if (object.id != null)
                if (typeof object.id === "string")
                    $util.base64.decode(object.id, message.id = $util.newBuffer($util.base64.length(object.id)), 0);
                else if (object.id.length)
                    message.id = object.id;
            if (object.senderPublicKey != null)
                if (typeof object.senderPublicKey === "string")
                    $util.base64.decode(object.senderPublicKey, message.senderPublicKey = $util.newBuffer($util.base64.length(object.senderPublicKey)), 0);
                else if (object.senderPublicKey.length)
                    message.senderPublicKey = object.senderPublicKey;
            if (object.dataHash != null)
                if (typeof object.dataHash === "string")
                    $util.base64.decode(object.dataHash, message.dataHash = $util.newBuffer($util.base64.length(object.dataHash)), 0);
                else if (object.dataHash.length)
                    message.dataHash = object.dataHash;
            if (object.policyId != null)
                if (typeof object.policyId === "string")
                    $util.base64.decode(object.policyId, message.policyId = $util.newBuffer($util.base64.length(object.policyId)), 0);
                else if (object.policyId.length)
                    message.policyId = object.policyId;
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            if (object.fee != null)
                if ($util.Long)
                    (message.fee = $util.Long.fromValue(object.fee)).unsigned = false;
                else if (typeof object.fee === "string")
                    message.fee = parseInt(object.fee, 10);
                else if (typeof object.fee === "number")
                    message.fee = object.fee;
                else if (typeof object.fee === "object")
                    message.fee = new $util.LongBits(object.fee.low >>> 0, object.fee.high >>> 0).toNumber();
            if (object.feeAssetId != null) {
                if (typeof object.feeAssetId !== "object")
                    throw TypeError(".wavesenterprise.PolicyDataHashTransaction.feeAssetId: object expected");
                message.feeAssetId = $root.google.protobuf.BytesValue.fromObject(object.feeAssetId);
            }
            if (object.atomicBadge != null) {
                if (typeof object.atomicBadge !== "object")
                    throw TypeError(".wavesenterprise.PolicyDataHashTransaction.atomicBadge: object expected");
                message.atomicBadge = $root.wavesenterprise.AtomicBadge.fromObject(object.atomicBadge);
            }
            if (object.proofs) {
                if (!Array.isArray(object.proofs))
                    throw TypeError(".wavesenterprise.PolicyDataHashTransaction.proofs: array expected");
                message.proofs = [];
                for (var i = 0; i < object.proofs.length; ++i)
                    if (typeof object.proofs[i] === "string")
                        $util.base64.decode(object.proofs[i], message.proofs[i] = $util.newBuffer($util.base64.length(object.proofs[i])), 0);
                    else if (object.proofs[i].length)
                        message.proofs[i] = object.proofs[i];
            }
            return message;
        };

        /**
         * Creates a plain object from a PolicyDataHashTransaction message. Also converts values to other types if specified.
         * @function toObject
         * @memberof wavesenterprise.PolicyDataHashTransaction
         * @static
         * @param {wavesenterprise.PolicyDataHashTransaction} message PolicyDataHashTransaction
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PolicyDataHashTransaction.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.proofs = [];
            if (options.defaults) {
                if (options.bytes === String)
                    object.id = "";
                else {
                    object.id = [];
                    if (options.bytes !== Array)
                        object.id = $util.newBuffer(object.id);
                }
                if (options.bytes === String)
                    object.senderPublicKey = "";
                else {
                    object.senderPublicKey = [];
                    if (options.bytes !== Array)
                        object.senderPublicKey = $util.newBuffer(object.senderPublicKey);
                }
                if (options.bytes === String)
                    object.dataHash = "";
                else {
                    object.dataHash = [];
                    if (options.bytes !== Array)
                        object.dataHash = $util.newBuffer(object.dataHash);
                }
                if (options.bytes === String)
                    object.policyId = "";
                else {
                    object.policyId = [];
                    if (options.bytes !== Array)
                        object.policyId = $util.newBuffer(object.policyId);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.fee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.fee = options.longs === String ? "0" : 0;
                object.feeAssetId = null;
                object.atomicBadge = null;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = options.bytes === String ? $util.base64.encode(message.id, 0, message.id.length) : options.bytes === Array ? Array.prototype.slice.call(message.id) : message.id;
            if (message.senderPublicKey != null && message.hasOwnProperty("senderPublicKey"))
                object.senderPublicKey = options.bytes === String ? $util.base64.encode(message.senderPublicKey, 0, message.senderPublicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.senderPublicKey) : message.senderPublicKey;
            if (message.dataHash != null && message.hasOwnProperty("dataHash"))
                object.dataHash = options.bytes === String ? $util.base64.encode(message.dataHash, 0, message.dataHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.dataHash) : message.dataHash;
            if (message.policyId != null && message.hasOwnProperty("policyId"))
                object.policyId = options.bytes === String ? $util.base64.encode(message.policyId, 0, message.policyId.length) : options.bytes === Array ? Array.prototype.slice.call(message.policyId) : message.policyId;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            if (message.fee != null && message.hasOwnProperty("fee"))
                if (typeof message.fee === "number")
                    object.fee = options.longs === String ? String(message.fee) : message.fee;
                else
                    object.fee = options.longs === String ? $util.Long.prototype.toString.call(message.fee) : options.longs === Number ? new $util.LongBits(message.fee.low >>> 0, message.fee.high >>> 0).toNumber() : message.fee;
            if (message.feeAssetId != null && message.hasOwnProperty("feeAssetId"))
                object.feeAssetId = $root.google.protobuf.BytesValue.toObject(message.feeAssetId, options);
            if (message.atomicBadge != null && message.hasOwnProperty("atomicBadge"))
                object.atomicBadge = $root.wavesenterprise.AtomicBadge.toObject(message.atomicBadge, options);
            if (message.proofs && message.proofs.length) {
                object.proofs = [];
                for (var j = 0; j < message.proofs.length; ++j)
                    object.proofs[j] = options.bytes === String ? $util.base64.encode(message.proofs[j], 0, message.proofs[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.proofs[j]) : message.proofs[j];
            }
            return object;
        };

        /**
         * Converts this PolicyDataHashTransaction to JSON.
         * @function toJSON
         * @memberof wavesenterprise.PolicyDataHashTransaction
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PolicyDataHashTransaction.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PolicyDataHashTransaction;
    })();

    wavesenterprise.CreateContractTransaction = (function() {

        /**
         * Properties of a CreateContractTransaction.
         * @memberof wavesenterprise
         * @interface ICreateContractTransaction
         * @property {Uint8Array|null} [id] CreateContractTransaction id
         * @property {Uint8Array|null} [senderPublicKey] CreateContractTransaction senderPublicKey
         * @property {string|null} [image] CreateContractTransaction image
         * @property {string|null} [imageHash] CreateContractTransaction imageHash
         * @property {string|null} [contractName] CreateContractTransaction contractName
         * @property {Array.<wavesenterprise.IDataEntry>|null} [params] CreateContractTransaction params
         * @property {number|Long|null} [fee] CreateContractTransaction fee
         * @property {number|Long|null} [timestamp] CreateContractTransaction timestamp
         * @property {google.protobuf.IBytesValue|null} [feeAssetId] CreateContractTransaction feeAssetId
         * @property {wavesenterprise.IAtomicBadge|null} [atomicBadge] CreateContractTransaction atomicBadge
         * @property {wavesenterprise.IValidationPolicy|null} [validationPolicy] CreateContractTransaction validationPolicy
         * @property {wavesenterprise.IContractApiVersion|null} [apiVersion] CreateContractTransaction apiVersion
         * @property {Array.<Uint8Array>|null} [proofs] CreateContractTransaction proofs
         */

        /**
         * Constructs a new CreateContractTransaction.
         * @memberof wavesenterprise
         * @classdesc Represents a CreateContractTransaction.
         * @implements ICreateContractTransaction
         * @constructor
         * @param {wavesenterprise.ICreateContractTransaction=} [properties] Properties to set
         */
        function CreateContractTransaction(properties) {
            this.params = [];
            this.proofs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CreateContractTransaction id.
         * @member {Uint8Array} id
         * @memberof wavesenterprise.CreateContractTransaction
         * @instance
         */
        CreateContractTransaction.prototype.id = $util.newBuffer([]);

        /**
         * CreateContractTransaction senderPublicKey.
         * @member {Uint8Array} senderPublicKey
         * @memberof wavesenterprise.CreateContractTransaction
         * @instance
         */
        CreateContractTransaction.prototype.senderPublicKey = $util.newBuffer([]);

        /**
         * CreateContractTransaction image.
         * @member {string} image
         * @memberof wavesenterprise.CreateContractTransaction
         * @instance
         */
        CreateContractTransaction.prototype.image = "";

        /**
         * CreateContractTransaction imageHash.
         * @member {string} imageHash
         * @memberof wavesenterprise.CreateContractTransaction
         * @instance
         */
        CreateContractTransaction.prototype.imageHash = "";

        /**
         * CreateContractTransaction contractName.
         * @member {string} contractName
         * @memberof wavesenterprise.CreateContractTransaction
         * @instance
         */
        CreateContractTransaction.prototype.contractName = "";

        /**
         * CreateContractTransaction params.
         * @member {Array.<wavesenterprise.IDataEntry>} params
         * @memberof wavesenterprise.CreateContractTransaction
         * @instance
         */
        CreateContractTransaction.prototype.params = $util.emptyArray;

        /**
         * CreateContractTransaction fee.
         * @member {number|Long} fee
         * @memberof wavesenterprise.CreateContractTransaction
         * @instance
         */
        CreateContractTransaction.prototype.fee = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * CreateContractTransaction timestamp.
         * @member {number|Long} timestamp
         * @memberof wavesenterprise.CreateContractTransaction
         * @instance
         */
        CreateContractTransaction.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * CreateContractTransaction feeAssetId.
         * @member {google.protobuf.IBytesValue|null|undefined} feeAssetId
         * @memberof wavesenterprise.CreateContractTransaction
         * @instance
         */
        CreateContractTransaction.prototype.feeAssetId = null;

        /**
         * CreateContractTransaction atomicBadge.
         * @member {wavesenterprise.IAtomicBadge|null|undefined} atomicBadge
         * @memberof wavesenterprise.CreateContractTransaction
         * @instance
         */
        CreateContractTransaction.prototype.atomicBadge = null;

        /**
         * CreateContractTransaction validationPolicy.
         * @member {wavesenterprise.IValidationPolicy|null|undefined} validationPolicy
         * @memberof wavesenterprise.CreateContractTransaction
         * @instance
         */
        CreateContractTransaction.prototype.validationPolicy = null;

        /**
         * CreateContractTransaction apiVersion.
         * @member {wavesenterprise.IContractApiVersion|null|undefined} apiVersion
         * @memberof wavesenterprise.CreateContractTransaction
         * @instance
         */
        CreateContractTransaction.prototype.apiVersion = null;

        /**
         * CreateContractTransaction proofs.
         * @member {Array.<Uint8Array>} proofs
         * @memberof wavesenterprise.CreateContractTransaction
         * @instance
         */
        CreateContractTransaction.prototype.proofs = $util.emptyArray;

        /**
         * Creates a new CreateContractTransaction instance using the specified properties.
         * @function create
         * @memberof wavesenterprise.CreateContractTransaction
         * @static
         * @param {wavesenterprise.ICreateContractTransaction=} [properties] Properties to set
         * @returns {wavesenterprise.CreateContractTransaction} CreateContractTransaction instance
         */
        CreateContractTransaction.create = function create(properties) {
            return new CreateContractTransaction(properties);
        };

        /**
         * Encodes the specified CreateContractTransaction message. Does not implicitly {@link wavesenterprise.CreateContractTransaction.verify|verify} messages.
         * @function encode
         * @memberof wavesenterprise.CreateContractTransaction
         * @static
         * @param {wavesenterprise.ICreateContractTransaction} message CreateContractTransaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateContractTransaction.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.id);
            if (message.senderPublicKey != null && Object.hasOwnProperty.call(message, "senderPublicKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.senderPublicKey);
            if (message.image != null && Object.hasOwnProperty.call(message, "image"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.image);
            if (message.imageHash != null && Object.hasOwnProperty.call(message, "imageHash"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.imageHash);
            if (message.contractName != null && Object.hasOwnProperty.call(message, "contractName"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.contractName);
            if (message.params != null && message.params.length)
                for (var i = 0; i < message.params.length; ++i)
                    $root.wavesenterprise.DataEntry.encode(message.params[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.fee != null && Object.hasOwnProperty.call(message, "fee"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.fee);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 8, wireType 0 =*/64).int64(message.timestamp);
            if (message.feeAssetId != null && Object.hasOwnProperty.call(message, "feeAssetId"))
                $root.google.protobuf.BytesValue.encode(message.feeAssetId, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.atomicBadge != null && Object.hasOwnProperty.call(message, "atomicBadge"))
                $root.wavesenterprise.AtomicBadge.encode(message.atomicBadge, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.validationPolicy != null && Object.hasOwnProperty.call(message, "validationPolicy"))
                $root.wavesenterprise.ValidationPolicy.encode(message.validationPolicy, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            if (message.apiVersion != null && Object.hasOwnProperty.call(message, "apiVersion"))
                $root.wavesenterprise.ContractApiVersion.encode(message.apiVersion, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
            if (message.proofs != null && message.proofs.length)
                for (var i = 0; i < message.proofs.length; ++i)
                    writer.uint32(/* id 13, wireType 2 =*/106).bytes(message.proofs[i]);
            return writer;
        };

        /**
         * Encodes the specified CreateContractTransaction message, length delimited. Does not implicitly {@link wavesenterprise.CreateContractTransaction.verify|verify} messages.
         * @function encodeDelimited
         * @memberof wavesenterprise.CreateContractTransaction
         * @static
         * @param {wavesenterprise.ICreateContractTransaction} message CreateContractTransaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateContractTransaction.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CreateContractTransaction message from the specified reader or buffer.
         * @function decode
         * @memberof wavesenterprise.CreateContractTransaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {wavesenterprise.CreateContractTransaction} CreateContractTransaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateContractTransaction.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.wavesenterprise.CreateContractTransaction();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.bytes();
                    break;
                case 2:
                    message.senderPublicKey = reader.bytes();
                    break;
                case 3:
                    message.image = reader.string();
                    break;
                case 4:
                    message.imageHash = reader.string();
                    break;
                case 5:
                    message.contractName = reader.string();
                    break;
                case 6:
                    if (!(message.params && message.params.length))
                        message.params = [];
                    message.params.push($root.wavesenterprise.DataEntry.decode(reader, reader.uint32()));
                    break;
                case 7:
                    message.fee = reader.int64();
                    break;
                case 8:
                    message.timestamp = reader.int64();
                    break;
                case 9:
                    message.feeAssetId = $root.google.protobuf.BytesValue.decode(reader, reader.uint32());
                    break;
                case 10:
                    message.atomicBadge = $root.wavesenterprise.AtomicBadge.decode(reader, reader.uint32());
                    break;
                case 11:
                    message.validationPolicy = $root.wavesenterprise.ValidationPolicy.decode(reader, reader.uint32());
                    break;
                case 12:
                    message.apiVersion = $root.wavesenterprise.ContractApiVersion.decode(reader, reader.uint32());
                    break;
                case 13:
                    if (!(message.proofs && message.proofs.length))
                        message.proofs = [];
                    message.proofs.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CreateContractTransaction message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof wavesenterprise.CreateContractTransaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {wavesenterprise.CreateContractTransaction} CreateContractTransaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateContractTransaction.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CreateContractTransaction message.
         * @function verify
         * @memberof wavesenterprise.CreateContractTransaction
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CreateContractTransaction.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!(message.id && typeof message.id.length === "number" || $util.isString(message.id)))
                    return "id: buffer expected";
            if (message.senderPublicKey != null && message.hasOwnProperty("senderPublicKey"))
                if (!(message.senderPublicKey && typeof message.senderPublicKey.length === "number" || $util.isString(message.senderPublicKey)))
                    return "senderPublicKey: buffer expected";
            if (message.image != null && message.hasOwnProperty("image"))
                if (!$util.isString(message.image))
                    return "image: string expected";
            if (message.imageHash != null && message.hasOwnProperty("imageHash"))
                if (!$util.isString(message.imageHash))
                    return "imageHash: string expected";
            if (message.contractName != null && message.hasOwnProperty("contractName"))
                if (!$util.isString(message.contractName))
                    return "contractName: string expected";
            if (message.params != null && message.hasOwnProperty("params")) {
                if (!Array.isArray(message.params))
                    return "params: array expected";
                for (var i = 0; i < message.params.length; ++i) {
                    var error = $root.wavesenterprise.DataEntry.verify(message.params[i]);
                    if (error)
                        return "params." + error;
                }
            }
            if (message.fee != null && message.hasOwnProperty("fee"))
                if (!$util.isInteger(message.fee) && !(message.fee && $util.isInteger(message.fee.low) && $util.isInteger(message.fee.high)))
                    return "fee: integer|Long expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            if (message.feeAssetId != null && message.hasOwnProperty("feeAssetId")) {
                var error = $root.google.protobuf.BytesValue.verify(message.feeAssetId);
                if (error)
                    return "feeAssetId." + error;
            }
            if (message.atomicBadge != null && message.hasOwnProperty("atomicBadge")) {
                var error = $root.wavesenterprise.AtomicBadge.verify(message.atomicBadge);
                if (error)
                    return "atomicBadge." + error;
            }
            if (message.validationPolicy != null && message.hasOwnProperty("validationPolicy")) {
                var error = $root.wavesenterprise.ValidationPolicy.verify(message.validationPolicy);
                if (error)
                    return "validationPolicy." + error;
            }
            if (message.apiVersion != null && message.hasOwnProperty("apiVersion")) {
                var error = $root.wavesenterprise.ContractApiVersion.verify(message.apiVersion);
                if (error)
                    return "apiVersion." + error;
            }
            if (message.proofs != null && message.hasOwnProperty("proofs")) {
                if (!Array.isArray(message.proofs))
                    return "proofs: array expected";
                for (var i = 0; i < message.proofs.length; ++i)
                    if (!(message.proofs[i] && typeof message.proofs[i].length === "number" || $util.isString(message.proofs[i])))
                        return "proofs: buffer[] expected";
            }
            return null;
        };

        /**
         * Creates a CreateContractTransaction message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof wavesenterprise.CreateContractTransaction
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {wavesenterprise.CreateContractTransaction} CreateContractTransaction
         */
        CreateContractTransaction.fromObject = function fromObject(object) {
            if (object instanceof $root.wavesenterprise.CreateContractTransaction)
                return object;
            var message = new $root.wavesenterprise.CreateContractTransaction();
            if (object.id != null)
                if (typeof object.id === "string")
                    $util.base64.decode(object.id, message.id = $util.newBuffer($util.base64.length(object.id)), 0);
                else if (object.id.length)
                    message.id = object.id;
            if (object.senderPublicKey != null)
                if (typeof object.senderPublicKey === "string")
                    $util.base64.decode(object.senderPublicKey, message.senderPublicKey = $util.newBuffer($util.base64.length(object.senderPublicKey)), 0);
                else if (object.senderPublicKey.length)
                    message.senderPublicKey = object.senderPublicKey;
            if (object.image != null)
                message.image = String(object.image);
            if (object.imageHash != null)
                message.imageHash = String(object.imageHash);
            if (object.contractName != null)
                message.contractName = String(object.contractName);
            if (object.params) {
                if (!Array.isArray(object.params))
                    throw TypeError(".wavesenterprise.CreateContractTransaction.params: array expected");
                message.params = [];
                for (var i = 0; i < object.params.length; ++i) {
                    if (typeof object.params[i] !== "object")
                        throw TypeError(".wavesenterprise.CreateContractTransaction.params: object expected");
                    message.params[i] = $root.wavesenterprise.DataEntry.fromObject(object.params[i]);
                }
            }
            if (object.fee != null)
                if ($util.Long)
                    (message.fee = $util.Long.fromValue(object.fee)).unsigned = false;
                else if (typeof object.fee === "string")
                    message.fee = parseInt(object.fee, 10);
                else if (typeof object.fee === "number")
                    message.fee = object.fee;
                else if (typeof object.fee === "object")
                    message.fee = new $util.LongBits(object.fee.low >>> 0, object.fee.high >>> 0).toNumber();
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            if (object.feeAssetId != null) {
                if (typeof object.feeAssetId !== "object")
                    throw TypeError(".wavesenterprise.CreateContractTransaction.feeAssetId: object expected");
                message.feeAssetId = $root.google.protobuf.BytesValue.fromObject(object.feeAssetId);
            }
            if (object.atomicBadge != null) {
                if (typeof object.atomicBadge !== "object")
                    throw TypeError(".wavesenterprise.CreateContractTransaction.atomicBadge: object expected");
                message.atomicBadge = $root.wavesenterprise.AtomicBadge.fromObject(object.atomicBadge);
            }
            if (object.validationPolicy != null) {
                if (typeof object.validationPolicy !== "object")
                    throw TypeError(".wavesenterprise.CreateContractTransaction.validationPolicy: object expected");
                message.validationPolicy = $root.wavesenterprise.ValidationPolicy.fromObject(object.validationPolicy);
            }
            if (object.apiVersion != null) {
                if (typeof object.apiVersion !== "object")
                    throw TypeError(".wavesenterprise.CreateContractTransaction.apiVersion: object expected");
                message.apiVersion = $root.wavesenterprise.ContractApiVersion.fromObject(object.apiVersion);
            }
            if (object.proofs) {
                if (!Array.isArray(object.proofs))
                    throw TypeError(".wavesenterprise.CreateContractTransaction.proofs: array expected");
                message.proofs = [];
                for (var i = 0; i < object.proofs.length; ++i)
                    if (typeof object.proofs[i] === "string")
                        $util.base64.decode(object.proofs[i], message.proofs[i] = $util.newBuffer($util.base64.length(object.proofs[i])), 0);
                    else if (object.proofs[i].length)
                        message.proofs[i] = object.proofs[i];
            }
            return message;
        };

        /**
         * Creates a plain object from a CreateContractTransaction message. Also converts values to other types if specified.
         * @function toObject
         * @memberof wavesenterprise.CreateContractTransaction
         * @static
         * @param {wavesenterprise.CreateContractTransaction} message CreateContractTransaction
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CreateContractTransaction.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.params = [];
                object.proofs = [];
            }
            if (options.defaults) {
                if (options.bytes === String)
                    object.id = "";
                else {
                    object.id = [];
                    if (options.bytes !== Array)
                        object.id = $util.newBuffer(object.id);
                }
                if (options.bytes === String)
                    object.senderPublicKey = "";
                else {
                    object.senderPublicKey = [];
                    if (options.bytes !== Array)
                        object.senderPublicKey = $util.newBuffer(object.senderPublicKey);
                }
                object.image = "";
                object.imageHash = "";
                object.contractName = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.fee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.fee = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
                object.feeAssetId = null;
                object.atomicBadge = null;
                object.validationPolicy = null;
                object.apiVersion = null;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = options.bytes === String ? $util.base64.encode(message.id, 0, message.id.length) : options.bytes === Array ? Array.prototype.slice.call(message.id) : message.id;
            if (message.senderPublicKey != null && message.hasOwnProperty("senderPublicKey"))
                object.senderPublicKey = options.bytes === String ? $util.base64.encode(message.senderPublicKey, 0, message.senderPublicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.senderPublicKey) : message.senderPublicKey;
            if (message.image != null && message.hasOwnProperty("image"))
                object.image = message.image;
            if (message.imageHash != null && message.hasOwnProperty("imageHash"))
                object.imageHash = message.imageHash;
            if (message.contractName != null && message.hasOwnProperty("contractName"))
                object.contractName = message.contractName;
            if (message.params && message.params.length) {
                object.params = [];
                for (var j = 0; j < message.params.length; ++j)
                    object.params[j] = $root.wavesenterprise.DataEntry.toObject(message.params[j], options);
            }
            if (message.fee != null && message.hasOwnProperty("fee"))
                if (typeof message.fee === "number")
                    object.fee = options.longs === String ? String(message.fee) : message.fee;
                else
                    object.fee = options.longs === String ? $util.Long.prototype.toString.call(message.fee) : options.longs === Number ? new $util.LongBits(message.fee.low >>> 0, message.fee.high >>> 0).toNumber() : message.fee;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            if (message.feeAssetId != null && message.hasOwnProperty("feeAssetId"))
                object.feeAssetId = $root.google.protobuf.BytesValue.toObject(message.feeAssetId, options);
            if (message.atomicBadge != null && message.hasOwnProperty("atomicBadge"))
                object.atomicBadge = $root.wavesenterprise.AtomicBadge.toObject(message.atomicBadge, options);
            if (message.validationPolicy != null && message.hasOwnProperty("validationPolicy"))
                object.validationPolicy = $root.wavesenterprise.ValidationPolicy.toObject(message.validationPolicy, options);
            if (message.apiVersion != null && message.hasOwnProperty("apiVersion"))
                object.apiVersion = $root.wavesenterprise.ContractApiVersion.toObject(message.apiVersion, options);
            if (message.proofs && message.proofs.length) {
                object.proofs = [];
                for (var j = 0; j < message.proofs.length; ++j)
                    object.proofs[j] = options.bytes === String ? $util.base64.encode(message.proofs[j], 0, message.proofs[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.proofs[j]) : message.proofs[j];
            }
            return object;
        };

        /**
         * Converts this CreateContractTransaction to JSON.
         * @function toJSON
         * @memberof wavesenterprise.CreateContractTransaction
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CreateContractTransaction.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CreateContractTransaction;
    })();

    wavesenterprise.ContractApiVersion = (function() {

        /**
         * Properties of a ContractApiVersion.
         * @memberof wavesenterprise
         * @interface IContractApiVersion
         * @property {number|null} [majorVersion] ContractApiVersion majorVersion
         * @property {number|null} [minorVersion] ContractApiVersion minorVersion
         */

        /**
         * Constructs a new ContractApiVersion.
         * @memberof wavesenterprise
         * @classdesc Represents a ContractApiVersion.
         * @implements IContractApiVersion
         * @constructor
         * @param {wavesenterprise.IContractApiVersion=} [properties] Properties to set
         */
        function ContractApiVersion(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ContractApiVersion majorVersion.
         * @member {number} majorVersion
         * @memberof wavesenterprise.ContractApiVersion
         * @instance
         */
        ContractApiVersion.prototype.majorVersion = 0;

        /**
         * ContractApiVersion minorVersion.
         * @member {number} minorVersion
         * @memberof wavesenterprise.ContractApiVersion
         * @instance
         */
        ContractApiVersion.prototype.minorVersion = 0;

        /**
         * Creates a new ContractApiVersion instance using the specified properties.
         * @function create
         * @memberof wavesenterprise.ContractApiVersion
         * @static
         * @param {wavesenterprise.IContractApiVersion=} [properties] Properties to set
         * @returns {wavesenterprise.ContractApiVersion} ContractApiVersion instance
         */
        ContractApiVersion.create = function create(properties) {
            return new ContractApiVersion(properties);
        };

        /**
         * Encodes the specified ContractApiVersion message. Does not implicitly {@link wavesenterprise.ContractApiVersion.verify|verify} messages.
         * @function encode
         * @memberof wavesenterprise.ContractApiVersion
         * @static
         * @param {wavesenterprise.IContractApiVersion} message ContractApiVersion message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContractApiVersion.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.majorVersion != null && Object.hasOwnProperty.call(message, "majorVersion"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.majorVersion);
            if (message.minorVersion != null && Object.hasOwnProperty.call(message, "minorVersion"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.minorVersion);
            return writer;
        };

        /**
         * Encodes the specified ContractApiVersion message, length delimited. Does not implicitly {@link wavesenterprise.ContractApiVersion.verify|verify} messages.
         * @function encodeDelimited
         * @memberof wavesenterprise.ContractApiVersion
         * @static
         * @param {wavesenterprise.IContractApiVersion} message ContractApiVersion message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContractApiVersion.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ContractApiVersion message from the specified reader or buffer.
         * @function decode
         * @memberof wavesenterprise.ContractApiVersion
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {wavesenterprise.ContractApiVersion} ContractApiVersion
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContractApiVersion.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.wavesenterprise.ContractApiVersion();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.majorVersion = reader.int32();
                    break;
                case 2:
                    message.minorVersion = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ContractApiVersion message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof wavesenterprise.ContractApiVersion
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {wavesenterprise.ContractApiVersion} ContractApiVersion
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContractApiVersion.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ContractApiVersion message.
         * @function verify
         * @memberof wavesenterprise.ContractApiVersion
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ContractApiVersion.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.majorVersion != null && message.hasOwnProperty("majorVersion"))
                if (!$util.isInteger(message.majorVersion))
                    return "majorVersion: integer expected";
            if (message.minorVersion != null && message.hasOwnProperty("minorVersion"))
                if (!$util.isInteger(message.minorVersion))
                    return "minorVersion: integer expected";
            return null;
        };

        /**
         * Creates a ContractApiVersion message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof wavesenterprise.ContractApiVersion
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {wavesenterprise.ContractApiVersion} ContractApiVersion
         */
        ContractApiVersion.fromObject = function fromObject(object) {
            if (object instanceof $root.wavesenterprise.ContractApiVersion)
                return object;
            var message = new $root.wavesenterprise.ContractApiVersion();
            if (object.majorVersion != null)
                message.majorVersion = object.majorVersion | 0;
            if (object.minorVersion != null)
                message.minorVersion = object.minorVersion | 0;
            return message;
        };

        /**
         * Creates a plain object from a ContractApiVersion message. Also converts values to other types if specified.
         * @function toObject
         * @memberof wavesenterprise.ContractApiVersion
         * @static
         * @param {wavesenterprise.ContractApiVersion} message ContractApiVersion
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ContractApiVersion.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.majorVersion = 0;
                object.minorVersion = 0;
            }
            if (message.majorVersion != null && message.hasOwnProperty("majorVersion"))
                object.majorVersion = message.majorVersion;
            if (message.minorVersion != null && message.hasOwnProperty("minorVersion"))
                object.minorVersion = message.minorVersion;
            return object;
        };

        /**
         * Converts this ContractApiVersion to JSON.
         * @function toJSON
         * @memberof wavesenterprise.ContractApiVersion
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ContractApiVersion.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ContractApiVersion;
    })();

    wavesenterprise.ValidationPolicy = (function() {

        /**
         * Properties of a ValidationPolicy.
         * @memberof wavesenterprise
         * @interface IValidationPolicy
         * @property {wavesenterprise.ValidationPolicy.IAny|null} [any] ValidationPolicy any
         * @property {wavesenterprise.ValidationPolicy.IMajority|null} [majority] ValidationPolicy majority
         * @property {wavesenterprise.ValidationPolicy.IMajorityWithOneOf|null} [majorityWithOneOf] ValidationPolicy majorityWithOneOf
         */

        /**
         * Constructs a new ValidationPolicy.
         * @memberof wavesenterprise
         * @classdesc Represents a ValidationPolicy.
         * @implements IValidationPolicy
         * @constructor
         * @param {wavesenterprise.IValidationPolicy=} [properties] Properties to set
         */
        function ValidationPolicy(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ValidationPolicy any.
         * @member {wavesenterprise.ValidationPolicy.IAny|null|undefined} any
         * @memberof wavesenterprise.ValidationPolicy
         * @instance
         */
        ValidationPolicy.prototype.any = null;

        /**
         * ValidationPolicy majority.
         * @member {wavesenterprise.ValidationPolicy.IMajority|null|undefined} majority
         * @memberof wavesenterprise.ValidationPolicy
         * @instance
         */
        ValidationPolicy.prototype.majority = null;

        /**
         * ValidationPolicy majorityWithOneOf.
         * @member {wavesenterprise.ValidationPolicy.IMajorityWithOneOf|null|undefined} majorityWithOneOf
         * @memberof wavesenterprise.ValidationPolicy
         * @instance
         */
        ValidationPolicy.prototype.majorityWithOneOf = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * ValidationPolicy type.
         * @member {"any"|"majority"|"majorityWithOneOf"|undefined} type
         * @memberof wavesenterprise.ValidationPolicy
         * @instance
         */
        Object.defineProperty(ValidationPolicy.prototype, "type", {
            get: $util.oneOfGetter($oneOfFields = ["any", "majority", "majorityWithOneOf"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new ValidationPolicy instance using the specified properties.
         * @function create
         * @memberof wavesenterprise.ValidationPolicy
         * @static
         * @param {wavesenterprise.IValidationPolicy=} [properties] Properties to set
         * @returns {wavesenterprise.ValidationPolicy} ValidationPolicy instance
         */
        ValidationPolicy.create = function create(properties) {
            return new ValidationPolicy(properties);
        };

        /**
         * Encodes the specified ValidationPolicy message. Does not implicitly {@link wavesenterprise.ValidationPolicy.verify|verify} messages.
         * @function encode
         * @memberof wavesenterprise.ValidationPolicy
         * @static
         * @param {wavesenterprise.IValidationPolicy} message ValidationPolicy message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ValidationPolicy.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.any != null && Object.hasOwnProperty.call(message, "any"))
                $root.wavesenterprise.ValidationPolicy.Any.encode(message.any, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.majority != null && Object.hasOwnProperty.call(message, "majority"))
                $root.wavesenterprise.ValidationPolicy.Majority.encode(message.majority, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            if (message.majorityWithOneOf != null && Object.hasOwnProperty.call(message, "majorityWithOneOf"))
                $root.wavesenterprise.ValidationPolicy.MajorityWithOneOf.encode(message.majorityWithOneOf, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ValidationPolicy message, length delimited. Does not implicitly {@link wavesenterprise.ValidationPolicy.verify|verify} messages.
         * @function encodeDelimited
         * @memberof wavesenterprise.ValidationPolicy
         * @static
         * @param {wavesenterprise.IValidationPolicy} message ValidationPolicy message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ValidationPolicy.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ValidationPolicy message from the specified reader or buffer.
         * @function decode
         * @memberof wavesenterprise.ValidationPolicy
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {wavesenterprise.ValidationPolicy} ValidationPolicy
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ValidationPolicy.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.wavesenterprise.ValidationPolicy();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 10:
                    message.any = $root.wavesenterprise.ValidationPolicy.Any.decode(reader, reader.uint32());
                    break;
                case 11:
                    message.majority = $root.wavesenterprise.ValidationPolicy.Majority.decode(reader, reader.uint32());
                    break;
                case 12:
                    message.majorityWithOneOf = $root.wavesenterprise.ValidationPolicy.MajorityWithOneOf.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ValidationPolicy message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof wavesenterprise.ValidationPolicy
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {wavesenterprise.ValidationPolicy} ValidationPolicy
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ValidationPolicy.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ValidationPolicy message.
         * @function verify
         * @memberof wavesenterprise.ValidationPolicy
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ValidationPolicy.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.any != null && message.hasOwnProperty("any")) {
                properties.type = 1;
                {
                    var error = $root.wavesenterprise.ValidationPolicy.Any.verify(message.any);
                    if (error)
                        return "any." + error;
                }
            }
            if (message.majority != null && message.hasOwnProperty("majority")) {
                if (properties.type === 1)
                    return "type: multiple values";
                properties.type = 1;
                {
                    var error = $root.wavesenterprise.ValidationPolicy.Majority.verify(message.majority);
                    if (error)
                        return "majority." + error;
                }
            }
            if (message.majorityWithOneOf != null && message.hasOwnProperty("majorityWithOneOf")) {
                if (properties.type === 1)
                    return "type: multiple values";
                properties.type = 1;
                {
                    var error = $root.wavesenterprise.ValidationPolicy.MajorityWithOneOf.verify(message.majorityWithOneOf);
                    if (error)
                        return "majorityWithOneOf." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ValidationPolicy message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof wavesenterprise.ValidationPolicy
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {wavesenterprise.ValidationPolicy} ValidationPolicy
         */
        ValidationPolicy.fromObject = function fromObject(object) {
            if (object instanceof $root.wavesenterprise.ValidationPolicy)
                return object;
            var message = new $root.wavesenterprise.ValidationPolicy();
            if (object.any != null) {
                if (typeof object.any !== "object")
                    throw TypeError(".wavesenterprise.ValidationPolicy.any: object expected");
                message.any = $root.wavesenterprise.ValidationPolicy.Any.fromObject(object.any);
            }
            if (object.majority != null) {
                if (typeof object.majority !== "object")
                    throw TypeError(".wavesenterprise.ValidationPolicy.majority: object expected");
                message.majority = $root.wavesenterprise.ValidationPolicy.Majority.fromObject(object.majority);
            }
            if (object.majorityWithOneOf != null) {
                if (typeof object.majorityWithOneOf !== "object")
                    throw TypeError(".wavesenterprise.ValidationPolicy.majorityWithOneOf: object expected");
                message.majorityWithOneOf = $root.wavesenterprise.ValidationPolicy.MajorityWithOneOf.fromObject(object.majorityWithOneOf);
            }
            return message;
        };

        /**
         * Creates a plain object from a ValidationPolicy message. Also converts values to other types if specified.
         * @function toObject
         * @memberof wavesenterprise.ValidationPolicy
         * @static
         * @param {wavesenterprise.ValidationPolicy} message ValidationPolicy
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ValidationPolicy.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (message.any != null && message.hasOwnProperty("any")) {
                object.any = $root.wavesenterprise.ValidationPolicy.Any.toObject(message.any, options);
                if (options.oneofs)
                    object.type = "any";
            }
            if (message.majority != null && message.hasOwnProperty("majority")) {
                object.majority = $root.wavesenterprise.ValidationPolicy.Majority.toObject(message.majority, options);
                if (options.oneofs)
                    object.type = "majority";
            }
            if (message.majorityWithOneOf != null && message.hasOwnProperty("majorityWithOneOf")) {
                object.majorityWithOneOf = $root.wavesenterprise.ValidationPolicy.MajorityWithOneOf.toObject(message.majorityWithOneOf, options);
                if (options.oneofs)
                    object.type = "majorityWithOneOf";
            }
            return object;
        };

        /**
         * Converts this ValidationPolicy to JSON.
         * @function toJSON
         * @memberof wavesenterprise.ValidationPolicy
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ValidationPolicy.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        ValidationPolicy.Any = (function() {

            /**
             * Properties of an Any.
             * @memberof wavesenterprise.ValidationPolicy
             * @interface IAny
             */

            /**
             * Constructs a new Any.
             * @memberof wavesenterprise.ValidationPolicy
             * @classdesc Represents an Any.
             * @implements IAny
             * @constructor
             * @param {wavesenterprise.ValidationPolicy.IAny=} [properties] Properties to set
             */
            function Any(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new Any instance using the specified properties.
             * @function create
             * @memberof wavesenterprise.ValidationPolicy.Any
             * @static
             * @param {wavesenterprise.ValidationPolicy.IAny=} [properties] Properties to set
             * @returns {wavesenterprise.ValidationPolicy.Any} Any instance
             */
            Any.create = function create(properties) {
                return new Any(properties);
            };

            /**
             * Encodes the specified Any message. Does not implicitly {@link wavesenterprise.ValidationPolicy.Any.verify|verify} messages.
             * @function encode
             * @memberof wavesenterprise.ValidationPolicy.Any
             * @static
             * @param {wavesenterprise.ValidationPolicy.IAny} message Any message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Any.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified Any message, length delimited. Does not implicitly {@link wavesenterprise.ValidationPolicy.Any.verify|verify} messages.
             * @function encodeDelimited
             * @memberof wavesenterprise.ValidationPolicy.Any
             * @static
             * @param {wavesenterprise.ValidationPolicy.IAny} message Any message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Any.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Any message from the specified reader or buffer.
             * @function decode
             * @memberof wavesenterprise.ValidationPolicy.Any
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {wavesenterprise.ValidationPolicy.Any} Any
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Any.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.wavesenterprise.ValidationPolicy.Any();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Any message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof wavesenterprise.ValidationPolicy.Any
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {wavesenterprise.ValidationPolicy.Any} Any
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Any.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Any message.
             * @function verify
             * @memberof wavesenterprise.ValidationPolicy.Any
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Any.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates an Any message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof wavesenterprise.ValidationPolicy.Any
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {wavesenterprise.ValidationPolicy.Any} Any
             */
            Any.fromObject = function fromObject(object) {
                if (object instanceof $root.wavesenterprise.ValidationPolicy.Any)
                    return object;
                return new $root.wavesenterprise.ValidationPolicy.Any();
            };

            /**
             * Creates a plain object from an Any message. Also converts values to other types if specified.
             * @function toObject
             * @memberof wavesenterprise.ValidationPolicy.Any
             * @static
             * @param {wavesenterprise.ValidationPolicy.Any} message Any
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Any.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this Any to JSON.
             * @function toJSON
             * @memberof wavesenterprise.ValidationPolicy.Any
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Any.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Any;
        })();

        ValidationPolicy.Majority = (function() {

            /**
             * Properties of a Majority.
             * @memberof wavesenterprise.ValidationPolicy
             * @interface IMajority
             */

            /**
             * Constructs a new Majority.
             * @memberof wavesenterprise.ValidationPolicy
             * @classdesc Represents a Majority.
             * @implements IMajority
             * @constructor
             * @param {wavesenterprise.ValidationPolicy.IMajority=} [properties] Properties to set
             */
            function Majority(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new Majority instance using the specified properties.
             * @function create
             * @memberof wavesenterprise.ValidationPolicy.Majority
             * @static
             * @param {wavesenterprise.ValidationPolicy.IMajority=} [properties] Properties to set
             * @returns {wavesenterprise.ValidationPolicy.Majority} Majority instance
             */
            Majority.create = function create(properties) {
                return new Majority(properties);
            };

            /**
             * Encodes the specified Majority message. Does not implicitly {@link wavesenterprise.ValidationPolicy.Majority.verify|verify} messages.
             * @function encode
             * @memberof wavesenterprise.ValidationPolicy.Majority
             * @static
             * @param {wavesenterprise.ValidationPolicy.IMajority} message Majority message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Majority.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified Majority message, length delimited. Does not implicitly {@link wavesenterprise.ValidationPolicy.Majority.verify|verify} messages.
             * @function encodeDelimited
             * @memberof wavesenterprise.ValidationPolicy.Majority
             * @static
             * @param {wavesenterprise.ValidationPolicy.IMajority} message Majority message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Majority.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Majority message from the specified reader or buffer.
             * @function decode
             * @memberof wavesenterprise.ValidationPolicy.Majority
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {wavesenterprise.ValidationPolicy.Majority} Majority
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Majority.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.wavesenterprise.ValidationPolicy.Majority();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Majority message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof wavesenterprise.ValidationPolicy.Majority
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {wavesenterprise.ValidationPolicy.Majority} Majority
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Majority.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Majority message.
             * @function verify
             * @memberof wavesenterprise.ValidationPolicy.Majority
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Majority.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a Majority message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof wavesenterprise.ValidationPolicy.Majority
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {wavesenterprise.ValidationPolicy.Majority} Majority
             */
            Majority.fromObject = function fromObject(object) {
                if (object instanceof $root.wavesenterprise.ValidationPolicy.Majority)
                    return object;
                return new $root.wavesenterprise.ValidationPolicy.Majority();
            };

            /**
             * Creates a plain object from a Majority message. Also converts values to other types if specified.
             * @function toObject
             * @memberof wavesenterprise.ValidationPolicy.Majority
             * @static
             * @param {wavesenterprise.ValidationPolicy.Majority} message Majority
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Majority.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this Majority to JSON.
             * @function toJSON
             * @memberof wavesenterprise.ValidationPolicy.Majority
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Majority.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Majority;
        })();

        ValidationPolicy.MajorityWithOneOf = (function() {

            /**
             * Properties of a MajorityWithOneOf.
             * @memberof wavesenterprise.ValidationPolicy
             * @interface IMajorityWithOneOf
             * @property {Array.<Uint8Array>|null} [addresses] MajorityWithOneOf addresses
             */

            /**
             * Constructs a new MajorityWithOneOf.
             * @memberof wavesenterprise.ValidationPolicy
             * @classdesc Represents a MajorityWithOneOf.
             * @implements IMajorityWithOneOf
             * @constructor
             * @param {wavesenterprise.ValidationPolicy.IMajorityWithOneOf=} [properties] Properties to set
             */
            function MajorityWithOneOf(properties) {
                this.addresses = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MajorityWithOneOf addresses.
             * @member {Array.<Uint8Array>} addresses
             * @memberof wavesenterprise.ValidationPolicy.MajorityWithOneOf
             * @instance
             */
            MajorityWithOneOf.prototype.addresses = $util.emptyArray;

            /**
             * Creates a new MajorityWithOneOf instance using the specified properties.
             * @function create
             * @memberof wavesenterprise.ValidationPolicy.MajorityWithOneOf
             * @static
             * @param {wavesenterprise.ValidationPolicy.IMajorityWithOneOf=} [properties] Properties to set
             * @returns {wavesenterprise.ValidationPolicy.MajorityWithOneOf} MajorityWithOneOf instance
             */
            MajorityWithOneOf.create = function create(properties) {
                return new MajorityWithOneOf(properties);
            };

            /**
             * Encodes the specified MajorityWithOneOf message. Does not implicitly {@link wavesenterprise.ValidationPolicy.MajorityWithOneOf.verify|verify} messages.
             * @function encode
             * @memberof wavesenterprise.ValidationPolicy.MajorityWithOneOf
             * @static
             * @param {wavesenterprise.ValidationPolicy.IMajorityWithOneOf} message MajorityWithOneOf message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MajorityWithOneOf.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.addresses != null && message.addresses.length)
                    for (var i = 0; i < message.addresses.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.addresses[i]);
                return writer;
            };

            /**
             * Encodes the specified MajorityWithOneOf message, length delimited. Does not implicitly {@link wavesenterprise.ValidationPolicy.MajorityWithOneOf.verify|verify} messages.
             * @function encodeDelimited
             * @memberof wavesenterprise.ValidationPolicy.MajorityWithOneOf
             * @static
             * @param {wavesenterprise.ValidationPolicy.IMajorityWithOneOf} message MajorityWithOneOf message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MajorityWithOneOf.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MajorityWithOneOf message from the specified reader or buffer.
             * @function decode
             * @memberof wavesenterprise.ValidationPolicy.MajorityWithOneOf
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {wavesenterprise.ValidationPolicy.MajorityWithOneOf} MajorityWithOneOf
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MajorityWithOneOf.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.wavesenterprise.ValidationPolicy.MajorityWithOneOf();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.addresses && message.addresses.length))
                            message.addresses = [];
                        message.addresses.push(reader.bytes());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MajorityWithOneOf message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof wavesenterprise.ValidationPolicy.MajorityWithOneOf
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {wavesenterprise.ValidationPolicy.MajorityWithOneOf} MajorityWithOneOf
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MajorityWithOneOf.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MajorityWithOneOf message.
             * @function verify
             * @memberof wavesenterprise.ValidationPolicy.MajorityWithOneOf
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MajorityWithOneOf.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.addresses != null && message.hasOwnProperty("addresses")) {
                    if (!Array.isArray(message.addresses))
                        return "addresses: array expected";
                    for (var i = 0; i < message.addresses.length; ++i)
                        if (!(message.addresses[i] && typeof message.addresses[i].length === "number" || $util.isString(message.addresses[i])))
                            return "addresses: buffer[] expected";
                }
                return null;
            };

            /**
             * Creates a MajorityWithOneOf message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof wavesenterprise.ValidationPolicy.MajorityWithOneOf
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {wavesenterprise.ValidationPolicy.MajorityWithOneOf} MajorityWithOneOf
             */
            MajorityWithOneOf.fromObject = function fromObject(object) {
                if (object instanceof $root.wavesenterprise.ValidationPolicy.MajorityWithOneOf)
                    return object;
                var message = new $root.wavesenterprise.ValidationPolicy.MajorityWithOneOf();
                if (object.addresses) {
                    if (!Array.isArray(object.addresses))
                        throw TypeError(".wavesenterprise.ValidationPolicy.MajorityWithOneOf.addresses: array expected");
                    message.addresses = [];
                    for (var i = 0; i < object.addresses.length; ++i)
                        if (typeof object.addresses[i] === "string")
                            $util.base64.decode(object.addresses[i], message.addresses[i] = $util.newBuffer($util.base64.length(object.addresses[i])), 0);
                        else if (object.addresses[i].length)
                            message.addresses[i] = object.addresses[i];
                }
                return message;
            };

            /**
             * Creates a plain object from a MajorityWithOneOf message. Also converts values to other types if specified.
             * @function toObject
             * @memberof wavesenterprise.ValidationPolicy.MajorityWithOneOf
             * @static
             * @param {wavesenterprise.ValidationPolicy.MajorityWithOneOf} message MajorityWithOneOf
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MajorityWithOneOf.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.addresses = [];
                if (message.addresses && message.addresses.length) {
                    object.addresses = [];
                    for (var j = 0; j < message.addresses.length; ++j)
                        object.addresses[j] = options.bytes === String ? $util.base64.encode(message.addresses[j], 0, message.addresses[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.addresses[j]) : message.addresses[j];
                }
                return object;
            };

            /**
             * Converts this MajorityWithOneOf to JSON.
             * @function toJSON
             * @memberof wavesenterprise.ValidationPolicy.MajorityWithOneOf
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MajorityWithOneOf.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MajorityWithOneOf;
        })();

        return ValidationPolicy;
    })();

    wavesenterprise.CallContractTransaction = (function() {

        /**
         * Properties of a CallContractTransaction.
         * @memberof wavesenterprise
         * @interface ICallContractTransaction
         * @property {Uint8Array|null} [id] CallContractTransaction id
         * @property {Uint8Array|null} [senderPublicKey] CallContractTransaction senderPublicKey
         * @property {Uint8Array|null} [contractId] CallContractTransaction contractId
         * @property {Array.<wavesenterprise.IDataEntry>|null} [params] CallContractTransaction params
         * @property {number|Long|null} [fee] CallContractTransaction fee
         * @property {number|Long|null} [timestamp] CallContractTransaction timestamp
         * @property {number|null} [contractVersion] CallContractTransaction contractVersion
         * @property {google.protobuf.IBytesValue|null} [feeAssetId] CallContractTransaction feeAssetId
         * @property {wavesenterprise.IAtomicBadge|null} [atomicBadge] CallContractTransaction atomicBadge
         * @property {Array.<Uint8Array>|null} [proofs] CallContractTransaction proofs
         */

        /**
         * Constructs a new CallContractTransaction.
         * @memberof wavesenterprise
         * @classdesc Represents a CallContractTransaction.
         * @implements ICallContractTransaction
         * @constructor
         * @param {wavesenterprise.ICallContractTransaction=} [properties] Properties to set
         */
        function CallContractTransaction(properties) {
            this.params = [];
            this.proofs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CallContractTransaction id.
         * @member {Uint8Array} id
         * @memberof wavesenterprise.CallContractTransaction
         * @instance
         */
        CallContractTransaction.prototype.id = $util.newBuffer([]);

        /**
         * CallContractTransaction senderPublicKey.
         * @member {Uint8Array} senderPublicKey
         * @memberof wavesenterprise.CallContractTransaction
         * @instance
         */
        CallContractTransaction.prototype.senderPublicKey = $util.newBuffer([]);

        /**
         * CallContractTransaction contractId.
         * @member {Uint8Array} contractId
         * @memberof wavesenterprise.CallContractTransaction
         * @instance
         */
        CallContractTransaction.prototype.contractId = $util.newBuffer([]);

        /**
         * CallContractTransaction params.
         * @member {Array.<wavesenterprise.IDataEntry>} params
         * @memberof wavesenterprise.CallContractTransaction
         * @instance
         */
        CallContractTransaction.prototype.params = $util.emptyArray;

        /**
         * CallContractTransaction fee.
         * @member {number|Long} fee
         * @memberof wavesenterprise.CallContractTransaction
         * @instance
         */
        CallContractTransaction.prototype.fee = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * CallContractTransaction timestamp.
         * @member {number|Long} timestamp
         * @memberof wavesenterprise.CallContractTransaction
         * @instance
         */
        CallContractTransaction.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * CallContractTransaction contractVersion.
         * @member {number} contractVersion
         * @memberof wavesenterprise.CallContractTransaction
         * @instance
         */
        CallContractTransaction.prototype.contractVersion = 0;

        /**
         * CallContractTransaction feeAssetId.
         * @member {google.protobuf.IBytesValue|null|undefined} feeAssetId
         * @memberof wavesenterprise.CallContractTransaction
         * @instance
         */
        CallContractTransaction.prototype.feeAssetId = null;

        /**
         * CallContractTransaction atomicBadge.
         * @member {wavesenterprise.IAtomicBadge|null|undefined} atomicBadge
         * @memberof wavesenterprise.CallContractTransaction
         * @instance
         */
        CallContractTransaction.prototype.atomicBadge = null;

        /**
         * CallContractTransaction proofs.
         * @member {Array.<Uint8Array>} proofs
         * @memberof wavesenterprise.CallContractTransaction
         * @instance
         */
        CallContractTransaction.prototype.proofs = $util.emptyArray;

        /**
         * Creates a new CallContractTransaction instance using the specified properties.
         * @function create
         * @memberof wavesenterprise.CallContractTransaction
         * @static
         * @param {wavesenterprise.ICallContractTransaction=} [properties] Properties to set
         * @returns {wavesenterprise.CallContractTransaction} CallContractTransaction instance
         */
        CallContractTransaction.create = function create(properties) {
            return new CallContractTransaction(properties);
        };

        /**
         * Encodes the specified CallContractTransaction message. Does not implicitly {@link wavesenterprise.CallContractTransaction.verify|verify} messages.
         * @function encode
         * @memberof wavesenterprise.CallContractTransaction
         * @static
         * @param {wavesenterprise.ICallContractTransaction} message CallContractTransaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CallContractTransaction.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.id);
            if (message.senderPublicKey != null && Object.hasOwnProperty.call(message, "senderPublicKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.senderPublicKey);
            if (message.contractId != null && Object.hasOwnProperty.call(message, "contractId"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.contractId);
            if (message.params != null && message.params.length)
                for (var i = 0; i < message.params.length; ++i)
                    $root.wavesenterprise.DataEntry.encode(message.params[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.fee != null && Object.hasOwnProperty.call(message, "fee"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.fee);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.timestamp);
            if (message.contractVersion != null && Object.hasOwnProperty.call(message, "contractVersion"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.contractVersion);
            if (message.feeAssetId != null && Object.hasOwnProperty.call(message, "feeAssetId"))
                $root.google.protobuf.BytesValue.encode(message.feeAssetId, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.atomicBadge != null && Object.hasOwnProperty.call(message, "atomicBadge"))
                $root.wavesenterprise.AtomicBadge.encode(message.atomicBadge, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.proofs != null && message.proofs.length)
                for (var i = 0; i < message.proofs.length; ++i)
                    writer.uint32(/* id 10, wireType 2 =*/82).bytes(message.proofs[i]);
            return writer;
        };

        /**
         * Encodes the specified CallContractTransaction message, length delimited. Does not implicitly {@link wavesenterprise.CallContractTransaction.verify|verify} messages.
         * @function encodeDelimited
         * @memberof wavesenterprise.CallContractTransaction
         * @static
         * @param {wavesenterprise.ICallContractTransaction} message CallContractTransaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CallContractTransaction.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CallContractTransaction message from the specified reader or buffer.
         * @function decode
         * @memberof wavesenterprise.CallContractTransaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {wavesenterprise.CallContractTransaction} CallContractTransaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CallContractTransaction.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.wavesenterprise.CallContractTransaction();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.bytes();
                    break;
                case 2:
                    message.senderPublicKey = reader.bytes();
                    break;
                case 3:
                    message.contractId = reader.bytes();
                    break;
                case 4:
                    if (!(message.params && message.params.length))
                        message.params = [];
                    message.params.push($root.wavesenterprise.DataEntry.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.fee = reader.int64();
                    break;
                case 6:
                    message.timestamp = reader.int64();
                    break;
                case 7:
                    message.contractVersion = reader.int32();
                    break;
                case 8:
                    message.feeAssetId = $root.google.protobuf.BytesValue.decode(reader, reader.uint32());
                    break;
                case 9:
                    message.atomicBadge = $root.wavesenterprise.AtomicBadge.decode(reader, reader.uint32());
                    break;
                case 10:
                    if (!(message.proofs && message.proofs.length))
                        message.proofs = [];
                    message.proofs.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CallContractTransaction message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof wavesenterprise.CallContractTransaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {wavesenterprise.CallContractTransaction} CallContractTransaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CallContractTransaction.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CallContractTransaction message.
         * @function verify
         * @memberof wavesenterprise.CallContractTransaction
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CallContractTransaction.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!(message.id && typeof message.id.length === "number" || $util.isString(message.id)))
                    return "id: buffer expected";
            if (message.senderPublicKey != null && message.hasOwnProperty("senderPublicKey"))
                if (!(message.senderPublicKey && typeof message.senderPublicKey.length === "number" || $util.isString(message.senderPublicKey)))
                    return "senderPublicKey: buffer expected";
            if (message.contractId != null && message.hasOwnProperty("contractId"))
                if (!(message.contractId && typeof message.contractId.length === "number" || $util.isString(message.contractId)))
                    return "contractId: buffer expected";
            if (message.params != null && message.hasOwnProperty("params")) {
                if (!Array.isArray(message.params))
                    return "params: array expected";
                for (var i = 0; i < message.params.length; ++i) {
                    var error = $root.wavesenterprise.DataEntry.verify(message.params[i]);
                    if (error)
                        return "params." + error;
                }
            }
            if (message.fee != null && message.hasOwnProperty("fee"))
                if (!$util.isInteger(message.fee) && !(message.fee && $util.isInteger(message.fee.low) && $util.isInteger(message.fee.high)))
                    return "fee: integer|Long expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            if (message.contractVersion != null && message.hasOwnProperty("contractVersion"))
                if (!$util.isInteger(message.contractVersion))
                    return "contractVersion: integer expected";
            if (message.feeAssetId != null && message.hasOwnProperty("feeAssetId")) {
                var error = $root.google.protobuf.BytesValue.verify(message.feeAssetId);
                if (error)
                    return "feeAssetId." + error;
            }
            if (message.atomicBadge != null && message.hasOwnProperty("atomicBadge")) {
                var error = $root.wavesenterprise.AtomicBadge.verify(message.atomicBadge);
                if (error)
                    return "atomicBadge." + error;
            }
            if (message.proofs != null && message.hasOwnProperty("proofs")) {
                if (!Array.isArray(message.proofs))
                    return "proofs: array expected";
                for (var i = 0; i < message.proofs.length; ++i)
                    if (!(message.proofs[i] && typeof message.proofs[i].length === "number" || $util.isString(message.proofs[i])))
                        return "proofs: buffer[] expected";
            }
            return null;
        };

        /**
         * Creates a CallContractTransaction message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof wavesenterprise.CallContractTransaction
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {wavesenterprise.CallContractTransaction} CallContractTransaction
         */
        CallContractTransaction.fromObject = function fromObject(object) {
            if (object instanceof $root.wavesenterprise.CallContractTransaction)
                return object;
            var message = new $root.wavesenterprise.CallContractTransaction();
            if (object.id != null)
                if (typeof object.id === "string")
                    $util.base64.decode(object.id, message.id = $util.newBuffer($util.base64.length(object.id)), 0);
                else if (object.id.length)
                    message.id = object.id;
            if (object.senderPublicKey != null)
                if (typeof object.senderPublicKey === "string")
                    $util.base64.decode(object.senderPublicKey, message.senderPublicKey = $util.newBuffer($util.base64.length(object.senderPublicKey)), 0);
                else if (object.senderPublicKey.length)
                    message.senderPublicKey = object.senderPublicKey;
            if (object.contractId != null)
                if (typeof object.contractId === "string")
                    $util.base64.decode(object.contractId, message.contractId = $util.newBuffer($util.base64.length(object.contractId)), 0);
                else if (object.contractId.length)
                    message.contractId = object.contractId;
            if (object.params) {
                if (!Array.isArray(object.params))
                    throw TypeError(".wavesenterprise.CallContractTransaction.params: array expected");
                message.params = [];
                for (var i = 0; i < object.params.length; ++i) {
                    if (typeof object.params[i] !== "object")
                        throw TypeError(".wavesenterprise.CallContractTransaction.params: object expected");
                    message.params[i] = $root.wavesenterprise.DataEntry.fromObject(object.params[i]);
                }
            }
            if (object.fee != null)
                if ($util.Long)
                    (message.fee = $util.Long.fromValue(object.fee)).unsigned = false;
                else if (typeof object.fee === "string")
                    message.fee = parseInt(object.fee, 10);
                else if (typeof object.fee === "number")
                    message.fee = object.fee;
                else if (typeof object.fee === "object")
                    message.fee = new $util.LongBits(object.fee.low >>> 0, object.fee.high >>> 0).toNumber();
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            if (object.contractVersion != null)
                message.contractVersion = object.contractVersion | 0;
            if (object.feeAssetId != null) {
                if (typeof object.feeAssetId !== "object")
                    throw TypeError(".wavesenterprise.CallContractTransaction.feeAssetId: object expected");
                message.feeAssetId = $root.google.protobuf.BytesValue.fromObject(object.feeAssetId);
            }
            if (object.atomicBadge != null) {
                if (typeof object.atomicBadge !== "object")
                    throw TypeError(".wavesenterprise.CallContractTransaction.atomicBadge: object expected");
                message.atomicBadge = $root.wavesenterprise.AtomicBadge.fromObject(object.atomicBadge);
            }
            if (object.proofs) {
                if (!Array.isArray(object.proofs))
                    throw TypeError(".wavesenterprise.CallContractTransaction.proofs: array expected");
                message.proofs = [];
                for (var i = 0; i < object.proofs.length; ++i)
                    if (typeof object.proofs[i] === "string")
                        $util.base64.decode(object.proofs[i], message.proofs[i] = $util.newBuffer($util.base64.length(object.proofs[i])), 0);
                    else if (object.proofs[i].length)
                        message.proofs[i] = object.proofs[i];
            }
            return message;
        };

        /**
         * Creates a plain object from a CallContractTransaction message. Also converts values to other types if specified.
         * @function toObject
         * @memberof wavesenterprise.CallContractTransaction
         * @static
         * @param {wavesenterprise.CallContractTransaction} message CallContractTransaction
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CallContractTransaction.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.params = [];
                object.proofs = [];
            }
            if (options.defaults) {
                if (options.bytes === String)
                    object.id = "";
                else {
                    object.id = [];
                    if (options.bytes !== Array)
                        object.id = $util.newBuffer(object.id);
                }
                if (options.bytes === String)
                    object.senderPublicKey = "";
                else {
                    object.senderPublicKey = [];
                    if (options.bytes !== Array)
                        object.senderPublicKey = $util.newBuffer(object.senderPublicKey);
                }
                if (options.bytes === String)
                    object.contractId = "";
                else {
                    object.contractId = [];
                    if (options.bytes !== Array)
                        object.contractId = $util.newBuffer(object.contractId);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.fee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.fee = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
                object.contractVersion = 0;
                object.feeAssetId = null;
                object.atomicBadge = null;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = options.bytes === String ? $util.base64.encode(message.id, 0, message.id.length) : options.bytes === Array ? Array.prototype.slice.call(message.id) : message.id;
            if (message.senderPublicKey != null && message.hasOwnProperty("senderPublicKey"))
                object.senderPublicKey = options.bytes === String ? $util.base64.encode(message.senderPublicKey, 0, message.senderPublicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.senderPublicKey) : message.senderPublicKey;
            if (message.contractId != null && message.hasOwnProperty("contractId"))
                object.contractId = options.bytes === String ? $util.base64.encode(message.contractId, 0, message.contractId.length) : options.bytes === Array ? Array.prototype.slice.call(message.contractId) : message.contractId;
            if (message.params && message.params.length) {
                object.params = [];
                for (var j = 0; j < message.params.length; ++j)
                    object.params[j] = $root.wavesenterprise.DataEntry.toObject(message.params[j], options);
            }
            if (message.fee != null && message.hasOwnProperty("fee"))
                if (typeof message.fee === "number")
                    object.fee = options.longs === String ? String(message.fee) : message.fee;
                else
                    object.fee = options.longs === String ? $util.Long.prototype.toString.call(message.fee) : options.longs === Number ? new $util.LongBits(message.fee.low >>> 0, message.fee.high >>> 0).toNumber() : message.fee;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            if (message.contractVersion != null && message.hasOwnProperty("contractVersion"))
                object.contractVersion = message.contractVersion;
            if (message.feeAssetId != null && message.hasOwnProperty("feeAssetId"))
                object.feeAssetId = $root.google.protobuf.BytesValue.toObject(message.feeAssetId, options);
            if (message.atomicBadge != null && message.hasOwnProperty("atomicBadge"))
                object.atomicBadge = $root.wavesenterprise.AtomicBadge.toObject(message.atomicBadge, options);
            if (message.proofs && message.proofs.length) {
                object.proofs = [];
                for (var j = 0; j < message.proofs.length; ++j)
                    object.proofs[j] = options.bytes === String ? $util.base64.encode(message.proofs[j], 0, message.proofs[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.proofs[j]) : message.proofs[j];
            }
            return object;
        };

        /**
         * Converts this CallContractTransaction to JSON.
         * @function toJSON
         * @memberof wavesenterprise.CallContractTransaction
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CallContractTransaction.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CallContractTransaction;
    })();

    wavesenterprise.ExecutedContractTransaction = (function() {

        /**
         * Properties of an ExecutedContractTransaction.
         * @memberof wavesenterprise
         * @interface IExecutedContractTransaction
         * @property {Uint8Array|null} [id] ExecutedContractTransaction id
         * @property {Uint8Array|null} [senderPublicKey] ExecutedContractTransaction senderPublicKey
         * @property {wavesenterprise.IExecutableTransaction|null} [tx] ExecutedContractTransaction tx
         * @property {Array.<wavesenterprise.IDataEntry>|null} [results] ExecutedContractTransaction results
         * @property {Uint8Array|null} [resultsHash] ExecutedContractTransaction resultsHash
         * @property {Array.<wavesenterprise.IValidationProof>|null} [validationProofs] ExecutedContractTransaction validationProofs
         * @property {number|Long|null} [timestamp] ExecutedContractTransaction timestamp
         * @property {Array.<Uint8Array>|null} [proofs] ExecutedContractTransaction proofs
         */

        /**
         * Constructs a new ExecutedContractTransaction.
         * @memberof wavesenterprise
         * @classdesc Represents an ExecutedContractTransaction.
         * @implements IExecutedContractTransaction
         * @constructor
         * @param {wavesenterprise.IExecutedContractTransaction=} [properties] Properties to set
         */
        function ExecutedContractTransaction(properties) {
            this.results = [];
            this.validationProofs = [];
            this.proofs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExecutedContractTransaction id.
         * @member {Uint8Array} id
         * @memberof wavesenterprise.ExecutedContractTransaction
         * @instance
         */
        ExecutedContractTransaction.prototype.id = $util.newBuffer([]);

        /**
         * ExecutedContractTransaction senderPublicKey.
         * @member {Uint8Array} senderPublicKey
         * @memberof wavesenterprise.ExecutedContractTransaction
         * @instance
         */
        ExecutedContractTransaction.prototype.senderPublicKey = $util.newBuffer([]);

        /**
         * ExecutedContractTransaction tx.
         * @member {wavesenterprise.IExecutableTransaction|null|undefined} tx
         * @memberof wavesenterprise.ExecutedContractTransaction
         * @instance
         */
        ExecutedContractTransaction.prototype.tx = null;

        /**
         * ExecutedContractTransaction results.
         * @member {Array.<wavesenterprise.IDataEntry>} results
         * @memberof wavesenterprise.ExecutedContractTransaction
         * @instance
         */
        ExecutedContractTransaction.prototype.results = $util.emptyArray;

        /**
         * ExecutedContractTransaction resultsHash.
         * @member {Uint8Array} resultsHash
         * @memberof wavesenterprise.ExecutedContractTransaction
         * @instance
         */
        ExecutedContractTransaction.prototype.resultsHash = $util.newBuffer([]);

        /**
         * ExecutedContractTransaction validationProofs.
         * @member {Array.<wavesenterprise.IValidationProof>} validationProofs
         * @memberof wavesenterprise.ExecutedContractTransaction
         * @instance
         */
        ExecutedContractTransaction.prototype.validationProofs = $util.emptyArray;

        /**
         * ExecutedContractTransaction timestamp.
         * @member {number|Long} timestamp
         * @memberof wavesenterprise.ExecutedContractTransaction
         * @instance
         */
        ExecutedContractTransaction.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ExecutedContractTransaction proofs.
         * @member {Array.<Uint8Array>} proofs
         * @memberof wavesenterprise.ExecutedContractTransaction
         * @instance
         */
        ExecutedContractTransaction.prototype.proofs = $util.emptyArray;

        /**
         * Creates a new ExecutedContractTransaction instance using the specified properties.
         * @function create
         * @memberof wavesenterprise.ExecutedContractTransaction
         * @static
         * @param {wavesenterprise.IExecutedContractTransaction=} [properties] Properties to set
         * @returns {wavesenterprise.ExecutedContractTransaction} ExecutedContractTransaction instance
         */
        ExecutedContractTransaction.create = function create(properties) {
            return new ExecutedContractTransaction(properties);
        };

        /**
         * Encodes the specified ExecutedContractTransaction message. Does not implicitly {@link wavesenterprise.ExecutedContractTransaction.verify|verify} messages.
         * @function encode
         * @memberof wavesenterprise.ExecutedContractTransaction
         * @static
         * @param {wavesenterprise.IExecutedContractTransaction} message ExecutedContractTransaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExecutedContractTransaction.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.id);
            if (message.senderPublicKey != null && Object.hasOwnProperty.call(message, "senderPublicKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.senderPublicKey);
            if (message.tx != null && Object.hasOwnProperty.call(message, "tx"))
                $root.wavesenterprise.ExecutableTransaction.encode(message.tx, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.results != null && message.results.length)
                for (var i = 0; i < message.results.length; ++i)
                    $root.wavesenterprise.DataEntry.encode(message.results[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.resultsHash != null && Object.hasOwnProperty.call(message, "resultsHash"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.resultsHash);
            if (message.validationProofs != null && message.validationProofs.length)
                for (var i = 0; i < message.validationProofs.length; ++i)
                    $root.wavesenterprise.ValidationProof.encode(message.validationProofs[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.timestamp);
            if (message.proofs != null && message.proofs.length)
                for (var i = 0; i < message.proofs.length; ++i)
                    writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.proofs[i]);
            return writer;
        };

        /**
         * Encodes the specified ExecutedContractTransaction message, length delimited. Does not implicitly {@link wavesenterprise.ExecutedContractTransaction.verify|verify} messages.
         * @function encodeDelimited
         * @memberof wavesenterprise.ExecutedContractTransaction
         * @static
         * @param {wavesenterprise.IExecutedContractTransaction} message ExecutedContractTransaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExecutedContractTransaction.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExecutedContractTransaction message from the specified reader or buffer.
         * @function decode
         * @memberof wavesenterprise.ExecutedContractTransaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {wavesenterprise.ExecutedContractTransaction} ExecutedContractTransaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExecutedContractTransaction.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.wavesenterprise.ExecutedContractTransaction();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.bytes();
                    break;
                case 2:
                    message.senderPublicKey = reader.bytes();
                    break;
                case 3:
                    message.tx = $root.wavesenterprise.ExecutableTransaction.decode(reader, reader.uint32());
                    break;
                case 4:
                    if (!(message.results && message.results.length))
                        message.results = [];
                    message.results.push($root.wavesenterprise.DataEntry.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.resultsHash = reader.bytes();
                    break;
                case 6:
                    if (!(message.validationProofs && message.validationProofs.length))
                        message.validationProofs = [];
                    message.validationProofs.push($root.wavesenterprise.ValidationProof.decode(reader, reader.uint32()));
                    break;
                case 7:
                    message.timestamp = reader.int64();
                    break;
                case 8:
                    if (!(message.proofs && message.proofs.length))
                        message.proofs = [];
                    message.proofs.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExecutedContractTransaction message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof wavesenterprise.ExecutedContractTransaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {wavesenterprise.ExecutedContractTransaction} ExecutedContractTransaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExecutedContractTransaction.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExecutedContractTransaction message.
         * @function verify
         * @memberof wavesenterprise.ExecutedContractTransaction
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExecutedContractTransaction.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!(message.id && typeof message.id.length === "number" || $util.isString(message.id)))
                    return "id: buffer expected";
            if (message.senderPublicKey != null && message.hasOwnProperty("senderPublicKey"))
                if (!(message.senderPublicKey && typeof message.senderPublicKey.length === "number" || $util.isString(message.senderPublicKey)))
                    return "senderPublicKey: buffer expected";
            if (message.tx != null && message.hasOwnProperty("tx")) {
                var error = $root.wavesenterprise.ExecutableTransaction.verify(message.tx);
                if (error)
                    return "tx." + error;
            }
            if (message.results != null && message.hasOwnProperty("results")) {
                if (!Array.isArray(message.results))
                    return "results: array expected";
                for (var i = 0; i < message.results.length; ++i) {
                    var error = $root.wavesenterprise.DataEntry.verify(message.results[i]);
                    if (error)
                        return "results." + error;
                }
            }
            if (message.resultsHash != null && message.hasOwnProperty("resultsHash"))
                if (!(message.resultsHash && typeof message.resultsHash.length === "number" || $util.isString(message.resultsHash)))
                    return "resultsHash: buffer expected";
            if (message.validationProofs != null && message.hasOwnProperty("validationProofs")) {
                if (!Array.isArray(message.validationProofs))
                    return "validationProofs: array expected";
                for (var i = 0; i < message.validationProofs.length; ++i) {
                    var error = $root.wavesenterprise.ValidationProof.verify(message.validationProofs[i]);
                    if (error)
                        return "validationProofs." + error;
                }
            }
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            if (message.proofs != null && message.hasOwnProperty("proofs")) {
                if (!Array.isArray(message.proofs))
                    return "proofs: array expected";
                for (var i = 0; i < message.proofs.length; ++i)
                    if (!(message.proofs[i] && typeof message.proofs[i].length === "number" || $util.isString(message.proofs[i])))
                        return "proofs: buffer[] expected";
            }
            return null;
        };

        /**
         * Creates an ExecutedContractTransaction message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof wavesenterprise.ExecutedContractTransaction
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {wavesenterprise.ExecutedContractTransaction} ExecutedContractTransaction
         */
        ExecutedContractTransaction.fromObject = function fromObject(object) {
            if (object instanceof $root.wavesenterprise.ExecutedContractTransaction)
                return object;
            var message = new $root.wavesenterprise.ExecutedContractTransaction();
            if (object.id != null)
                if (typeof object.id === "string")
                    $util.base64.decode(object.id, message.id = $util.newBuffer($util.base64.length(object.id)), 0);
                else if (object.id.length)
                    message.id = object.id;
            if (object.senderPublicKey != null)
                if (typeof object.senderPublicKey === "string")
                    $util.base64.decode(object.senderPublicKey, message.senderPublicKey = $util.newBuffer($util.base64.length(object.senderPublicKey)), 0);
                else if (object.senderPublicKey.length)
                    message.senderPublicKey = object.senderPublicKey;
            if (object.tx != null) {
                if (typeof object.tx !== "object")
                    throw TypeError(".wavesenterprise.ExecutedContractTransaction.tx: object expected");
                message.tx = $root.wavesenterprise.ExecutableTransaction.fromObject(object.tx);
            }
            if (object.results) {
                if (!Array.isArray(object.results))
                    throw TypeError(".wavesenterprise.ExecutedContractTransaction.results: array expected");
                message.results = [];
                for (var i = 0; i < object.results.length; ++i) {
                    if (typeof object.results[i] !== "object")
                        throw TypeError(".wavesenterprise.ExecutedContractTransaction.results: object expected");
                    message.results[i] = $root.wavesenterprise.DataEntry.fromObject(object.results[i]);
                }
            }
            if (object.resultsHash != null)
                if (typeof object.resultsHash === "string")
                    $util.base64.decode(object.resultsHash, message.resultsHash = $util.newBuffer($util.base64.length(object.resultsHash)), 0);
                else if (object.resultsHash.length)
                    message.resultsHash = object.resultsHash;
            if (object.validationProofs) {
                if (!Array.isArray(object.validationProofs))
                    throw TypeError(".wavesenterprise.ExecutedContractTransaction.validationProofs: array expected");
                message.validationProofs = [];
                for (var i = 0; i < object.validationProofs.length; ++i) {
                    if (typeof object.validationProofs[i] !== "object")
                        throw TypeError(".wavesenterprise.ExecutedContractTransaction.validationProofs: object expected");
                    message.validationProofs[i] = $root.wavesenterprise.ValidationProof.fromObject(object.validationProofs[i]);
                }
            }
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            if (object.proofs) {
                if (!Array.isArray(object.proofs))
                    throw TypeError(".wavesenterprise.ExecutedContractTransaction.proofs: array expected");
                message.proofs = [];
                for (var i = 0; i < object.proofs.length; ++i)
                    if (typeof object.proofs[i] === "string")
                        $util.base64.decode(object.proofs[i], message.proofs[i] = $util.newBuffer($util.base64.length(object.proofs[i])), 0);
                    else if (object.proofs[i].length)
                        message.proofs[i] = object.proofs[i];
            }
            return message;
        };

        /**
         * Creates a plain object from an ExecutedContractTransaction message. Also converts values to other types if specified.
         * @function toObject
         * @memberof wavesenterprise.ExecutedContractTransaction
         * @static
         * @param {wavesenterprise.ExecutedContractTransaction} message ExecutedContractTransaction
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExecutedContractTransaction.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.results = [];
                object.validationProofs = [];
                object.proofs = [];
            }
            if (options.defaults) {
                if (options.bytes === String)
                    object.id = "";
                else {
                    object.id = [];
                    if (options.bytes !== Array)
                        object.id = $util.newBuffer(object.id);
                }
                if (options.bytes === String)
                    object.senderPublicKey = "";
                else {
                    object.senderPublicKey = [];
                    if (options.bytes !== Array)
                        object.senderPublicKey = $util.newBuffer(object.senderPublicKey);
                }
                object.tx = null;
                if (options.bytes === String)
                    object.resultsHash = "";
                else {
                    object.resultsHash = [];
                    if (options.bytes !== Array)
                        object.resultsHash = $util.newBuffer(object.resultsHash);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = options.bytes === String ? $util.base64.encode(message.id, 0, message.id.length) : options.bytes === Array ? Array.prototype.slice.call(message.id) : message.id;
            if (message.senderPublicKey != null && message.hasOwnProperty("senderPublicKey"))
                object.senderPublicKey = options.bytes === String ? $util.base64.encode(message.senderPublicKey, 0, message.senderPublicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.senderPublicKey) : message.senderPublicKey;
            if (message.tx != null && message.hasOwnProperty("tx"))
                object.tx = $root.wavesenterprise.ExecutableTransaction.toObject(message.tx, options);
            if (message.results && message.results.length) {
                object.results = [];
                for (var j = 0; j < message.results.length; ++j)
                    object.results[j] = $root.wavesenterprise.DataEntry.toObject(message.results[j], options);
            }
            if (message.resultsHash != null && message.hasOwnProperty("resultsHash"))
                object.resultsHash = options.bytes === String ? $util.base64.encode(message.resultsHash, 0, message.resultsHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.resultsHash) : message.resultsHash;
            if (message.validationProofs && message.validationProofs.length) {
                object.validationProofs = [];
                for (var j = 0; j < message.validationProofs.length; ++j)
                    object.validationProofs[j] = $root.wavesenterprise.ValidationProof.toObject(message.validationProofs[j], options);
            }
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            if (message.proofs && message.proofs.length) {
                object.proofs = [];
                for (var j = 0; j < message.proofs.length; ++j)
                    object.proofs[j] = options.bytes === String ? $util.base64.encode(message.proofs[j], 0, message.proofs[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.proofs[j]) : message.proofs[j];
            }
            return object;
        };

        /**
         * Converts this ExecutedContractTransaction to JSON.
         * @function toJSON
         * @memberof wavesenterprise.ExecutedContractTransaction
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExecutedContractTransaction.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ExecutedContractTransaction;
    })();

    wavesenterprise.ExecutableTransaction = (function() {

        /**
         * Properties of an ExecutableTransaction.
         * @memberof wavesenterprise
         * @interface IExecutableTransaction
         * @property {number|null} [version] ExecutableTransaction version
         * @property {wavesenterprise.ICreateContractTransaction|null} [createContractTransaction] ExecutableTransaction createContractTransaction
         * @property {wavesenterprise.ICallContractTransaction|null} [callContractTransaction] ExecutableTransaction callContractTransaction
         * @property {wavesenterprise.IUpdateContractTransaction|null} [updateContractTransaction] ExecutableTransaction updateContractTransaction
         */

        /**
         * Constructs a new ExecutableTransaction.
         * @memberof wavesenterprise
         * @classdesc Represents an ExecutableTransaction.
         * @implements IExecutableTransaction
         * @constructor
         * @param {wavesenterprise.IExecutableTransaction=} [properties] Properties to set
         */
        function ExecutableTransaction(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExecutableTransaction version.
         * @member {number} version
         * @memberof wavesenterprise.ExecutableTransaction
         * @instance
         */
        ExecutableTransaction.prototype.version = 0;

        /**
         * ExecutableTransaction createContractTransaction.
         * @member {wavesenterprise.ICreateContractTransaction|null|undefined} createContractTransaction
         * @memberof wavesenterprise.ExecutableTransaction
         * @instance
         */
        ExecutableTransaction.prototype.createContractTransaction = null;

        /**
         * ExecutableTransaction callContractTransaction.
         * @member {wavesenterprise.ICallContractTransaction|null|undefined} callContractTransaction
         * @memberof wavesenterprise.ExecutableTransaction
         * @instance
         */
        ExecutableTransaction.prototype.callContractTransaction = null;

        /**
         * ExecutableTransaction updateContractTransaction.
         * @member {wavesenterprise.IUpdateContractTransaction|null|undefined} updateContractTransaction
         * @memberof wavesenterprise.ExecutableTransaction
         * @instance
         */
        ExecutableTransaction.prototype.updateContractTransaction = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * ExecutableTransaction transaction.
         * @member {"createContractTransaction"|"callContractTransaction"|"updateContractTransaction"|undefined} transaction
         * @memberof wavesenterprise.ExecutableTransaction
         * @instance
         */
        Object.defineProperty(ExecutableTransaction.prototype, "transaction", {
            get: $util.oneOfGetter($oneOfFields = ["createContractTransaction", "callContractTransaction", "updateContractTransaction"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new ExecutableTransaction instance using the specified properties.
         * @function create
         * @memberof wavesenterprise.ExecutableTransaction
         * @static
         * @param {wavesenterprise.IExecutableTransaction=} [properties] Properties to set
         * @returns {wavesenterprise.ExecutableTransaction} ExecutableTransaction instance
         */
        ExecutableTransaction.create = function create(properties) {
            return new ExecutableTransaction(properties);
        };

        /**
         * Encodes the specified ExecutableTransaction message. Does not implicitly {@link wavesenterprise.ExecutableTransaction.verify|verify} messages.
         * @function encode
         * @memberof wavesenterprise.ExecutableTransaction
         * @static
         * @param {wavesenterprise.IExecutableTransaction} message ExecutableTransaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExecutableTransaction.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.version);
            if (message.createContractTransaction != null && Object.hasOwnProperty.call(message, "createContractTransaction"))
                $root.wavesenterprise.CreateContractTransaction.encode(message.createContractTransaction, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
            if (message.callContractTransaction != null && Object.hasOwnProperty.call(message, "callContractTransaction"))
                $root.wavesenterprise.CallContractTransaction.encode(message.callContractTransaction, writer.uint32(/* id 1001, wireType 2 =*/8010).fork()).ldelim();
            if (message.updateContractTransaction != null && Object.hasOwnProperty.call(message, "updateContractTransaction"))
                $root.wavesenterprise.UpdateContractTransaction.encode(message.updateContractTransaction, writer.uint32(/* id 1002, wireType 2 =*/8018).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ExecutableTransaction message, length delimited. Does not implicitly {@link wavesenterprise.ExecutableTransaction.verify|verify} messages.
         * @function encodeDelimited
         * @memberof wavesenterprise.ExecutableTransaction
         * @static
         * @param {wavesenterprise.IExecutableTransaction} message ExecutableTransaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExecutableTransaction.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExecutableTransaction message from the specified reader or buffer.
         * @function decode
         * @memberof wavesenterprise.ExecutableTransaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {wavesenterprise.ExecutableTransaction} ExecutableTransaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExecutableTransaction.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.wavesenterprise.ExecutableTransaction();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.version = reader.int32();
                    break;
                case 1000:
                    message.createContractTransaction = $root.wavesenterprise.CreateContractTransaction.decode(reader, reader.uint32());
                    break;
                case 1001:
                    message.callContractTransaction = $root.wavesenterprise.CallContractTransaction.decode(reader, reader.uint32());
                    break;
                case 1002:
                    message.updateContractTransaction = $root.wavesenterprise.UpdateContractTransaction.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExecutableTransaction message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof wavesenterprise.ExecutableTransaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {wavesenterprise.ExecutableTransaction} ExecutableTransaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExecutableTransaction.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExecutableTransaction message.
         * @function verify
         * @memberof wavesenterprise.ExecutableTransaction
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExecutableTransaction.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isInteger(message.version))
                    return "version: integer expected";
            if (message.createContractTransaction != null && message.hasOwnProperty("createContractTransaction")) {
                properties.transaction = 1;
                {
                    var error = $root.wavesenterprise.CreateContractTransaction.verify(message.createContractTransaction);
                    if (error)
                        return "createContractTransaction." + error;
                }
            }
            if (message.callContractTransaction != null && message.hasOwnProperty("callContractTransaction")) {
                if (properties.transaction === 1)
                    return "transaction: multiple values";
                properties.transaction = 1;
                {
                    var error = $root.wavesenterprise.CallContractTransaction.verify(message.callContractTransaction);
                    if (error)
                        return "callContractTransaction." + error;
                }
            }
            if (message.updateContractTransaction != null && message.hasOwnProperty("updateContractTransaction")) {
                if (properties.transaction === 1)
                    return "transaction: multiple values";
                properties.transaction = 1;
                {
                    var error = $root.wavesenterprise.UpdateContractTransaction.verify(message.updateContractTransaction);
                    if (error)
                        return "updateContractTransaction." + error;
                }
            }
            return null;
        };

        /**
         * Creates an ExecutableTransaction message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof wavesenterprise.ExecutableTransaction
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {wavesenterprise.ExecutableTransaction} ExecutableTransaction
         */
        ExecutableTransaction.fromObject = function fromObject(object) {
            if (object instanceof $root.wavesenterprise.ExecutableTransaction)
                return object;
            var message = new $root.wavesenterprise.ExecutableTransaction();
            if (object.version != null)
                message.version = object.version | 0;
            if (object.createContractTransaction != null) {
                if (typeof object.createContractTransaction !== "object")
                    throw TypeError(".wavesenterprise.ExecutableTransaction.createContractTransaction: object expected");
                message.createContractTransaction = $root.wavesenterprise.CreateContractTransaction.fromObject(object.createContractTransaction);
            }
            if (object.callContractTransaction != null) {
                if (typeof object.callContractTransaction !== "object")
                    throw TypeError(".wavesenterprise.ExecutableTransaction.callContractTransaction: object expected");
                message.callContractTransaction = $root.wavesenterprise.CallContractTransaction.fromObject(object.callContractTransaction);
            }
            if (object.updateContractTransaction != null) {
                if (typeof object.updateContractTransaction !== "object")
                    throw TypeError(".wavesenterprise.ExecutableTransaction.updateContractTransaction: object expected");
                message.updateContractTransaction = $root.wavesenterprise.UpdateContractTransaction.fromObject(object.updateContractTransaction);
            }
            return message;
        };

        /**
         * Creates a plain object from an ExecutableTransaction message. Also converts values to other types if specified.
         * @function toObject
         * @memberof wavesenterprise.ExecutableTransaction
         * @static
         * @param {wavesenterprise.ExecutableTransaction} message ExecutableTransaction
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExecutableTransaction.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.version = 0;
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            if (message.createContractTransaction != null && message.hasOwnProperty("createContractTransaction")) {
                object.createContractTransaction = $root.wavesenterprise.CreateContractTransaction.toObject(message.createContractTransaction, options);
                if (options.oneofs)
                    object.transaction = "createContractTransaction";
            }
            if (message.callContractTransaction != null && message.hasOwnProperty("callContractTransaction")) {
                object.callContractTransaction = $root.wavesenterprise.CallContractTransaction.toObject(message.callContractTransaction, options);
                if (options.oneofs)
                    object.transaction = "callContractTransaction";
            }
            if (message.updateContractTransaction != null && message.hasOwnProperty("updateContractTransaction")) {
                object.updateContractTransaction = $root.wavesenterprise.UpdateContractTransaction.toObject(message.updateContractTransaction, options);
                if (options.oneofs)
                    object.transaction = "updateContractTransaction";
            }
            return object;
        };

        /**
         * Converts this ExecutableTransaction to JSON.
         * @function toJSON
         * @memberof wavesenterprise.ExecutableTransaction
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExecutableTransaction.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ExecutableTransaction;
    })();

    wavesenterprise.UpdateContractTransaction = (function() {

        /**
         * Properties of an UpdateContractTransaction.
         * @memberof wavesenterprise
         * @interface IUpdateContractTransaction
         * @property {Uint8Array|null} [id] UpdateContractTransaction id
         * @property {Uint8Array|null} [senderPublicKey] UpdateContractTransaction senderPublicKey
         * @property {Uint8Array|null} [contractId] UpdateContractTransaction contractId
         * @property {string|null} [image] UpdateContractTransaction image
         * @property {string|null} [imageHash] UpdateContractTransaction imageHash
         * @property {number|Long|null} [fee] UpdateContractTransaction fee
         * @property {number|Long|null} [timestamp] UpdateContractTransaction timestamp
         * @property {google.protobuf.IBytesValue|null} [feeAssetId] UpdateContractTransaction feeAssetId
         * @property {wavesenterprise.IAtomicBadge|null} [atomicBadge] UpdateContractTransaction atomicBadge
         * @property {wavesenterprise.IValidationPolicy|null} [validationPolicy] UpdateContractTransaction validationPolicy
         * @property {wavesenterprise.IContractApiVersion|null} [apiVersion] UpdateContractTransaction apiVersion
         * @property {Array.<Uint8Array>|null} [proofs] UpdateContractTransaction proofs
         */

        /**
         * Constructs a new UpdateContractTransaction.
         * @memberof wavesenterprise
         * @classdesc Represents an UpdateContractTransaction.
         * @implements IUpdateContractTransaction
         * @constructor
         * @param {wavesenterprise.IUpdateContractTransaction=} [properties] Properties to set
         */
        function UpdateContractTransaction(properties) {
            this.proofs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpdateContractTransaction id.
         * @member {Uint8Array} id
         * @memberof wavesenterprise.UpdateContractTransaction
         * @instance
         */
        UpdateContractTransaction.prototype.id = $util.newBuffer([]);

        /**
         * UpdateContractTransaction senderPublicKey.
         * @member {Uint8Array} senderPublicKey
         * @memberof wavesenterprise.UpdateContractTransaction
         * @instance
         */
        UpdateContractTransaction.prototype.senderPublicKey = $util.newBuffer([]);

        /**
         * UpdateContractTransaction contractId.
         * @member {Uint8Array} contractId
         * @memberof wavesenterprise.UpdateContractTransaction
         * @instance
         */
        UpdateContractTransaction.prototype.contractId = $util.newBuffer([]);

        /**
         * UpdateContractTransaction image.
         * @member {string} image
         * @memberof wavesenterprise.UpdateContractTransaction
         * @instance
         */
        UpdateContractTransaction.prototype.image = "";

        /**
         * UpdateContractTransaction imageHash.
         * @member {string} imageHash
         * @memberof wavesenterprise.UpdateContractTransaction
         * @instance
         */
        UpdateContractTransaction.prototype.imageHash = "";

        /**
         * UpdateContractTransaction fee.
         * @member {number|Long} fee
         * @memberof wavesenterprise.UpdateContractTransaction
         * @instance
         */
        UpdateContractTransaction.prototype.fee = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * UpdateContractTransaction timestamp.
         * @member {number|Long} timestamp
         * @memberof wavesenterprise.UpdateContractTransaction
         * @instance
         */
        UpdateContractTransaction.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * UpdateContractTransaction feeAssetId.
         * @member {google.protobuf.IBytesValue|null|undefined} feeAssetId
         * @memberof wavesenterprise.UpdateContractTransaction
         * @instance
         */
        UpdateContractTransaction.prototype.feeAssetId = null;

        /**
         * UpdateContractTransaction atomicBadge.
         * @member {wavesenterprise.IAtomicBadge|null|undefined} atomicBadge
         * @memberof wavesenterprise.UpdateContractTransaction
         * @instance
         */
        UpdateContractTransaction.prototype.atomicBadge = null;

        /**
         * UpdateContractTransaction validationPolicy.
         * @member {wavesenterprise.IValidationPolicy|null|undefined} validationPolicy
         * @memberof wavesenterprise.UpdateContractTransaction
         * @instance
         */
        UpdateContractTransaction.prototype.validationPolicy = null;

        /**
         * UpdateContractTransaction apiVersion.
         * @member {wavesenterprise.IContractApiVersion|null|undefined} apiVersion
         * @memberof wavesenterprise.UpdateContractTransaction
         * @instance
         */
        UpdateContractTransaction.prototype.apiVersion = null;

        /**
         * UpdateContractTransaction proofs.
         * @member {Array.<Uint8Array>} proofs
         * @memberof wavesenterprise.UpdateContractTransaction
         * @instance
         */
        UpdateContractTransaction.prototype.proofs = $util.emptyArray;

        /**
         * Creates a new UpdateContractTransaction instance using the specified properties.
         * @function create
         * @memberof wavesenterprise.UpdateContractTransaction
         * @static
         * @param {wavesenterprise.IUpdateContractTransaction=} [properties] Properties to set
         * @returns {wavesenterprise.UpdateContractTransaction} UpdateContractTransaction instance
         */
        UpdateContractTransaction.create = function create(properties) {
            return new UpdateContractTransaction(properties);
        };

        /**
         * Encodes the specified UpdateContractTransaction message. Does not implicitly {@link wavesenterprise.UpdateContractTransaction.verify|verify} messages.
         * @function encode
         * @memberof wavesenterprise.UpdateContractTransaction
         * @static
         * @param {wavesenterprise.IUpdateContractTransaction} message UpdateContractTransaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateContractTransaction.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.id);
            if (message.senderPublicKey != null && Object.hasOwnProperty.call(message, "senderPublicKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.senderPublicKey);
            if (message.contractId != null && Object.hasOwnProperty.call(message, "contractId"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.contractId);
            if (message.image != null && Object.hasOwnProperty.call(message, "image"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.image);
            if (message.imageHash != null && Object.hasOwnProperty.call(message, "imageHash"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.imageHash);
            if (message.fee != null && Object.hasOwnProperty.call(message, "fee"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.fee);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.timestamp);
            if (message.feeAssetId != null && Object.hasOwnProperty.call(message, "feeAssetId"))
                $root.google.protobuf.BytesValue.encode(message.feeAssetId, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.atomicBadge != null && Object.hasOwnProperty.call(message, "atomicBadge"))
                $root.wavesenterprise.AtomicBadge.encode(message.atomicBadge, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.validationPolicy != null && Object.hasOwnProperty.call(message, "validationPolicy"))
                $root.wavesenterprise.ValidationPolicy.encode(message.validationPolicy, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.apiVersion != null && Object.hasOwnProperty.call(message, "apiVersion"))
                $root.wavesenterprise.ContractApiVersion.encode(message.apiVersion, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            if (message.proofs != null && message.proofs.length)
                for (var i = 0; i < message.proofs.length; ++i)
                    writer.uint32(/* id 12, wireType 2 =*/98).bytes(message.proofs[i]);
            return writer;
        };

        /**
         * Encodes the specified UpdateContractTransaction message, length delimited. Does not implicitly {@link wavesenterprise.UpdateContractTransaction.verify|verify} messages.
         * @function encodeDelimited
         * @memberof wavesenterprise.UpdateContractTransaction
         * @static
         * @param {wavesenterprise.IUpdateContractTransaction} message UpdateContractTransaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateContractTransaction.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UpdateContractTransaction message from the specified reader or buffer.
         * @function decode
         * @memberof wavesenterprise.UpdateContractTransaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {wavesenterprise.UpdateContractTransaction} UpdateContractTransaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateContractTransaction.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.wavesenterprise.UpdateContractTransaction();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.bytes();
                    break;
                case 2:
                    message.senderPublicKey = reader.bytes();
                    break;
                case 3:
                    message.contractId = reader.bytes();
                    break;
                case 4:
                    message.image = reader.string();
                    break;
                case 5:
                    message.imageHash = reader.string();
                    break;
                case 6:
                    message.fee = reader.int64();
                    break;
                case 7:
                    message.timestamp = reader.int64();
                    break;
                case 8:
                    message.feeAssetId = $root.google.protobuf.BytesValue.decode(reader, reader.uint32());
                    break;
                case 9:
                    message.atomicBadge = $root.wavesenterprise.AtomicBadge.decode(reader, reader.uint32());
                    break;
                case 10:
                    message.validationPolicy = $root.wavesenterprise.ValidationPolicy.decode(reader, reader.uint32());
                    break;
                case 11:
                    message.apiVersion = $root.wavesenterprise.ContractApiVersion.decode(reader, reader.uint32());
                    break;
                case 12:
                    if (!(message.proofs && message.proofs.length))
                        message.proofs = [];
                    message.proofs.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UpdateContractTransaction message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof wavesenterprise.UpdateContractTransaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {wavesenterprise.UpdateContractTransaction} UpdateContractTransaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateContractTransaction.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UpdateContractTransaction message.
         * @function verify
         * @memberof wavesenterprise.UpdateContractTransaction
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpdateContractTransaction.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!(message.id && typeof message.id.length === "number" || $util.isString(message.id)))
                    return "id: buffer expected";
            if (message.senderPublicKey != null && message.hasOwnProperty("senderPublicKey"))
                if (!(message.senderPublicKey && typeof message.senderPublicKey.length === "number" || $util.isString(message.senderPublicKey)))
                    return "senderPublicKey: buffer expected";
            if (message.contractId != null && message.hasOwnProperty("contractId"))
                if (!(message.contractId && typeof message.contractId.length === "number" || $util.isString(message.contractId)))
                    return "contractId: buffer expected";
            if (message.image != null && message.hasOwnProperty("image"))
                if (!$util.isString(message.image))
                    return "image: string expected";
            if (message.imageHash != null && message.hasOwnProperty("imageHash"))
                if (!$util.isString(message.imageHash))
                    return "imageHash: string expected";
            if (message.fee != null && message.hasOwnProperty("fee"))
                if (!$util.isInteger(message.fee) && !(message.fee && $util.isInteger(message.fee.low) && $util.isInteger(message.fee.high)))
                    return "fee: integer|Long expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            if (message.feeAssetId != null && message.hasOwnProperty("feeAssetId")) {
                var error = $root.google.protobuf.BytesValue.verify(message.feeAssetId);
                if (error)
                    return "feeAssetId." + error;
            }
            if (message.atomicBadge != null && message.hasOwnProperty("atomicBadge")) {
                var error = $root.wavesenterprise.AtomicBadge.verify(message.atomicBadge);
                if (error)
                    return "atomicBadge." + error;
            }
            if (message.validationPolicy != null && message.hasOwnProperty("validationPolicy")) {
                var error = $root.wavesenterprise.ValidationPolicy.verify(message.validationPolicy);
                if (error)
                    return "validationPolicy." + error;
            }
            if (message.apiVersion != null && message.hasOwnProperty("apiVersion")) {
                var error = $root.wavesenterprise.ContractApiVersion.verify(message.apiVersion);
                if (error)
                    return "apiVersion." + error;
            }
            if (message.proofs != null && message.hasOwnProperty("proofs")) {
                if (!Array.isArray(message.proofs))
                    return "proofs: array expected";
                for (var i = 0; i < message.proofs.length; ++i)
                    if (!(message.proofs[i] && typeof message.proofs[i].length === "number" || $util.isString(message.proofs[i])))
                        return "proofs: buffer[] expected";
            }
            return null;
        };

        /**
         * Creates an UpdateContractTransaction message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof wavesenterprise.UpdateContractTransaction
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {wavesenterprise.UpdateContractTransaction} UpdateContractTransaction
         */
        UpdateContractTransaction.fromObject = function fromObject(object) {
            if (object instanceof $root.wavesenterprise.UpdateContractTransaction)
                return object;
            var message = new $root.wavesenterprise.UpdateContractTransaction();
            if (object.id != null)
                if (typeof object.id === "string")
                    $util.base64.decode(object.id, message.id = $util.newBuffer($util.base64.length(object.id)), 0);
                else if (object.id.length)
                    message.id = object.id;
            if (object.senderPublicKey != null)
                if (typeof object.senderPublicKey === "string")
                    $util.base64.decode(object.senderPublicKey, message.senderPublicKey = $util.newBuffer($util.base64.length(object.senderPublicKey)), 0);
                else if (object.senderPublicKey.length)
                    message.senderPublicKey = object.senderPublicKey;
            if (object.contractId != null)
                if (typeof object.contractId === "string")
                    $util.base64.decode(object.contractId, message.contractId = $util.newBuffer($util.base64.length(object.contractId)), 0);
                else if (object.contractId.length)
                    message.contractId = object.contractId;
            if (object.image != null)
                message.image = String(object.image);
            if (object.imageHash != null)
                message.imageHash = String(object.imageHash);
            if (object.fee != null)
                if ($util.Long)
                    (message.fee = $util.Long.fromValue(object.fee)).unsigned = false;
                else if (typeof object.fee === "string")
                    message.fee = parseInt(object.fee, 10);
                else if (typeof object.fee === "number")
                    message.fee = object.fee;
                else if (typeof object.fee === "object")
                    message.fee = new $util.LongBits(object.fee.low >>> 0, object.fee.high >>> 0).toNumber();
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            if (object.feeAssetId != null) {
                if (typeof object.feeAssetId !== "object")
                    throw TypeError(".wavesenterprise.UpdateContractTransaction.feeAssetId: object expected");
                message.feeAssetId = $root.google.protobuf.BytesValue.fromObject(object.feeAssetId);
            }
            if (object.atomicBadge != null) {
                if (typeof object.atomicBadge !== "object")
                    throw TypeError(".wavesenterprise.UpdateContractTransaction.atomicBadge: object expected");
                message.atomicBadge = $root.wavesenterprise.AtomicBadge.fromObject(object.atomicBadge);
            }
            if (object.validationPolicy != null) {
                if (typeof object.validationPolicy !== "object")
                    throw TypeError(".wavesenterprise.UpdateContractTransaction.validationPolicy: object expected");
                message.validationPolicy = $root.wavesenterprise.ValidationPolicy.fromObject(object.validationPolicy);
            }
            if (object.apiVersion != null) {
                if (typeof object.apiVersion !== "object")
                    throw TypeError(".wavesenterprise.UpdateContractTransaction.apiVersion: object expected");
                message.apiVersion = $root.wavesenterprise.ContractApiVersion.fromObject(object.apiVersion);
            }
            if (object.proofs) {
                if (!Array.isArray(object.proofs))
                    throw TypeError(".wavesenterprise.UpdateContractTransaction.proofs: array expected");
                message.proofs = [];
                for (var i = 0; i < object.proofs.length; ++i)
                    if (typeof object.proofs[i] === "string")
                        $util.base64.decode(object.proofs[i], message.proofs[i] = $util.newBuffer($util.base64.length(object.proofs[i])), 0);
                    else if (object.proofs[i].length)
                        message.proofs[i] = object.proofs[i];
            }
            return message;
        };

        /**
         * Creates a plain object from an UpdateContractTransaction message. Also converts values to other types if specified.
         * @function toObject
         * @memberof wavesenterprise.UpdateContractTransaction
         * @static
         * @param {wavesenterprise.UpdateContractTransaction} message UpdateContractTransaction
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UpdateContractTransaction.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.proofs = [];
            if (options.defaults) {
                if (options.bytes === String)
                    object.id = "";
                else {
                    object.id = [];
                    if (options.bytes !== Array)
                        object.id = $util.newBuffer(object.id);
                }
                if (options.bytes === String)
                    object.senderPublicKey = "";
                else {
                    object.senderPublicKey = [];
                    if (options.bytes !== Array)
                        object.senderPublicKey = $util.newBuffer(object.senderPublicKey);
                }
                if (options.bytes === String)
                    object.contractId = "";
                else {
                    object.contractId = [];
                    if (options.bytes !== Array)
                        object.contractId = $util.newBuffer(object.contractId);
                }
                object.image = "";
                object.imageHash = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.fee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.fee = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
                object.feeAssetId = null;
                object.atomicBadge = null;
                object.validationPolicy = null;
                object.apiVersion = null;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = options.bytes === String ? $util.base64.encode(message.id, 0, message.id.length) : options.bytes === Array ? Array.prototype.slice.call(message.id) : message.id;
            if (message.senderPublicKey != null && message.hasOwnProperty("senderPublicKey"))
                object.senderPublicKey = options.bytes === String ? $util.base64.encode(message.senderPublicKey, 0, message.senderPublicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.senderPublicKey) : message.senderPublicKey;
            if (message.contractId != null && message.hasOwnProperty("contractId"))
                object.contractId = options.bytes === String ? $util.base64.encode(message.contractId, 0, message.contractId.length) : options.bytes === Array ? Array.prototype.slice.call(message.contractId) : message.contractId;
            if (message.image != null && message.hasOwnProperty("image"))
                object.image = message.image;
            if (message.imageHash != null && message.hasOwnProperty("imageHash"))
                object.imageHash = message.imageHash;
            if (message.fee != null && message.hasOwnProperty("fee"))
                if (typeof message.fee === "number")
                    object.fee = options.longs === String ? String(message.fee) : message.fee;
                else
                    object.fee = options.longs === String ? $util.Long.prototype.toString.call(message.fee) : options.longs === Number ? new $util.LongBits(message.fee.low >>> 0, message.fee.high >>> 0).toNumber() : message.fee;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            if (message.feeAssetId != null && message.hasOwnProperty("feeAssetId"))
                object.feeAssetId = $root.google.protobuf.BytesValue.toObject(message.feeAssetId, options);
            if (message.atomicBadge != null && message.hasOwnProperty("atomicBadge"))
                object.atomicBadge = $root.wavesenterprise.AtomicBadge.toObject(message.atomicBadge, options);
            if (message.validationPolicy != null && message.hasOwnProperty("validationPolicy"))
                object.validationPolicy = $root.wavesenterprise.ValidationPolicy.toObject(message.validationPolicy, options);
            if (message.apiVersion != null && message.hasOwnProperty("apiVersion"))
                object.apiVersion = $root.wavesenterprise.ContractApiVersion.toObject(message.apiVersion, options);
            if (message.proofs && message.proofs.length) {
                object.proofs = [];
                for (var j = 0; j < message.proofs.length; ++j)
                    object.proofs[j] = options.bytes === String ? $util.base64.encode(message.proofs[j], 0, message.proofs[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.proofs[j]) : message.proofs[j];
            }
            return object;
        };

        /**
         * Converts this UpdateContractTransaction to JSON.
         * @function toJSON
         * @memberof wavesenterprise.UpdateContractTransaction
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UpdateContractTransaction.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UpdateContractTransaction;
    })();

    wavesenterprise.ValidationProof = (function() {

        /**
         * Properties of a ValidationProof.
         * @memberof wavesenterprise
         * @interface IValidationProof
         * @property {Uint8Array|null} [validatorPublicKey] ValidationProof validatorPublicKey
         * @property {Uint8Array|null} [signature] ValidationProof signature
         */

        /**
         * Constructs a new ValidationProof.
         * @memberof wavesenterprise
         * @classdesc Represents a ValidationProof.
         * @implements IValidationProof
         * @constructor
         * @param {wavesenterprise.IValidationProof=} [properties] Properties to set
         */
        function ValidationProof(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ValidationProof validatorPublicKey.
         * @member {Uint8Array} validatorPublicKey
         * @memberof wavesenterprise.ValidationProof
         * @instance
         */
        ValidationProof.prototype.validatorPublicKey = $util.newBuffer([]);

        /**
         * ValidationProof signature.
         * @member {Uint8Array} signature
         * @memberof wavesenterprise.ValidationProof
         * @instance
         */
        ValidationProof.prototype.signature = $util.newBuffer([]);

        /**
         * Creates a new ValidationProof instance using the specified properties.
         * @function create
         * @memberof wavesenterprise.ValidationProof
         * @static
         * @param {wavesenterprise.IValidationProof=} [properties] Properties to set
         * @returns {wavesenterprise.ValidationProof} ValidationProof instance
         */
        ValidationProof.create = function create(properties) {
            return new ValidationProof(properties);
        };

        /**
         * Encodes the specified ValidationProof message. Does not implicitly {@link wavesenterprise.ValidationProof.verify|verify} messages.
         * @function encode
         * @memberof wavesenterprise.ValidationProof
         * @static
         * @param {wavesenterprise.IValidationProof} message ValidationProof message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ValidationProof.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.validatorPublicKey != null && Object.hasOwnProperty.call(message, "validatorPublicKey"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.validatorPublicKey);
            if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.signature);
            return writer;
        };

        /**
         * Encodes the specified ValidationProof message, length delimited. Does not implicitly {@link wavesenterprise.ValidationProof.verify|verify} messages.
         * @function encodeDelimited
         * @memberof wavesenterprise.ValidationProof
         * @static
         * @param {wavesenterprise.IValidationProof} message ValidationProof message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ValidationProof.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ValidationProof message from the specified reader or buffer.
         * @function decode
         * @memberof wavesenterprise.ValidationProof
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {wavesenterprise.ValidationProof} ValidationProof
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ValidationProof.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.wavesenterprise.ValidationProof();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.validatorPublicKey = reader.bytes();
                    break;
                case 2:
                    message.signature = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ValidationProof message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof wavesenterprise.ValidationProof
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {wavesenterprise.ValidationProof} ValidationProof
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ValidationProof.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ValidationProof message.
         * @function verify
         * @memberof wavesenterprise.ValidationProof
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ValidationProof.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.validatorPublicKey != null && message.hasOwnProperty("validatorPublicKey"))
                if (!(message.validatorPublicKey && typeof message.validatorPublicKey.length === "number" || $util.isString(message.validatorPublicKey)))
                    return "validatorPublicKey: buffer expected";
            if (message.signature != null && message.hasOwnProperty("signature"))
                if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                    return "signature: buffer expected";
            return null;
        };

        /**
         * Creates a ValidationProof message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof wavesenterprise.ValidationProof
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {wavesenterprise.ValidationProof} ValidationProof
         */
        ValidationProof.fromObject = function fromObject(object) {
            if (object instanceof $root.wavesenterprise.ValidationProof)
                return object;
            var message = new $root.wavesenterprise.ValidationProof();
            if (object.validatorPublicKey != null)
                if (typeof object.validatorPublicKey === "string")
                    $util.base64.decode(object.validatorPublicKey, message.validatorPublicKey = $util.newBuffer($util.base64.length(object.validatorPublicKey)), 0);
                else if (object.validatorPublicKey.length)
                    message.validatorPublicKey = object.validatorPublicKey;
            if (object.signature != null)
                if (typeof object.signature === "string")
                    $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                else if (object.signature.length)
                    message.signature = object.signature;
            return message;
        };

        /**
         * Creates a plain object from a ValidationProof message. Also converts values to other types if specified.
         * @function toObject
         * @memberof wavesenterprise.ValidationProof
         * @static
         * @param {wavesenterprise.ValidationProof} message ValidationProof
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ValidationProof.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.validatorPublicKey = "";
                else {
                    object.validatorPublicKey = [];
                    if (options.bytes !== Array)
                        object.validatorPublicKey = $util.newBuffer(object.validatorPublicKey);
                }
                if (options.bytes === String)
                    object.signature = "";
                else {
                    object.signature = [];
                    if (options.bytes !== Array)
                        object.signature = $util.newBuffer(object.signature);
                }
            }
            if (message.validatorPublicKey != null && message.hasOwnProperty("validatorPublicKey"))
                object.validatorPublicKey = options.bytes === String ? $util.base64.encode(message.validatorPublicKey, 0, message.validatorPublicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.validatorPublicKey) : message.validatorPublicKey;
            if (message.signature != null && message.hasOwnProperty("signature"))
                object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
            return object;
        };

        /**
         * Converts this ValidationProof to JSON.
         * @function toJSON
         * @memberof wavesenterprise.ValidationProof
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ValidationProof.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ValidationProof;
    })();

    wavesenterprise.DisableContractTransaction = (function() {

        /**
         * Properties of a DisableContractTransaction.
         * @memberof wavesenterprise
         * @interface IDisableContractTransaction
         * @property {Uint8Array|null} [id] DisableContractTransaction id
         * @property {Uint8Array|null} [senderPublicKey] DisableContractTransaction senderPublicKey
         * @property {Uint8Array|null} [contractId] DisableContractTransaction contractId
         * @property {number|Long|null} [fee] DisableContractTransaction fee
         * @property {number|Long|null} [timestamp] DisableContractTransaction timestamp
         * @property {google.protobuf.IBytesValue|null} [feeAssetId] DisableContractTransaction feeAssetId
         * @property {wavesenterprise.IAtomicBadge|null} [atomicBadge] DisableContractTransaction atomicBadge
         * @property {Array.<Uint8Array>|null} [proofs] DisableContractTransaction proofs
         */

        /**
         * Constructs a new DisableContractTransaction.
         * @memberof wavesenterprise
         * @classdesc Represents a DisableContractTransaction.
         * @implements IDisableContractTransaction
         * @constructor
         * @param {wavesenterprise.IDisableContractTransaction=} [properties] Properties to set
         */
        function DisableContractTransaction(properties) {
            this.proofs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DisableContractTransaction id.
         * @member {Uint8Array} id
         * @memberof wavesenterprise.DisableContractTransaction
         * @instance
         */
        DisableContractTransaction.prototype.id = $util.newBuffer([]);

        /**
         * DisableContractTransaction senderPublicKey.
         * @member {Uint8Array} senderPublicKey
         * @memberof wavesenterprise.DisableContractTransaction
         * @instance
         */
        DisableContractTransaction.prototype.senderPublicKey = $util.newBuffer([]);

        /**
         * DisableContractTransaction contractId.
         * @member {Uint8Array} contractId
         * @memberof wavesenterprise.DisableContractTransaction
         * @instance
         */
        DisableContractTransaction.prototype.contractId = $util.newBuffer([]);

        /**
         * DisableContractTransaction fee.
         * @member {number|Long} fee
         * @memberof wavesenterprise.DisableContractTransaction
         * @instance
         */
        DisableContractTransaction.prototype.fee = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * DisableContractTransaction timestamp.
         * @member {number|Long} timestamp
         * @memberof wavesenterprise.DisableContractTransaction
         * @instance
         */
        DisableContractTransaction.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * DisableContractTransaction feeAssetId.
         * @member {google.protobuf.IBytesValue|null|undefined} feeAssetId
         * @memberof wavesenterprise.DisableContractTransaction
         * @instance
         */
        DisableContractTransaction.prototype.feeAssetId = null;

        /**
         * DisableContractTransaction atomicBadge.
         * @member {wavesenterprise.IAtomicBadge|null|undefined} atomicBadge
         * @memberof wavesenterprise.DisableContractTransaction
         * @instance
         */
        DisableContractTransaction.prototype.atomicBadge = null;

        /**
         * DisableContractTransaction proofs.
         * @member {Array.<Uint8Array>} proofs
         * @memberof wavesenterprise.DisableContractTransaction
         * @instance
         */
        DisableContractTransaction.prototype.proofs = $util.emptyArray;

        /**
         * Creates a new DisableContractTransaction instance using the specified properties.
         * @function create
         * @memberof wavesenterprise.DisableContractTransaction
         * @static
         * @param {wavesenterprise.IDisableContractTransaction=} [properties] Properties to set
         * @returns {wavesenterprise.DisableContractTransaction} DisableContractTransaction instance
         */
        DisableContractTransaction.create = function create(properties) {
            return new DisableContractTransaction(properties);
        };

        /**
         * Encodes the specified DisableContractTransaction message. Does not implicitly {@link wavesenterprise.DisableContractTransaction.verify|verify} messages.
         * @function encode
         * @memberof wavesenterprise.DisableContractTransaction
         * @static
         * @param {wavesenterprise.IDisableContractTransaction} message DisableContractTransaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DisableContractTransaction.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.id);
            if (message.senderPublicKey != null && Object.hasOwnProperty.call(message, "senderPublicKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.senderPublicKey);
            if (message.contractId != null && Object.hasOwnProperty.call(message, "contractId"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.contractId);
            if (message.fee != null && Object.hasOwnProperty.call(message, "fee"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.fee);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.timestamp);
            if (message.feeAssetId != null && Object.hasOwnProperty.call(message, "feeAssetId"))
                $root.google.protobuf.BytesValue.encode(message.feeAssetId, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.atomicBadge != null && Object.hasOwnProperty.call(message, "atomicBadge"))
                $root.wavesenterprise.AtomicBadge.encode(message.atomicBadge, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.proofs != null && message.proofs.length)
                for (var i = 0; i < message.proofs.length; ++i)
                    writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.proofs[i]);
            return writer;
        };

        /**
         * Encodes the specified DisableContractTransaction message, length delimited. Does not implicitly {@link wavesenterprise.DisableContractTransaction.verify|verify} messages.
         * @function encodeDelimited
         * @memberof wavesenterprise.DisableContractTransaction
         * @static
         * @param {wavesenterprise.IDisableContractTransaction} message DisableContractTransaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DisableContractTransaction.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DisableContractTransaction message from the specified reader or buffer.
         * @function decode
         * @memberof wavesenterprise.DisableContractTransaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {wavesenterprise.DisableContractTransaction} DisableContractTransaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DisableContractTransaction.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.wavesenterprise.DisableContractTransaction();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.bytes();
                    break;
                case 2:
                    message.senderPublicKey = reader.bytes();
                    break;
                case 3:
                    message.contractId = reader.bytes();
                    break;
                case 4:
                    message.fee = reader.int64();
                    break;
                case 5:
                    message.timestamp = reader.int64();
                    break;
                case 6:
                    message.feeAssetId = $root.google.protobuf.BytesValue.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.atomicBadge = $root.wavesenterprise.AtomicBadge.decode(reader, reader.uint32());
                    break;
                case 8:
                    if (!(message.proofs && message.proofs.length))
                        message.proofs = [];
                    message.proofs.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DisableContractTransaction message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof wavesenterprise.DisableContractTransaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {wavesenterprise.DisableContractTransaction} DisableContractTransaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DisableContractTransaction.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DisableContractTransaction message.
         * @function verify
         * @memberof wavesenterprise.DisableContractTransaction
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DisableContractTransaction.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!(message.id && typeof message.id.length === "number" || $util.isString(message.id)))
                    return "id: buffer expected";
            if (message.senderPublicKey != null && message.hasOwnProperty("senderPublicKey"))
                if (!(message.senderPublicKey && typeof message.senderPublicKey.length === "number" || $util.isString(message.senderPublicKey)))
                    return "senderPublicKey: buffer expected";
            if (message.contractId != null && message.hasOwnProperty("contractId"))
                if (!(message.contractId && typeof message.contractId.length === "number" || $util.isString(message.contractId)))
                    return "contractId: buffer expected";
            if (message.fee != null && message.hasOwnProperty("fee"))
                if (!$util.isInteger(message.fee) && !(message.fee && $util.isInteger(message.fee.low) && $util.isInteger(message.fee.high)))
                    return "fee: integer|Long expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            if (message.feeAssetId != null && message.hasOwnProperty("feeAssetId")) {
                var error = $root.google.protobuf.BytesValue.verify(message.feeAssetId);
                if (error)
                    return "feeAssetId." + error;
            }
            if (message.atomicBadge != null && message.hasOwnProperty("atomicBadge")) {
                var error = $root.wavesenterprise.AtomicBadge.verify(message.atomicBadge);
                if (error)
                    return "atomicBadge." + error;
            }
            if (message.proofs != null && message.hasOwnProperty("proofs")) {
                if (!Array.isArray(message.proofs))
                    return "proofs: array expected";
                for (var i = 0; i < message.proofs.length; ++i)
                    if (!(message.proofs[i] && typeof message.proofs[i].length === "number" || $util.isString(message.proofs[i])))
                        return "proofs: buffer[] expected";
            }
            return null;
        };

        /**
         * Creates a DisableContractTransaction message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof wavesenterprise.DisableContractTransaction
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {wavesenterprise.DisableContractTransaction} DisableContractTransaction
         */
        DisableContractTransaction.fromObject = function fromObject(object) {
            if (object instanceof $root.wavesenterprise.DisableContractTransaction)
                return object;
            var message = new $root.wavesenterprise.DisableContractTransaction();
            if (object.id != null)
                if (typeof object.id === "string")
                    $util.base64.decode(object.id, message.id = $util.newBuffer($util.base64.length(object.id)), 0);
                else if (object.id.length)
                    message.id = object.id;
            if (object.senderPublicKey != null)
                if (typeof object.senderPublicKey === "string")
                    $util.base64.decode(object.senderPublicKey, message.senderPublicKey = $util.newBuffer($util.base64.length(object.senderPublicKey)), 0);
                else if (object.senderPublicKey.length)
                    message.senderPublicKey = object.senderPublicKey;
            if (object.contractId != null)
                if (typeof object.contractId === "string")
                    $util.base64.decode(object.contractId, message.contractId = $util.newBuffer($util.base64.length(object.contractId)), 0);
                else if (object.contractId.length)
                    message.contractId = object.contractId;
            if (object.fee != null)
                if ($util.Long)
                    (message.fee = $util.Long.fromValue(object.fee)).unsigned = false;
                else if (typeof object.fee === "string")
                    message.fee = parseInt(object.fee, 10);
                else if (typeof object.fee === "number")
                    message.fee = object.fee;
                else if (typeof object.fee === "object")
                    message.fee = new $util.LongBits(object.fee.low >>> 0, object.fee.high >>> 0).toNumber();
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            if (object.feeAssetId != null) {
                if (typeof object.feeAssetId !== "object")
                    throw TypeError(".wavesenterprise.DisableContractTransaction.feeAssetId: object expected");
                message.feeAssetId = $root.google.protobuf.BytesValue.fromObject(object.feeAssetId);
            }
            if (object.atomicBadge != null) {
                if (typeof object.atomicBadge !== "object")
                    throw TypeError(".wavesenterprise.DisableContractTransaction.atomicBadge: object expected");
                message.atomicBadge = $root.wavesenterprise.AtomicBadge.fromObject(object.atomicBadge);
            }
            if (object.proofs) {
                if (!Array.isArray(object.proofs))
                    throw TypeError(".wavesenterprise.DisableContractTransaction.proofs: array expected");
                message.proofs = [];
                for (var i = 0; i < object.proofs.length; ++i)
                    if (typeof object.proofs[i] === "string")
                        $util.base64.decode(object.proofs[i], message.proofs[i] = $util.newBuffer($util.base64.length(object.proofs[i])), 0);
                    else if (object.proofs[i].length)
                        message.proofs[i] = object.proofs[i];
            }
            return message;
        };

        /**
         * Creates a plain object from a DisableContractTransaction message. Also converts values to other types if specified.
         * @function toObject
         * @memberof wavesenterprise.DisableContractTransaction
         * @static
         * @param {wavesenterprise.DisableContractTransaction} message DisableContractTransaction
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DisableContractTransaction.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.proofs = [];
            if (options.defaults) {
                if (options.bytes === String)
                    object.id = "";
                else {
                    object.id = [];
                    if (options.bytes !== Array)
                        object.id = $util.newBuffer(object.id);
                }
                if (options.bytes === String)
                    object.senderPublicKey = "";
                else {
                    object.senderPublicKey = [];
                    if (options.bytes !== Array)
                        object.senderPublicKey = $util.newBuffer(object.senderPublicKey);
                }
                if (options.bytes === String)
                    object.contractId = "";
                else {
                    object.contractId = [];
                    if (options.bytes !== Array)
                        object.contractId = $util.newBuffer(object.contractId);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.fee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.fee = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
                object.feeAssetId = null;
                object.atomicBadge = null;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = options.bytes === String ? $util.base64.encode(message.id, 0, message.id.length) : options.bytes === Array ? Array.prototype.slice.call(message.id) : message.id;
            if (message.senderPublicKey != null && message.hasOwnProperty("senderPublicKey"))
                object.senderPublicKey = options.bytes === String ? $util.base64.encode(message.senderPublicKey, 0, message.senderPublicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.senderPublicKey) : message.senderPublicKey;
            if (message.contractId != null && message.hasOwnProperty("contractId"))
                object.contractId = options.bytes === String ? $util.base64.encode(message.contractId, 0, message.contractId.length) : options.bytes === Array ? Array.prototype.slice.call(message.contractId) : message.contractId;
            if (message.fee != null && message.hasOwnProperty("fee"))
                if (typeof message.fee === "number")
                    object.fee = options.longs === String ? String(message.fee) : message.fee;
                else
                    object.fee = options.longs === String ? $util.Long.prototype.toString.call(message.fee) : options.longs === Number ? new $util.LongBits(message.fee.low >>> 0, message.fee.high >>> 0).toNumber() : message.fee;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            if (message.feeAssetId != null && message.hasOwnProperty("feeAssetId"))
                object.feeAssetId = $root.google.protobuf.BytesValue.toObject(message.feeAssetId, options);
            if (message.atomicBadge != null && message.hasOwnProperty("atomicBadge"))
                object.atomicBadge = $root.wavesenterprise.AtomicBadge.toObject(message.atomicBadge, options);
            if (message.proofs && message.proofs.length) {
                object.proofs = [];
                for (var j = 0; j < message.proofs.length; ++j)
                    object.proofs[j] = options.bytes === String ? $util.base64.encode(message.proofs[j], 0, message.proofs[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.proofs[j]) : message.proofs[j];
            }
            return object;
        };

        /**
         * Converts this DisableContractTransaction to JSON.
         * @function toJSON
         * @memberof wavesenterprise.DisableContractTransaction
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DisableContractTransaction.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DisableContractTransaction;
    })();

    wavesenterprise.SetScriptTransaction = (function() {

        /**
         * Properties of a SetScriptTransaction.
         * @memberof wavesenterprise
         * @interface ISetScriptTransaction
         * @property {Uint8Array|null} [id] SetScriptTransaction id
         * @property {number|null} [chainId] SetScriptTransaction chainId
         * @property {Uint8Array|null} [senderPublicKey] SetScriptTransaction senderPublicKey
         * @property {google.protobuf.IBytesValue|null} [script] SetScriptTransaction script
         * @property {Uint8Array|null} [name] SetScriptTransaction name
         * @property {Uint8Array|null} [description] SetScriptTransaction description
         * @property {number|Long|null} [fee] SetScriptTransaction fee
         * @property {number|Long|null} [timestamp] SetScriptTransaction timestamp
         * @property {Array.<Uint8Array>|null} [proofs] SetScriptTransaction proofs
         */

        /**
         * Constructs a new SetScriptTransaction.
         * @memberof wavesenterprise
         * @classdesc Represents a SetScriptTransaction.
         * @implements ISetScriptTransaction
         * @constructor
         * @param {wavesenterprise.ISetScriptTransaction=} [properties] Properties to set
         */
        function SetScriptTransaction(properties) {
            this.proofs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SetScriptTransaction id.
         * @member {Uint8Array} id
         * @memberof wavesenterprise.SetScriptTransaction
         * @instance
         */
        SetScriptTransaction.prototype.id = $util.newBuffer([]);

        /**
         * SetScriptTransaction chainId.
         * @member {number} chainId
         * @memberof wavesenterprise.SetScriptTransaction
         * @instance
         */
        SetScriptTransaction.prototype.chainId = 0;

        /**
         * SetScriptTransaction senderPublicKey.
         * @member {Uint8Array} senderPublicKey
         * @memberof wavesenterprise.SetScriptTransaction
         * @instance
         */
        SetScriptTransaction.prototype.senderPublicKey = $util.newBuffer([]);

        /**
         * SetScriptTransaction script.
         * @member {google.protobuf.IBytesValue|null|undefined} script
         * @memberof wavesenterprise.SetScriptTransaction
         * @instance
         */
        SetScriptTransaction.prototype.script = null;

        /**
         * SetScriptTransaction name.
         * @member {Uint8Array} name
         * @memberof wavesenterprise.SetScriptTransaction
         * @instance
         */
        SetScriptTransaction.prototype.name = $util.newBuffer([]);

        /**
         * SetScriptTransaction description.
         * @member {Uint8Array} description
         * @memberof wavesenterprise.SetScriptTransaction
         * @instance
         */
        SetScriptTransaction.prototype.description = $util.newBuffer([]);

        /**
         * SetScriptTransaction fee.
         * @member {number|Long} fee
         * @memberof wavesenterprise.SetScriptTransaction
         * @instance
         */
        SetScriptTransaction.prototype.fee = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SetScriptTransaction timestamp.
         * @member {number|Long} timestamp
         * @memberof wavesenterprise.SetScriptTransaction
         * @instance
         */
        SetScriptTransaction.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SetScriptTransaction proofs.
         * @member {Array.<Uint8Array>} proofs
         * @memberof wavesenterprise.SetScriptTransaction
         * @instance
         */
        SetScriptTransaction.prototype.proofs = $util.emptyArray;

        /**
         * Creates a new SetScriptTransaction instance using the specified properties.
         * @function create
         * @memberof wavesenterprise.SetScriptTransaction
         * @static
         * @param {wavesenterprise.ISetScriptTransaction=} [properties] Properties to set
         * @returns {wavesenterprise.SetScriptTransaction} SetScriptTransaction instance
         */
        SetScriptTransaction.create = function create(properties) {
            return new SetScriptTransaction(properties);
        };

        /**
         * Encodes the specified SetScriptTransaction message. Does not implicitly {@link wavesenterprise.SetScriptTransaction.verify|verify} messages.
         * @function encode
         * @memberof wavesenterprise.SetScriptTransaction
         * @static
         * @param {wavesenterprise.ISetScriptTransaction} message SetScriptTransaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetScriptTransaction.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.id);
            if (message.chainId != null && Object.hasOwnProperty.call(message, "chainId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.chainId);
            if (message.senderPublicKey != null && Object.hasOwnProperty.call(message, "senderPublicKey"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.senderPublicKey);
            if (message.script != null && Object.hasOwnProperty.call(message, "script"))
                $root.google.protobuf.BytesValue.encode(message.script, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.name);
            if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.description);
            if (message.fee != null && Object.hasOwnProperty.call(message, "fee"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.fee);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 8, wireType 0 =*/64).int64(message.timestamp);
            if (message.proofs != null && message.proofs.length)
                for (var i = 0; i < message.proofs.length; ++i)
                    writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.proofs[i]);
            return writer;
        };

        /**
         * Encodes the specified SetScriptTransaction message, length delimited. Does not implicitly {@link wavesenterprise.SetScriptTransaction.verify|verify} messages.
         * @function encodeDelimited
         * @memberof wavesenterprise.SetScriptTransaction
         * @static
         * @param {wavesenterprise.ISetScriptTransaction} message SetScriptTransaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetScriptTransaction.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SetScriptTransaction message from the specified reader or buffer.
         * @function decode
         * @memberof wavesenterprise.SetScriptTransaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {wavesenterprise.SetScriptTransaction} SetScriptTransaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetScriptTransaction.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.wavesenterprise.SetScriptTransaction();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.bytes();
                    break;
                case 2:
                    message.chainId = reader.int32();
                    break;
                case 3:
                    message.senderPublicKey = reader.bytes();
                    break;
                case 4:
                    message.script = $root.google.protobuf.BytesValue.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.name = reader.bytes();
                    break;
                case 6:
                    message.description = reader.bytes();
                    break;
                case 7:
                    message.fee = reader.int64();
                    break;
                case 8:
                    message.timestamp = reader.int64();
                    break;
                case 9:
                    if (!(message.proofs && message.proofs.length))
                        message.proofs = [];
                    message.proofs.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SetScriptTransaction message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof wavesenterprise.SetScriptTransaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {wavesenterprise.SetScriptTransaction} SetScriptTransaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetScriptTransaction.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SetScriptTransaction message.
         * @function verify
         * @memberof wavesenterprise.SetScriptTransaction
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SetScriptTransaction.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!(message.id && typeof message.id.length === "number" || $util.isString(message.id)))
                    return "id: buffer expected";
            if (message.chainId != null && message.hasOwnProperty("chainId"))
                if (!$util.isInteger(message.chainId))
                    return "chainId: integer expected";
            if (message.senderPublicKey != null && message.hasOwnProperty("senderPublicKey"))
                if (!(message.senderPublicKey && typeof message.senderPublicKey.length === "number" || $util.isString(message.senderPublicKey)))
                    return "senderPublicKey: buffer expected";
            if (message.script != null && message.hasOwnProperty("script")) {
                var error = $root.google.protobuf.BytesValue.verify(message.script);
                if (error)
                    return "script." + error;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                if (!(message.name && typeof message.name.length === "number" || $util.isString(message.name)))
                    return "name: buffer expected";
            if (message.description != null && message.hasOwnProperty("description"))
                if (!(message.description && typeof message.description.length === "number" || $util.isString(message.description)))
                    return "description: buffer expected";
            if (message.fee != null && message.hasOwnProperty("fee"))
                if (!$util.isInteger(message.fee) && !(message.fee && $util.isInteger(message.fee.low) && $util.isInteger(message.fee.high)))
                    return "fee: integer|Long expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            if (message.proofs != null && message.hasOwnProperty("proofs")) {
                if (!Array.isArray(message.proofs))
                    return "proofs: array expected";
                for (var i = 0; i < message.proofs.length; ++i)
                    if (!(message.proofs[i] && typeof message.proofs[i].length === "number" || $util.isString(message.proofs[i])))
                        return "proofs: buffer[] expected";
            }
            return null;
        };

        /**
         * Creates a SetScriptTransaction message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof wavesenterprise.SetScriptTransaction
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {wavesenterprise.SetScriptTransaction} SetScriptTransaction
         */
        SetScriptTransaction.fromObject = function fromObject(object) {
            if (object instanceof $root.wavesenterprise.SetScriptTransaction)
                return object;
            var message = new $root.wavesenterprise.SetScriptTransaction();
            if (object.id != null)
                if (typeof object.id === "string")
                    $util.base64.decode(object.id, message.id = $util.newBuffer($util.base64.length(object.id)), 0);
                else if (object.id.length)
                    message.id = object.id;
            if (object.chainId != null)
                message.chainId = object.chainId | 0;
            if (object.senderPublicKey != null)
                if (typeof object.senderPublicKey === "string")
                    $util.base64.decode(object.senderPublicKey, message.senderPublicKey = $util.newBuffer($util.base64.length(object.senderPublicKey)), 0);
                else if (object.senderPublicKey.length)
                    message.senderPublicKey = object.senderPublicKey;
            if (object.script != null) {
                if (typeof object.script !== "object")
                    throw TypeError(".wavesenterprise.SetScriptTransaction.script: object expected");
                message.script = $root.google.protobuf.BytesValue.fromObject(object.script);
            }
            if (object.name != null)
                if (typeof object.name === "string")
                    $util.base64.decode(object.name, message.name = $util.newBuffer($util.base64.length(object.name)), 0);
                else if (object.name.length)
                    message.name = object.name;
            if (object.description != null)
                if (typeof object.description === "string")
                    $util.base64.decode(object.description, message.description = $util.newBuffer($util.base64.length(object.description)), 0);
                else if (object.description.length)
                    message.description = object.description;
            if (object.fee != null)
                if ($util.Long)
                    (message.fee = $util.Long.fromValue(object.fee)).unsigned = false;
                else if (typeof object.fee === "string")
                    message.fee = parseInt(object.fee, 10);
                else if (typeof object.fee === "number")
                    message.fee = object.fee;
                else if (typeof object.fee === "object")
                    message.fee = new $util.LongBits(object.fee.low >>> 0, object.fee.high >>> 0).toNumber();
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            if (object.proofs) {
                if (!Array.isArray(object.proofs))
                    throw TypeError(".wavesenterprise.SetScriptTransaction.proofs: array expected");
                message.proofs = [];
                for (var i = 0; i < object.proofs.length; ++i)
                    if (typeof object.proofs[i] === "string")
                        $util.base64.decode(object.proofs[i], message.proofs[i] = $util.newBuffer($util.base64.length(object.proofs[i])), 0);
                    else if (object.proofs[i].length)
                        message.proofs[i] = object.proofs[i];
            }
            return message;
        };

        /**
         * Creates a plain object from a SetScriptTransaction message. Also converts values to other types if specified.
         * @function toObject
         * @memberof wavesenterprise.SetScriptTransaction
         * @static
         * @param {wavesenterprise.SetScriptTransaction} message SetScriptTransaction
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SetScriptTransaction.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.proofs = [];
            if (options.defaults) {
                if (options.bytes === String)
                    object.id = "";
                else {
                    object.id = [];
                    if (options.bytes !== Array)
                        object.id = $util.newBuffer(object.id);
                }
                object.chainId = 0;
                if (options.bytes === String)
                    object.senderPublicKey = "";
                else {
                    object.senderPublicKey = [];
                    if (options.bytes !== Array)
                        object.senderPublicKey = $util.newBuffer(object.senderPublicKey);
                }
                object.script = null;
                if (options.bytes === String)
                    object.name = "";
                else {
                    object.name = [];
                    if (options.bytes !== Array)
                        object.name = $util.newBuffer(object.name);
                }
                if (options.bytes === String)
                    object.description = "";
                else {
                    object.description = [];
                    if (options.bytes !== Array)
                        object.description = $util.newBuffer(object.description);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.fee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.fee = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = options.bytes === String ? $util.base64.encode(message.id, 0, message.id.length) : options.bytes === Array ? Array.prototype.slice.call(message.id) : message.id;
            if (message.chainId != null && message.hasOwnProperty("chainId"))
                object.chainId = message.chainId;
            if (message.senderPublicKey != null && message.hasOwnProperty("senderPublicKey"))
                object.senderPublicKey = options.bytes === String ? $util.base64.encode(message.senderPublicKey, 0, message.senderPublicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.senderPublicKey) : message.senderPublicKey;
            if (message.script != null && message.hasOwnProperty("script"))
                object.script = $root.google.protobuf.BytesValue.toObject(message.script, options);
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = options.bytes === String ? $util.base64.encode(message.name, 0, message.name.length) : options.bytes === Array ? Array.prototype.slice.call(message.name) : message.name;
            if (message.description != null && message.hasOwnProperty("description"))
                object.description = options.bytes === String ? $util.base64.encode(message.description, 0, message.description.length) : options.bytes === Array ? Array.prototype.slice.call(message.description) : message.description;
            if (message.fee != null && message.hasOwnProperty("fee"))
                if (typeof message.fee === "number")
                    object.fee = options.longs === String ? String(message.fee) : message.fee;
                else
                    object.fee = options.longs === String ? $util.Long.prototype.toString.call(message.fee) : options.longs === Number ? new $util.LongBits(message.fee.low >>> 0, message.fee.high >>> 0).toNumber() : message.fee;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            if (message.proofs && message.proofs.length) {
                object.proofs = [];
                for (var j = 0; j < message.proofs.length; ++j)
                    object.proofs[j] = options.bytes === String ? $util.base64.encode(message.proofs[j], 0, message.proofs[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.proofs[j]) : message.proofs[j];
            }
            return object;
        };

        /**
         * Converts this SetScriptTransaction to JSON.
         * @function toJSON
         * @memberof wavesenterprise.SetScriptTransaction
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SetScriptTransaction.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SetScriptTransaction;
    })();

    wavesenterprise.AtomicTransaction = (function() {

        /**
         * Properties of an AtomicTransaction.
         * @memberof wavesenterprise
         * @interface IAtomicTransaction
         * @property {Uint8Array|null} [id] AtomicTransaction id
         * @property {Uint8Array|null} [senderPublicKey] AtomicTransaction senderPublicKey
         * @property {google.protobuf.IBytesValue|null} [miner] AtomicTransaction miner
         * @property {Array.<wavesenterprise.IAtomicInnerTransaction>|null} [transactions] AtomicTransaction transactions
         * @property {number|Long|null} [timestamp] AtomicTransaction timestamp
         * @property {Array.<Uint8Array>|null} [proofs] AtomicTransaction proofs
         */

        /**
         * Constructs a new AtomicTransaction.
         * @memberof wavesenterprise
         * @classdesc Represents an AtomicTransaction.
         * @implements IAtomicTransaction
         * @constructor
         * @param {wavesenterprise.IAtomicTransaction=} [properties] Properties to set
         */
        function AtomicTransaction(properties) {
            this.transactions = [];
            this.proofs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AtomicTransaction id.
         * @member {Uint8Array} id
         * @memberof wavesenterprise.AtomicTransaction
         * @instance
         */
        AtomicTransaction.prototype.id = $util.newBuffer([]);

        /**
         * AtomicTransaction senderPublicKey.
         * @member {Uint8Array} senderPublicKey
         * @memberof wavesenterprise.AtomicTransaction
         * @instance
         */
        AtomicTransaction.prototype.senderPublicKey = $util.newBuffer([]);

        /**
         * AtomicTransaction miner.
         * @member {google.protobuf.IBytesValue|null|undefined} miner
         * @memberof wavesenterprise.AtomicTransaction
         * @instance
         */
        AtomicTransaction.prototype.miner = null;

        /**
         * AtomicTransaction transactions.
         * @member {Array.<wavesenterprise.IAtomicInnerTransaction>} transactions
         * @memberof wavesenterprise.AtomicTransaction
         * @instance
         */
        AtomicTransaction.prototype.transactions = $util.emptyArray;

        /**
         * AtomicTransaction timestamp.
         * @member {number|Long} timestamp
         * @memberof wavesenterprise.AtomicTransaction
         * @instance
         */
        AtomicTransaction.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * AtomicTransaction proofs.
         * @member {Array.<Uint8Array>} proofs
         * @memberof wavesenterprise.AtomicTransaction
         * @instance
         */
        AtomicTransaction.prototype.proofs = $util.emptyArray;

        /**
         * Creates a new AtomicTransaction instance using the specified properties.
         * @function create
         * @memberof wavesenterprise.AtomicTransaction
         * @static
         * @param {wavesenterprise.IAtomicTransaction=} [properties] Properties to set
         * @returns {wavesenterprise.AtomicTransaction} AtomicTransaction instance
         */
        AtomicTransaction.create = function create(properties) {
            return new AtomicTransaction(properties);
        };

        /**
         * Encodes the specified AtomicTransaction message. Does not implicitly {@link wavesenterprise.AtomicTransaction.verify|verify} messages.
         * @function encode
         * @memberof wavesenterprise.AtomicTransaction
         * @static
         * @param {wavesenterprise.IAtomicTransaction} message AtomicTransaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AtomicTransaction.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.id);
            if (message.senderPublicKey != null && Object.hasOwnProperty.call(message, "senderPublicKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.senderPublicKey);
            if (message.miner != null && Object.hasOwnProperty.call(message, "miner"))
                $root.google.protobuf.BytesValue.encode(message.miner, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.transactions != null && message.transactions.length)
                for (var i = 0; i < message.transactions.length; ++i)
                    $root.wavesenterprise.AtomicInnerTransaction.encode(message.transactions[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.timestamp);
            if (message.proofs != null && message.proofs.length)
                for (var i = 0; i < message.proofs.length; ++i)
                    writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.proofs[i]);
            return writer;
        };

        /**
         * Encodes the specified AtomicTransaction message, length delimited. Does not implicitly {@link wavesenterprise.AtomicTransaction.verify|verify} messages.
         * @function encodeDelimited
         * @memberof wavesenterprise.AtomicTransaction
         * @static
         * @param {wavesenterprise.IAtomicTransaction} message AtomicTransaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AtomicTransaction.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AtomicTransaction message from the specified reader or buffer.
         * @function decode
         * @memberof wavesenterprise.AtomicTransaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {wavesenterprise.AtomicTransaction} AtomicTransaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AtomicTransaction.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.wavesenterprise.AtomicTransaction();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.bytes();
                    break;
                case 2:
                    message.senderPublicKey = reader.bytes();
                    break;
                case 3:
                    message.miner = $root.google.protobuf.BytesValue.decode(reader, reader.uint32());
                    break;
                case 4:
                    if (!(message.transactions && message.transactions.length))
                        message.transactions = [];
                    message.transactions.push($root.wavesenterprise.AtomicInnerTransaction.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.timestamp = reader.int64();
                    break;
                case 6:
                    if (!(message.proofs && message.proofs.length))
                        message.proofs = [];
                    message.proofs.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AtomicTransaction message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof wavesenterprise.AtomicTransaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {wavesenterprise.AtomicTransaction} AtomicTransaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AtomicTransaction.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AtomicTransaction message.
         * @function verify
         * @memberof wavesenterprise.AtomicTransaction
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AtomicTransaction.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!(message.id && typeof message.id.length === "number" || $util.isString(message.id)))
                    return "id: buffer expected";
            if (message.senderPublicKey != null && message.hasOwnProperty("senderPublicKey"))
                if (!(message.senderPublicKey && typeof message.senderPublicKey.length === "number" || $util.isString(message.senderPublicKey)))
                    return "senderPublicKey: buffer expected";
            if (message.miner != null && message.hasOwnProperty("miner")) {
                var error = $root.google.protobuf.BytesValue.verify(message.miner);
                if (error)
                    return "miner." + error;
            }
            if (message.transactions != null && message.hasOwnProperty("transactions")) {
                if (!Array.isArray(message.transactions))
                    return "transactions: array expected";
                for (var i = 0; i < message.transactions.length; ++i) {
                    var error = $root.wavesenterprise.AtomicInnerTransaction.verify(message.transactions[i]);
                    if (error)
                        return "transactions." + error;
                }
            }
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            if (message.proofs != null && message.hasOwnProperty("proofs")) {
                if (!Array.isArray(message.proofs))
                    return "proofs: array expected";
                for (var i = 0; i < message.proofs.length; ++i)
                    if (!(message.proofs[i] && typeof message.proofs[i].length === "number" || $util.isString(message.proofs[i])))
                        return "proofs: buffer[] expected";
            }
            return null;
        };

        /**
         * Creates an AtomicTransaction message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof wavesenterprise.AtomicTransaction
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {wavesenterprise.AtomicTransaction} AtomicTransaction
         */
        AtomicTransaction.fromObject = function fromObject(object) {
            if (object instanceof $root.wavesenterprise.AtomicTransaction)
                return object;
            var message = new $root.wavesenterprise.AtomicTransaction();
            if (object.id != null)
                if (typeof object.id === "string")
                    $util.base64.decode(object.id, message.id = $util.newBuffer($util.base64.length(object.id)), 0);
                else if (object.id.length)
                    message.id = object.id;
            if (object.senderPublicKey != null)
                if (typeof object.senderPublicKey === "string")
                    $util.base64.decode(object.senderPublicKey, message.senderPublicKey = $util.newBuffer($util.base64.length(object.senderPublicKey)), 0);
                else if (object.senderPublicKey.length)
                    message.senderPublicKey = object.senderPublicKey;
            if (object.miner != null) {
                if (typeof object.miner !== "object")
                    throw TypeError(".wavesenterprise.AtomicTransaction.miner: object expected");
                message.miner = $root.google.protobuf.BytesValue.fromObject(object.miner);
            }
            if (object.transactions) {
                if (!Array.isArray(object.transactions))
                    throw TypeError(".wavesenterprise.AtomicTransaction.transactions: array expected");
                message.transactions = [];
                for (var i = 0; i < object.transactions.length; ++i) {
                    if (typeof object.transactions[i] !== "object")
                        throw TypeError(".wavesenterprise.AtomicTransaction.transactions: object expected");
                    message.transactions[i] = $root.wavesenterprise.AtomicInnerTransaction.fromObject(object.transactions[i]);
                }
            }
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            if (object.proofs) {
                if (!Array.isArray(object.proofs))
                    throw TypeError(".wavesenterprise.AtomicTransaction.proofs: array expected");
                message.proofs = [];
                for (var i = 0; i < object.proofs.length; ++i)
                    if (typeof object.proofs[i] === "string")
                        $util.base64.decode(object.proofs[i], message.proofs[i] = $util.newBuffer($util.base64.length(object.proofs[i])), 0);
                    else if (object.proofs[i].length)
                        message.proofs[i] = object.proofs[i];
            }
            return message;
        };

        /**
         * Creates a plain object from an AtomicTransaction message. Also converts values to other types if specified.
         * @function toObject
         * @memberof wavesenterprise.AtomicTransaction
         * @static
         * @param {wavesenterprise.AtomicTransaction} message AtomicTransaction
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AtomicTransaction.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.transactions = [];
                object.proofs = [];
            }
            if (options.defaults) {
                if (options.bytes === String)
                    object.id = "";
                else {
                    object.id = [];
                    if (options.bytes !== Array)
                        object.id = $util.newBuffer(object.id);
                }
                if (options.bytes === String)
                    object.senderPublicKey = "";
                else {
                    object.senderPublicKey = [];
                    if (options.bytes !== Array)
                        object.senderPublicKey = $util.newBuffer(object.senderPublicKey);
                }
                object.miner = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = options.bytes === String ? $util.base64.encode(message.id, 0, message.id.length) : options.bytes === Array ? Array.prototype.slice.call(message.id) : message.id;
            if (message.senderPublicKey != null && message.hasOwnProperty("senderPublicKey"))
                object.senderPublicKey = options.bytes === String ? $util.base64.encode(message.senderPublicKey, 0, message.senderPublicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.senderPublicKey) : message.senderPublicKey;
            if (message.miner != null && message.hasOwnProperty("miner"))
                object.miner = $root.google.protobuf.BytesValue.toObject(message.miner, options);
            if (message.transactions && message.transactions.length) {
                object.transactions = [];
                for (var j = 0; j < message.transactions.length; ++j)
                    object.transactions[j] = $root.wavesenterprise.AtomicInnerTransaction.toObject(message.transactions[j], options);
            }
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            if (message.proofs && message.proofs.length) {
                object.proofs = [];
                for (var j = 0; j < message.proofs.length; ++j)
                    object.proofs[j] = options.bytes === String ? $util.base64.encode(message.proofs[j], 0, message.proofs[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.proofs[j]) : message.proofs[j];
            }
            return object;
        };

        /**
         * Converts this AtomicTransaction to JSON.
         * @function toJSON
         * @memberof wavesenterprise.AtomicTransaction
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AtomicTransaction.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AtomicTransaction;
    })();

    wavesenterprise.AtomicInnerTransaction = (function() {

        /**
         * Properties of an AtomicInnerTransaction.
         * @memberof wavesenterprise
         * @interface IAtomicInnerTransaction
         * @property {number|null} [version] AtomicInnerTransaction version
         * @property {wavesenterprise.IGenesisTransaction|null} [genesisTransaction] AtomicInnerTransaction genesisTransaction
         * @property {wavesenterprise.IGenesisPermitTransaction|null} [genesisPermitTransaction] AtomicInnerTransaction genesisPermitTransaction
         * @property {wavesenterprise.IGenesisRegisterNodeTransaction|null} [genesisRegisterNodeTransaction] AtomicInnerTransaction genesisRegisterNodeTransaction
         * @property {wavesenterprise.IRegisterNodeTransaction|null} [registerNodeTransaction] AtomicInnerTransaction registerNodeTransaction
         * @property {wavesenterprise.ICreateAliasTransaction|null} [createAliasTransaction] AtomicInnerTransaction createAliasTransaction
         * @property {wavesenterprise.IIssueTransaction|null} [issueTransaction] AtomicInnerTransaction issueTransaction
         * @property {wavesenterprise.IReissueTransaction|null} [reissueTransaction] AtomicInnerTransaction reissueTransaction
         * @property {wavesenterprise.IBurnTransaction|null} [burnTransaction] AtomicInnerTransaction burnTransaction
         * @property {wavesenterprise.ILeaseTransaction|null} [leaseTransaction] AtomicInnerTransaction leaseTransaction
         * @property {wavesenterprise.ILeaseCancelTransaction|null} [leaseCancelTransaction] AtomicInnerTransaction leaseCancelTransaction
         * @property {wavesenterprise.ISponsorFeeTransaction|null} [sponsorFeeTransaction] AtomicInnerTransaction sponsorFeeTransaction
         * @property {wavesenterprise.ISetAssetScriptTransaction|null} [setAssetScriptTransaction] AtomicInnerTransaction setAssetScriptTransaction
         * @property {wavesenterprise.IDataTransaction|null} [dataTransaction] AtomicInnerTransaction dataTransaction
         * @property {wavesenterprise.ITransferTransaction|null} [transferTransaction] AtomicInnerTransaction transferTransaction
         * @property {wavesenterprise.IMassTransferTransaction|null} [massTransferTransaction] AtomicInnerTransaction massTransferTransaction
         * @property {wavesenterprise.IPermitTransaction|null} [permitTransaction] AtomicInnerTransaction permitTransaction
         * @property {wavesenterprise.ICreatePolicyTransaction|null} [createPolicyTransaction] AtomicInnerTransaction createPolicyTransaction
         * @property {wavesenterprise.IUpdatePolicyTransaction|null} [updatePolicyTransaction] AtomicInnerTransaction updatePolicyTransaction
         * @property {wavesenterprise.IPolicyDataHashTransaction|null} [policyDataHashTransaction] AtomicInnerTransaction policyDataHashTransaction
         * @property {wavesenterprise.ICreateContractTransaction|null} [createContractTransaction] AtomicInnerTransaction createContractTransaction
         * @property {wavesenterprise.ICallContractTransaction|null} [callContractTransaction] AtomicInnerTransaction callContractTransaction
         * @property {wavesenterprise.IExecutedContractTransaction|null} [executedContractTransaction] AtomicInnerTransaction executedContractTransaction
         * @property {wavesenterprise.IDisableContractTransaction|null} [disableContractTransaction] AtomicInnerTransaction disableContractTransaction
         * @property {wavesenterprise.IUpdateContractTransaction|null} [updateContractTransaction] AtomicInnerTransaction updateContractTransaction
         * @property {wavesenterprise.ISetScriptTransaction|null} [setScriptTransaction] AtomicInnerTransaction setScriptTransaction
         */

        /**
         * Constructs a new AtomicInnerTransaction.
         * @memberof wavesenterprise
         * @classdesc Represents an AtomicInnerTransaction.
         * @implements IAtomicInnerTransaction
         * @constructor
         * @param {wavesenterprise.IAtomicInnerTransaction=} [properties] Properties to set
         */
        function AtomicInnerTransaction(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AtomicInnerTransaction version.
         * @member {number} version
         * @memberof wavesenterprise.AtomicInnerTransaction
         * @instance
         */
        AtomicInnerTransaction.prototype.version = 0;

        /**
         * AtomicInnerTransaction genesisTransaction.
         * @member {wavesenterprise.IGenesisTransaction|null|undefined} genesisTransaction
         * @memberof wavesenterprise.AtomicInnerTransaction
         * @instance
         */
        AtomicInnerTransaction.prototype.genesisTransaction = null;

        /**
         * AtomicInnerTransaction genesisPermitTransaction.
         * @member {wavesenterprise.IGenesisPermitTransaction|null|undefined} genesisPermitTransaction
         * @memberof wavesenterprise.AtomicInnerTransaction
         * @instance
         */
        AtomicInnerTransaction.prototype.genesisPermitTransaction = null;

        /**
         * AtomicInnerTransaction genesisRegisterNodeTransaction.
         * @member {wavesenterprise.IGenesisRegisterNodeTransaction|null|undefined} genesisRegisterNodeTransaction
         * @memberof wavesenterprise.AtomicInnerTransaction
         * @instance
         */
        AtomicInnerTransaction.prototype.genesisRegisterNodeTransaction = null;

        /**
         * AtomicInnerTransaction registerNodeTransaction.
         * @member {wavesenterprise.IRegisterNodeTransaction|null|undefined} registerNodeTransaction
         * @memberof wavesenterprise.AtomicInnerTransaction
         * @instance
         */
        AtomicInnerTransaction.prototype.registerNodeTransaction = null;

        /**
         * AtomicInnerTransaction createAliasTransaction.
         * @member {wavesenterprise.ICreateAliasTransaction|null|undefined} createAliasTransaction
         * @memberof wavesenterprise.AtomicInnerTransaction
         * @instance
         */
        AtomicInnerTransaction.prototype.createAliasTransaction = null;

        /**
         * AtomicInnerTransaction issueTransaction.
         * @member {wavesenterprise.IIssueTransaction|null|undefined} issueTransaction
         * @memberof wavesenterprise.AtomicInnerTransaction
         * @instance
         */
        AtomicInnerTransaction.prototype.issueTransaction = null;

        /**
         * AtomicInnerTransaction reissueTransaction.
         * @member {wavesenterprise.IReissueTransaction|null|undefined} reissueTransaction
         * @memberof wavesenterprise.AtomicInnerTransaction
         * @instance
         */
        AtomicInnerTransaction.prototype.reissueTransaction = null;

        /**
         * AtomicInnerTransaction burnTransaction.
         * @member {wavesenterprise.IBurnTransaction|null|undefined} burnTransaction
         * @memberof wavesenterprise.AtomicInnerTransaction
         * @instance
         */
        AtomicInnerTransaction.prototype.burnTransaction = null;

        /**
         * AtomicInnerTransaction leaseTransaction.
         * @member {wavesenterprise.ILeaseTransaction|null|undefined} leaseTransaction
         * @memberof wavesenterprise.AtomicInnerTransaction
         * @instance
         */
        AtomicInnerTransaction.prototype.leaseTransaction = null;

        /**
         * AtomicInnerTransaction leaseCancelTransaction.
         * @member {wavesenterprise.ILeaseCancelTransaction|null|undefined} leaseCancelTransaction
         * @memberof wavesenterprise.AtomicInnerTransaction
         * @instance
         */
        AtomicInnerTransaction.prototype.leaseCancelTransaction = null;

        /**
         * AtomicInnerTransaction sponsorFeeTransaction.
         * @member {wavesenterprise.ISponsorFeeTransaction|null|undefined} sponsorFeeTransaction
         * @memberof wavesenterprise.AtomicInnerTransaction
         * @instance
         */
        AtomicInnerTransaction.prototype.sponsorFeeTransaction = null;

        /**
         * AtomicInnerTransaction setAssetScriptTransaction.
         * @member {wavesenterprise.ISetAssetScriptTransaction|null|undefined} setAssetScriptTransaction
         * @memberof wavesenterprise.AtomicInnerTransaction
         * @instance
         */
        AtomicInnerTransaction.prototype.setAssetScriptTransaction = null;

        /**
         * AtomicInnerTransaction dataTransaction.
         * @member {wavesenterprise.IDataTransaction|null|undefined} dataTransaction
         * @memberof wavesenterprise.AtomicInnerTransaction
         * @instance
         */
        AtomicInnerTransaction.prototype.dataTransaction = null;

        /**
         * AtomicInnerTransaction transferTransaction.
         * @member {wavesenterprise.ITransferTransaction|null|undefined} transferTransaction
         * @memberof wavesenterprise.AtomicInnerTransaction
         * @instance
         */
        AtomicInnerTransaction.prototype.transferTransaction = null;

        /**
         * AtomicInnerTransaction massTransferTransaction.
         * @member {wavesenterprise.IMassTransferTransaction|null|undefined} massTransferTransaction
         * @memberof wavesenterprise.AtomicInnerTransaction
         * @instance
         */
        AtomicInnerTransaction.prototype.massTransferTransaction = null;

        /**
         * AtomicInnerTransaction permitTransaction.
         * @member {wavesenterprise.IPermitTransaction|null|undefined} permitTransaction
         * @memberof wavesenterprise.AtomicInnerTransaction
         * @instance
         */
        AtomicInnerTransaction.prototype.permitTransaction = null;

        /**
         * AtomicInnerTransaction createPolicyTransaction.
         * @member {wavesenterprise.ICreatePolicyTransaction|null|undefined} createPolicyTransaction
         * @memberof wavesenterprise.AtomicInnerTransaction
         * @instance
         */
        AtomicInnerTransaction.prototype.createPolicyTransaction = null;

        /**
         * AtomicInnerTransaction updatePolicyTransaction.
         * @member {wavesenterprise.IUpdatePolicyTransaction|null|undefined} updatePolicyTransaction
         * @memberof wavesenterprise.AtomicInnerTransaction
         * @instance
         */
        AtomicInnerTransaction.prototype.updatePolicyTransaction = null;

        /**
         * AtomicInnerTransaction policyDataHashTransaction.
         * @member {wavesenterprise.IPolicyDataHashTransaction|null|undefined} policyDataHashTransaction
         * @memberof wavesenterprise.AtomicInnerTransaction
         * @instance
         */
        AtomicInnerTransaction.prototype.policyDataHashTransaction = null;

        /**
         * AtomicInnerTransaction createContractTransaction.
         * @member {wavesenterprise.ICreateContractTransaction|null|undefined} createContractTransaction
         * @memberof wavesenterprise.AtomicInnerTransaction
         * @instance
         */
        AtomicInnerTransaction.prototype.createContractTransaction = null;

        /**
         * AtomicInnerTransaction callContractTransaction.
         * @member {wavesenterprise.ICallContractTransaction|null|undefined} callContractTransaction
         * @memberof wavesenterprise.AtomicInnerTransaction
         * @instance
         */
        AtomicInnerTransaction.prototype.callContractTransaction = null;

        /**
         * AtomicInnerTransaction executedContractTransaction.
         * @member {wavesenterprise.IExecutedContractTransaction|null|undefined} executedContractTransaction
         * @memberof wavesenterprise.AtomicInnerTransaction
         * @instance
         */
        AtomicInnerTransaction.prototype.executedContractTransaction = null;

        /**
         * AtomicInnerTransaction disableContractTransaction.
         * @member {wavesenterprise.IDisableContractTransaction|null|undefined} disableContractTransaction
         * @memberof wavesenterprise.AtomicInnerTransaction
         * @instance
         */
        AtomicInnerTransaction.prototype.disableContractTransaction = null;

        /**
         * AtomicInnerTransaction updateContractTransaction.
         * @member {wavesenterprise.IUpdateContractTransaction|null|undefined} updateContractTransaction
         * @memberof wavesenterprise.AtomicInnerTransaction
         * @instance
         */
        AtomicInnerTransaction.prototype.updateContractTransaction = null;

        /**
         * AtomicInnerTransaction setScriptTransaction.
         * @member {wavesenterprise.ISetScriptTransaction|null|undefined} setScriptTransaction
         * @memberof wavesenterprise.AtomicInnerTransaction
         * @instance
         */
        AtomicInnerTransaction.prototype.setScriptTransaction = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * AtomicInnerTransaction transaction.
         * @member {"genesisTransaction"|"genesisPermitTransaction"|"genesisRegisterNodeTransaction"|"registerNodeTransaction"|"createAliasTransaction"|"issueTransaction"|"reissueTransaction"|"burnTransaction"|"leaseTransaction"|"leaseCancelTransaction"|"sponsorFeeTransaction"|"setAssetScriptTransaction"|"dataTransaction"|"transferTransaction"|"massTransferTransaction"|"permitTransaction"|"createPolicyTransaction"|"updatePolicyTransaction"|"policyDataHashTransaction"|"createContractTransaction"|"callContractTransaction"|"executedContractTransaction"|"disableContractTransaction"|"updateContractTransaction"|"setScriptTransaction"|undefined} transaction
         * @memberof wavesenterprise.AtomicInnerTransaction
         * @instance
         */
        Object.defineProperty(AtomicInnerTransaction.prototype, "transaction", {
            get: $util.oneOfGetter($oneOfFields = ["genesisTransaction", "genesisPermitTransaction", "genesisRegisterNodeTransaction", "registerNodeTransaction", "createAliasTransaction", "issueTransaction", "reissueTransaction", "burnTransaction", "leaseTransaction", "leaseCancelTransaction", "sponsorFeeTransaction", "setAssetScriptTransaction", "dataTransaction", "transferTransaction", "massTransferTransaction", "permitTransaction", "createPolicyTransaction", "updatePolicyTransaction", "policyDataHashTransaction", "createContractTransaction", "callContractTransaction", "executedContractTransaction", "disableContractTransaction", "updateContractTransaction", "setScriptTransaction"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new AtomicInnerTransaction instance using the specified properties.
         * @function create
         * @memberof wavesenterprise.AtomicInnerTransaction
         * @static
         * @param {wavesenterprise.IAtomicInnerTransaction=} [properties] Properties to set
         * @returns {wavesenterprise.AtomicInnerTransaction} AtomicInnerTransaction instance
         */
        AtomicInnerTransaction.create = function create(properties) {
            return new AtomicInnerTransaction(properties);
        };

        /**
         * Encodes the specified AtomicInnerTransaction message. Does not implicitly {@link wavesenterprise.AtomicInnerTransaction.verify|verify} messages.
         * @function encode
         * @memberof wavesenterprise.AtomicInnerTransaction
         * @static
         * @param {wavesenterprise.IAtomicInnerTransaction} message AtomicInnerTransaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AtomicInnerTransaction.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.version);
            if (message.genesisTransaction != null && Object.hasOwnProperty.call(message, "genesisTransaction"))
                $root.wavesenterprise.GenesisTransaction.encode(message.genesisTransaction, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
            if (message.genesisPermitTransaction != null && Object.hasOwnProperty.call(message, "genesisPermitTransaction"))
                $root.wavesenterprise.GenesisPermitTransaction.encode(message.genesisPermitTransaction, writer.uint32(/* id 1001, wireType 2 =*/8010).fork()).ldelim();
            if (message.genesisRegisterNodeTransaction != null && Object.hasOwnProperty.call(message, "genesisRegisterNodeTransaction"))
                $root.wavesenterprise.GenesisRegisterNodeTransaction.encode(message.genesisRegisterNodeTransaction, writer.uint32(/* id 1002, wireType 2 =*/8018).fork()).ldelim();
            if (message.registerNodeTransaction != null && Object.hasOwnProperty.call(message, "registerNodeTransaction"))
                $root.wavesenterprise.RegisterNodeTransaction.encode(message.registerNodeTransaction, writer.uint32(/* id 1003, wireType 2 =*/8026).fork()).ldelim();
            if (message.createAliasTransaction != null && Object.hasOwnProperty.call(message, "createAliasTransaction"))
                $root.wavesenterprise.CreateAliasTransaction.encode(message.createAliasTransaction, writer.uint32(/* id 1004, wireType 2 =*/8034).fork()).ldelim();
            if (message.issueTransaction != null && Object.hasOwnProperty.call(message, "issueTransaction"))
                $root.wavesenterprise.IssueTransaction.encode(message.issueTransaction, writer.uint32(/* id 1005, wireType 2 =*/8042).fork()).ldelim();
            if (message.reissueTransaction != null && Object.hasOwnProperty.call(message, "reissueTransaction"))
                $root.wavesenterprise.ReissueTransaction.encode(message.reissueTransaction, writer.uint32(/* id 1006, wireType 2 =*/8050).fork()).ldelim();
            if (message.burnTransaction != null && Object.hasOwnProperty.call(message, "burnTransaction"))
                $root.wavesenterprise.BurnTransaction.encode(message.burnTransaction, writer.uint32(/* id 1007, wireType 2 =*/8058).fork()).ldelim();
            if (message.leaseTransaction != null && Object.hasOwnProperty.call(message, "leaseTransaction"))
                $root.wavesenterprise.LeaseTransaction.encode(message.leaseTransaction, writer.uint32(/* id 1008, wireType 2 =*/8066).fork()).ldelim();
            if (message.leaseCancelTransaction != null && Object.hasOwnProperty.call(message, "leaseCancelTransaction"))
                $root.wavesenterprise.LeaseCancelTransaction.encode(message.leaseCancelTransaction, writer.uint32(/* id 1009, wireType 2 =*/8074).fork()).ldelim();
            if (message.sponsorFeeTransaction != null && Object.hasOwnProperty.call(message, "sponsorFeeTransaction"))
                $root.wavesenterprise.SponsorFeeTransaction.encode(message.sponsorFeeTransaction, writer.uint32(/* id 1010, wireType 2 =*/8082).fork()).ldelim();
            if (message.setAssetScriptTransaction != null && Object.hasOwnProperty.call(message, "setAssetScriptTransaction"))
                $root.wavesenterprise.SetAssetScriptTransaction.encode(message.setAssetScriptTransaction, writer.uint32(/* id 1011, wireType 2 =*/8090).fork()).ldelim();
            if (message.dataTransaction != null && Object.hasOwnProperty.call(message, "dataTransaction"))
                $root.wavesenterprise.DataTransaction.encode(message.dataTransaction, writer.uint32(/* id 1012, wireType 2 =*/8098).fork()).ldelim();
            if (message.transferTransaction != null && Object.hasOwnProperty.call(message, "transferTransaction"))
                $root.wavesenterprise.TransferTransaction.encode(message.transferTransaction, writer.uint32(/* id 1013, wireType 2 =*/8106).fork()).ldelim();
            if (message.massTransferTransaction != null && Object.hasOwnProperty.call(message, "massTransferTransaction"))
                $root.wavesenterprise.MassTransferTransaction.encode(message.massTransferTransaction, writer.uint32(/* id 1014, wireType 2 =*/8114).fork()).ldelim();
            if (message.permitTransaction != null && Object.hasOwnProperty.call(message, "permitTransaction"))
                $root.wavesenterprise.PermitTransaction.encode(message.permitTransaction, writer.uint32(/* id 1015, wireType 2 =*/8122).fork()).ldelim();
            if (message.createPolicyTransaction != null && Object.hasOwnProperty.call(message, "createPolicyTransaction"))
                $root.wavesenterprise.CreatePolicyTransaction.encode(message.createPolicyTransaction, writer.uint32(/* id 1016, wireType 2 =*/8130).fork()).ldelim();
            if (message.updatePolicyTransaction != null && Object.hasOwnProperty.call(message, "updatePolicyTransaction"))
                $root.wavesenterprise.UpdatePolicyTransaction.encode(message.updatePolicyTransaction, writer.uint32(/* id 1017, wireType 2 =*/8138).fork()).ldelim();
            if (message.policyDataHashTransaction != null && Object.hasOwnProperty.call(message, "policyDataHashTransaction"))
                $root.wavesenterprise.PolicyDataHashTransaction.encode(message.policyDataHashTransaction, writer.uint32(/* id 1018, wireType 2 =*/8146).fork()).ldelim();
            if (message.createContractTransaction != null && Object.hasOwnProperty.call(message, "createContractTransaction"))
                $root.wavesenterprise.CreateContractTransaction.encode(message.createContractTransaction, writer.uint32(/* id 1019, wireType 2 =*/8154).fork()).ldelim();
            if (message.callContractTransaction != null && Object.hasOwnProperty.call(message, "callContractTransaction"))
                $root.wavesenterprise.CallContractTransaction.encode(message.callContractTransaction, writer.uint32(/* id 1020, wireType 2 =*/8162).fork()).ldelim();
            if (message.executedContractTransaction != null && Object.hasOwnProperty.call(message, "executedContractTransaction"))
                $root.wavesenterprise.ExecutedContractTransaction.encode(message.executedContractTransaction, writer.uint32(/* id 1021, wireType 2 =*/8170).fork()).ldelim();
            if (message.disableContractTransaction != null && Object.hasOwnProperty.call(message, "disableContractTransaction"))
                $root.wavesenterprise.DisableContractTransaction.encode(message.disableContractTransaction, writer.uint32(/* id 1022, wireType 2 =*/8178).fork()).ldelim();
            if (message.updateContractTransaction != null && Object.hasOwnProperty.call(message, "updateContractTransaction"))
                $root.wavesenterprise.UpdateContractTransaction.encode(message.updateContractTransaction, writer.uint32(/* id 1023, wireType 2 =*/8186).fork()).ldelim();
            if (message.setScriptTransaction != null && Object.hasOwnProperty.call(message, "setScriptTransaction"))
                $root.wavesenterprise.SetScriptTransaction.encode(message.setScriptTransaction, writer.uint32(/* id 1024, wireType 2 =*/8194).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified AtomicInnerTransaction message, length delimited. Does not implicitly {@link wavesenterprise.AtomicInnerTransaction.verify|verify} messages.
         * @function encodeDelimited
         * @memberof wavesenterprise.AtomicInnerTransaction
         * @static
         * @param {wavesenterprise.IAtomicInnerTransaction} message AtomicInnerTransaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AtomicInnerTransaction.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AtomicInnerTransaction message from the specified reader or buffer.
         * @function decode
         * @memberof wavesenterprise.AtomicInnerTransaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {wavesenterprise.AtomicInnerTransaction} AtomicInnerTransaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AtomicInnerTransaction.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.wavesenterprise.AtomicInnerTransaction();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.version = reader.int32();
                    break;
                case 1000:
                    message.genesisTransaction = $root.wavesenterprise.GenesisTransaction.decode(reader, reader.uint32());
                    break;
                case 1001:
                    message.genesisPermitTransaction = $root.wavesenterprise.GenesisPermitTransaction.decode(reader, reader.uint32());
                    break;
                case 1002:
                    message.genesisRegisterNodeTransaction = $root.wavesenterprise.GenesisRegisterNodeTransaction.decode(reader, reader.uint32());
                    break;
                case 1003:
                    message.registerNodeTransaction = $root.wavesenterprise.RegisterNodeTransaction.decode(reader, reader.uint32());
                    break;
                case 1004:
                    message.createAliasTransaction = $root.wavesenterprise.CreateAliasTransaction.decode(reader, reader.uint32());
                    break;
                case 1005:
                    message.issueTransaction = $root.wavesenterprise.IssueTransaction.decode(reader, reader.uint32());
                    break;
                case 1006:
                    message.reissueTransaction = $root.wavesenterprise.ReissueTransaction.decode(reader, reader.uint32());
                    break;
                case 1007:
                    message.burnTransaction = $root.wavesenterprise.BurnTransaction.decode(reader, reader.uint32());
                    break;
                case 1008:
                    message.leaseTransaction = $root.wavesenterprise.LeaseTransaction.decode(reader, reader.uint32());
                    break;
                case 1009:
                    message.leaseCancelTransaction = $root.wavesenterprise.LeaseCancelTransaction.decode(reader, reader.uint32());
                    break;
                case 1010:
                    message.sponsorFeeTransaction = $root.wavesenterprise.SponsorFeeTransaction.decode(reader, reader.uint32());
                    break;
                case 1011:
                    message.setAssetScriptTransaction = $root.wavesenterprise.SetAssetScriptTransaction.decode(reader, reader.uint32());
                    break;
                case 1012:
                    message.dataTransaction = $root.wavesenterprise.DataTransaction.decode(reader, reader.uint32());
                    break;
                case 1013:
                    message.transferTransaction = $root.wavesenterprise.TransferTransaction.decode(reader, reader.uint32());
                    break;
                case 1014:
                    message.massTransferTransaction = $root.wavesenterprise.MassTransferTransaction.decode(reader, reader.uint32());
                    break;
                case 1015:
                    message.permitTransaction = $root.wavesenterprise.PermitTransaction.decode(reader, reader.uint32());
                    break;
                case 1016:
                    message.createPolicyTransaction = $root.wavesenterprise.CreatePolicyTransaction.decode(reader, reader.uint32());
                    break;
                case 1017:
                    message.updatePolicyTransaction = $root.wavesenterprise.UpdatePolicyTransaction.decode(reader, reader.uint32());
                    break;
                case 1018:
                    message.policyDataHashTransaction = $root.wavesenterprise.PolicyDataHashTransaction.decode(reader, reader.uint32());
                    break;
                case 1019:
                    message.createContractTransaction = $root.wavesenterprise.CreateContractTransaction.decode(reader, reader.uint32());
                    break;
                case 1020:
                    message.callContractTransaction = $root.wavesenterprise.CallContractTransaction.decode(reader, reader.uint32());
                    break;
                case 1021:
                    message.executedContractTransaction = $root.wavesenterprise.ExecutedContractTransaction.decode(reader, reader.uint32());
                    break;
                case 1022:
                    message.disableContractTransaction = $root.wavesenterprise.DisableContractTransaction.decode(reader, reader.uint32());
                    break;
                case 1023:
                    message.updateContractTransaction = $root.wavesenterprise.UpdateContractTransaction.decode(reader, reader.uint32());
                    break;
                case 1024:
                    message.setScriptTransaction = $root.wavesenterprise.SetScriptTransaction.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AtomicInnerTransaction message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof wavesenterprise.AtomicInnerTransaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {wavesenterprise.AtomicInnerTransaction} AtomicInnerTransaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AtomicInnerTransaction.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AtomicInnerTransaction message.
         * @function verify
         * @memberof wavesenterprise.AtomicInnerTransaction
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AtomicInnerTransaction.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isInteger(message.version))
                    return "version: integer expected";
            if (message.genesisTransaction != null && message.hasOwnProperty("genesisTransaction")) {
                properties.transaction = 1;
                {
                    var error = $root.wavesenterprise.GenesisTransaction.verify(message.genesisTransaction);
                    if (error)
                        return "genesisTransaction." + error;
                }
            }
            if (message.genesisPermitTransaction != null && message.hasOwnProperty("genesisPermitTransaction")) {
                if (properties.transaction === 1)
                    return "transaction: multiple values";
                properties.transaction = 1;
                {
                    var error = $root.wavesenterprise.GenesisPermitTransaction.verify(message.genesisPermitTransaction);
                    if (error)
                        return "genesisPermitTransaction." + error;
                }
            }
            if (message.genesisRegisterNodeTransaction != null && message.hasOwnProperty("genesisRegisterNodeTransaction")) {
                if (properties.transaction === 1)
                    return "transaction: multiple values";
                properties.transaction = 1;
                {
                    var error = $root.wavesenterprise.GenesisRegisterNodeTransaction.verify(message.genesisRegisterNodeTransaction);
                    if (error)
                        return "genesisRegisterNodeTransaction." + error;
                }
            }
            if (message.registerNodeTransaction != null && message.hasOwnProperty("registerNodeTransaction")) {
                if (properties.transaction === 1)
                    return "transaction: multiple values";
                properties.transaction = 1;
                {
                    var error = $root.wavesenterprise.RegisterNodeTransaction.verify(message.registerNodeTransaction);
                    if (error)
                        return "registerNodeTransaction." + error;
                }
            }
            if (message.createAliasTransaction != null && message.hasOwnProperty("createAliasTransaction")) {
                if (properties.transaction === 1)
                    return "transaction: multiple values";
                properties.transaction = 1;
                {
                    var error = $root.wavesenterprise.CreateAliasTransaction.verify(message.createAliasTransaction);
                    if (error)
                        return "createAliasTransaction." + error;
                }
            }
            if (message.issueTransaction != null && message.hasOwnProperty("issueTransaction")) {
                if (properties.transaction === 1)
                    return "transaction: multiple values";
                properties.transaction = 1;
                {
                    var error = $root.wavesenterprise.IssueTransaction.verify(message.issueTransaction);
                    if (error)
                        return "issueTransaction." + error;
                }
            }
            if (message.reissueTransaction != null && message.hasOwnProperty("reissueTransaction")) {
                if (properties.transaction === 1)
                    return "transaction: multiple values";
                properties.transaction = 1;
                {
                    var error = $root.wavesenterprise.ReissueTransaction.verify(message.reissueTransaction);
                    if (error)
                        return "reissueTransaction." + error;
                }
            }
            if (message.burnTransaction != null && message.hasOwnProperty("burnTransaction")) {
                if (properties.transaction === 1)
                    return "transaction: multiple values";
                properties.transaction = 1;
                {
                    var error = $root.wavesenterprise.BurnTransaction.verify(message.burnTransaction);
                    if (error)
                        return "burnTransaction." + error;
                }
            }
            if (message.leaseTransaction != null && message.hasOwnProperty("leaseTransaction")) {
                if (properties.transaction === 1)
                    return "transaction: multiple values";
                properties.transaction = 1;
                {
                    var error = $root.wavesenterprise.LeaseTransaction.verify(message.leaseTransaction);
                    if (error)
                        return "leaseTransaction." + error;
                }
            }
            if (message.leaseCancelTransaction != null && message.hasOwnProperty("leaseCancelTransaction")) {
                if (properties.transaction === 1)
                    return "transaction: multiple values";
                properties.transaction = 1;
                {
                    var error = $root.wavesenterprise.LeaseCancelTransaction.verify(message.leaseCancelTransaction);
                    if (error)
                        return "leaseCancelTransaction." + error;
                }
            }
            if (message.sponsorFeeTransaction != null && message.hasOwnProperty("sponsorFeeTransaction")) {
                if (properties.transaction === 1)
                    return "transaction: multiple values";
                properties.transaction = 1;
                {
                    var error = $root.wavesenterprise.SponsorFeeTransaction.verify(message.sponsorFeeTransaction);
                    if (error)
                        return "sponsorFeeTransaction." + error;
                }
            }
            if (message.setAssetScriptTransaction != null && message.hasOwnProperty("setAssetScriptTransaction")) {
                if (properties.transaction === 1)
                    return "transaction: multiple values";
                properties.transaction = 1;
                {
                    var error = $root.wavesenterprise.SetAssetScriptTransaction.verify(message.setAssetScriptTransaction);
                    if (error)
                        return "setAssetScriptTransaction." + error;
                }
            }
            if (message.dataTransaction != null && message.hasOwnProperty("dataTransaction")) {
                if (properties.transaction === 1)
                    return "transaction: multiple values";
                properties.transaction = 1;
                {
                    var error = $root.wavesenterprise.DataTransaction.verify(message.dataTransaction);
                    if (error)
                        return "dataTransaction." + error;
                }
            }
            if (message.transferTransaction != null && message.hasOwnProperty("transferTransaction")) {
                if (properties.transaction === 1)
                    return "transaction: multiple values";
                properties.transaction = 1;
                {
                    var error = $root.wavesenterprise.TransferTransaction.verify(message.transferTransaction);
                    if (error)
                        return "transferTransaction." + error;
                }
            }
            if (message.massTransferTransaction != null && message.hasOwnProperty("massTransferTransaction")) {
                if (properties.transaction === 1)
                    return "transaction: multiple values";
                properties.transaction = 1;
                {
                    var error = $root.wavesenterprise.MassTransferTransaction.verify(message.massTransferTransaction);
                    if (error)
                        return "massTransferTransaction." + error;
                }
            }
            if (message.permitTransaction != null && message.hasOwnProperty("permitTransaction")) {
                if (properties.transaction === 1)
                    return "transaction: multiple values";
                properties.transaction = 1;
                {
                    var error = $root.wavesenterprise.PermitTransaction.verify(message.permitTransaction);
                    if (error)
                        return "permitTransaction." + error;
                }
            }
            if (message.createPolicyTransaction != null && message.hasOwnProperty("createPolicyTransaction")) {
                if (properties.transaction === 1)
                    return "transaction: multiple values";
                properties.transaction = 1;
                {
                    var error = $root.wavesenterprise.CreatePolicyTransaction.verify(message.createPolicyTransaction);
                    if (error)
                        return "createPolicyTransaction." + error;
                }
            }
            if (message.updatePolicyTransaction != null && message.hasOwnProperty("updatePolicyTransaction")) {
                if (properties.transaction === 1)
                    return "transaction: multiple values";
                properties.transaction = 1;
                {
                    var error = $root.wavesenterprise.UpdatePolicyTransaction.verify(message.updatePolicyTransaction);
                    if (error)
                        return "updatePolicyTransaction." + error;
                }
            }
            if (message.policyDataHashTransaction != null && message.hasOwnProperty("policyDataHashTransaction")) {
                if (properties.transaction === 1)
                    return "transaction: multiple values";
                properties.transaction = 1;
                {
                    var error = $root.wavesenterprise.PolicyDataHashTransaction.verify(message.policyDataHashTransaction);
                    if (error)
                        return "policyDataHashTransaction." + error;
                }
            }
            if (message.createContractTransaction != null && message.hasOwnProperty("createContractTransaction")) {
                if (properties.transaction === 1)
                    return "transaction: multiple values";
                properties.transaction = 1;
                {
                    var error = $root.wavesenterprise.CreateContractTransaction.verify(message.createContractTransaction);
                    if (error)
                        return "createContractTransaction." + error;
                }
            }
            if (message.callContractTransaction != null && message.hasOwnProperty("callContractTransaction")) {
                if (properties.transaction === 1)
                    return "transaction: multiple values";
                properties.transaction = 1;
                {
                    var error = $root.wavesenterprise.CallContractTransaction.verify(message.callContractTransaction);
                    if (error)
                        return "callContractTransaction." + error;
                }
            }
            if (message.executedContractTransaction != null && message.hasOwnProperty("executedContractTransaction")) {
                if (properties.transaction === 1)
                    return "transaction: multiple values";
                properties.transaction = 1;
                {
                    var error = $root.wavesenterprise.ExecutedContractTransaction.verify(message.executedContractTransaction);
                    if (error)
                        return "executedContractTransaction." + error;
                }
            }
            if (message.disableContractTransaction != null && message.hasOwnProperty("disableContractTransaction")) {
                if (properties.transaction === 1)
                    return "transaction: multiple values";
                properties.transaction = 1;
                {
                    var error = $root.wavesenterprise.DisableContractTransaction.verify(message.disableContractTransaction);
                    if (error)
                        return "disableContractTransaction." + error;
                }
            }
            if (message.updateContractTransaction != null && message.hasOwnProperty("updateContractTransaction")) {
                if (properties.transaction === 1)
                    return "transaction: multiple values";
                properties.transaction = 1;
                {
                    var error = $root.wavesenterprise.UpdateContractTransaction.verify(message.updateContractTransaction);
                    if (error)
                        return "updateContractTransaction." + error;
                }
            }
            if (message.setScriptTransaction != null && message.hasOwnProperty("setScriptTransaction")) {
                if (properties.transaction === 1)
                    return "transaction: multiple values";
                properties.transaction = 1;
                {
                    var error = $root.wavesenterprise.SetScriptTransaction.verify(message.setScriptTransaction);
                    if (error)
                        return "setScriptTransaction." + error;
                }
            }
            return null;
        };

        /**
         * Creates an AtomicInnerTransaction message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof wavesenterprise.AtomicInnerTransaction
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {wavesenterprise.AtomicInnerTransaction} AtomicInnerTransaction
         */
        AtomicInnerTransaction.fromObject = function fromObject(object) {
            if (object instanceof $root.wavesenterprise.AtomicInnerTransaction)
                return object;
            var message = new $root.wavesenterprise.AtomicInnerTransaction();
            if (object.version != null)
                message.version = object.version | 0;
            if (object.genesisTransaction != null) {
                if (typeof object.genesisTransaction !== "object")
                    throw TypeError(".wavesenterprise.AtomicInnerTransaction.genesisTransaction: object expected");
                message.genesisTransaction = $root.wavesenterprise.GenesisTransaction.fromObject(object.genesisTransaction);
            }
            if (object.genesisPermitTransaction != null) {
                if (typeof object.genesisPermitTransaction !== "object")
                    throw TypeError(".wavesenterprise.AtomicInnerTransaction.genesisPermitTransaction: object expected");
                message.genesisPermitTransaction = $root.wavesenterprise.GenesisPermitTransaction.fromObject(object.genesisPermitTransaction);
            }
            if (object.genesisRegisterNodeTransaction != null) {
                if (typeof object.genesisRegisterNodeTransaction !== "object")
                    throw TypeError(".wavesenterprise.AtomicInnerTransaction.genesisRegisterNodeTransaction: object expected");
                message.genesisRegisterNodeTransaction = $root.wavesenterprise.GenesisRegisterNodeTransaction.fromObject(object.genesisRegisterNodeTransaction);
            }
            if (object.registerNodeTransaction != null) {
                if (typeof object.registerNodeTransaction !== "object")
                    throw TypeError(".wavesenterprise.AtomicInnerTransaction.registerNodeTransaction: object expected");
                message.registerNodeTransaction = $root.wavesenterprise.RegisterNodeTransaction.fromObject(object.registerNodeTransaction);
            }
            if (object.createAliasTransaction != null) {
                if (typeof object.createAliasTransaction !== "object")
                    throw TypeError(".wavesenterprise.AtomicInnerTransaction.createAliasTransaction: object expected");
                message.createAliasTransaction = $root.wavesenterprise.CreateAliasTransaction.fromObject(object.createAliasTransaction);
            }
            if (object.issueTransaction != null) {
                if (typeof object.issueTransaction !== "object")
                    throw TypeError(".wavesenterprise.AtomicInnerTransaction.issueTransaction: object expected");
                message.issueTransaction = $root.wavesenterprise.IssueTransaction.fromObject(object.issueTransaction);
            }
            if (object.reissueTransaction != null) {
                if (typeof object.reissueTransaction !== "object")
                    throw TypeError(".wavesenterprise.AtomicInnerTransaction.reissueTransaction: object expected");
                message.reissueTransaction = $root.wavesenterprise.ReissueTransaction.fromObject(object.reissueTransaction);
            }
            if (object.burnTransaction != null) {
                if (typeof object.burnTransaction !== "object")
                    throw TypeError(".wavesenterprise.AtomicInnerTransaction.burnTransaction: object expected");
                message.burnTransaction = $root.wavesenterprise.BurnTransaction.fromObject(object.burnTransaction);
            }
            if (object.leaseTransaction != null) {
                if (typeof object.leaseTransaction !== "object")
                    throw TypeError(".wavesenterprise.AtomicInnerTransaction.leaseTransaction: object expected");
                message.leaseTransaction = $root.wavesenterprise.LeaseTransaction.fromObject(object.leaseTransaction);
            }
            if (object.leaseCancelTransaction != null) {
                if (typeof object.leaseCancelTransaction !== "object")
                    throw TypeError(".wavesenterprise.AtomicInnerTransaction.leaseCancelTransaction: object expected");
                message.leaseCancelTransaction = $root.wavesenterprise.LeaseCancelTransaction.fromObject(object.leaseCancelTransaction);
            }
            if (object.sponsorFeeTransaction != null) {
                if (typeof object.sponsorFeeTransaction !== "object")
                    throw TypeError(".wavesenterprise.AtomicInnerTransaction.sponsorFeeTransaction: object expected");
                message.sponsorFeeTransaction = $root.wavesenterprise.SponsorFeeTransaction.fromObject(object.sponsorFeeTransaction);
            }
            if (object.setAssetScriptTransaction != null) {
                if (typeof object.setAssetScriptTransaction !== "object")
                    throw TypeError(".wavesenterprise.AtomicInnerTransaction.setAssetScriptTransaction: object expected");
                message.setAssetScriptTransaction = $root.wavesenterprise.SetAssetScriptTransaction.fromObject(object.setAssetScriptTransaction);
            }
            if (object.dataTransaction != null) {
                if (typeof object.dataTransaction !== "object")
                    throw TypeError(".wavesenterprise.AtomicInnerTransaction.dataTransaction: object expected");
                message.dataTransaction = $root.wavesenterprise.DataTransaction.fromObject(object.dataTransaction);
            }
            if (object.transferTransaction != null) {
                if (typeof object.transferTransaction !== "object")
                    throw TypeError(".wavesenterprise.AtomicInnerTransaction.transferTransaction: object expected");
                message.transferTransaction = $root.wavesenterprise.TransferTransaction.fromObject(object.transferTransaction);
            }
            if (object.massTransferTransaction != null) {
                if (typeof object.massTransferTransaction !== "object")
                    throw TypeError(".wavesenterprise.AtomicInnerTransaction.massTransferTransaction: object expected");
                message.massTransferTransaction = $root.wavesenterprise.MassTransferTransaction.fromObject(object.massTransferTransaction);
            }
            if (object.permitTransaction != null) {
                if (typeof object.permitTransaction !== "object")
                    throw TypeError(".wavesenterprise.AtomicInnerTransaction.permitTransaction: object expected");
                message.permitTransaction = $root.wavesenterprise.PermitTransaction.fromObject(object.permitTransaction);
            }
            if (object.createPolicyTransaction != null) {
                if (typeof object.createPolicyTransaction !== "object")
                    throw TypeError(".wavesenterprise.AtomicInnerTransaction.createPolicyTransaction: object expected");
                message.createPolicyTransaction = $root.wavesenterprise.CreatePolicyTransaction.fromObject(object.createPolicyTransaction);
            }
            if (object.updatePolicyTransaction != null) {
                if (typeof object.updatePolicyTransaction !== "object")
                    throw TypeError(".wavesenterprise.AtomicInnerTransaction.updatePolicyTransaction: object expected");
                message.updatePolicyTransaction = $root.wavesenterprise.UpdatePolicyTransaction.fromObject(object.updatePolicyTransaction);
            }
            if (object.policyDataHashTransaction != null) {
                if (typeof object.policyDataHashTransaction !== "object")
                    throw TypeError(".wavesenterprise.AtomicInnerTransaction.policyDataHashTransaction: object expected");
                message.policyDataHashTransaction = $root.wavesenterprise.PolicyDataHashTransaction.fromObject(object.policyDataHashTransaction);
            }
            if (object.createContractTransaction != null) {
                if (typeof object.createContractTransaction !== "object")
                    throw TypeError(".wavesenterprise.AtomicInnerTransaction.createContractTransaction: object expected");
                message.createContractTransaction = $root.wavesenterprise.CreateContractTransaction.fromObject(object.createContractTransaction);
            }
            if (object.callContractTransaction != null) {
                if (typeof object.callContractTransaction !== "object")
                    throw TypeError(".wavesenterprise.AtomicInnerTransaction.callContractTransaction: object expected");
                message.callContractTransaction = $root.wavesenterprise.CallContractTransaction.fromObject(object.callContractTransaction);
            }
            if (object.executedContractTransaction != null) {
                if (typeof object.executedContractTransaction !== "object")
                    throw TypeError(".wavesenterprise.AtomicInnerTransaction.executedContractTransaction: object expected");
                message.executedContractTransaction = $root.wavesenterprise.ExecutedContractTransaction.fromObject(object.executedContractTransaction);
            }
            if (object.disableContractTransaction != null) {
                if (typeof object.disableContractTransaction !== "object")
                    throw TypeError(".wavesenterprise.AtomicInnerTransaction.disableContractTransaction: object expected");
                message.disableContractTransaction = $root.wavesenterprise.DisableContractTransaction.fromObject(object.disableContractTransaction);
            }
            if (object.updateContractTransaction != null) {
                if (typeof object.updateContractTransaction !== "object")
                    throw TypeError(".wavesenterprise.AtomicInnerTransaction.updateContractTransaction: object expected");
                message.updateContractTransaction = $root.wavesenterprise.UpdateContractTransaction.fromObject(object.updateContractTransaction);
            }
            if (object.setScriptTransaction != null) {
                if (typeof object.setScriptTransaction !== "object")
                    throw TypeError(".wavesenterprise.AtomicInnerTransaction.setScriptTransaction: object expected");
                message.setScriptTransaction = $root.wavesenterprise.SetScriptTransaction.fromObject(object.setScriptTransaction);
            }
            return message;
        };

        /**
         * Creates a plain object from an AtomicInnerTransaction message. Also converts values to other types if specified.
         * @function toObject
         * @memberof wavesenterprise.AtomicInnerTransaction
         * @static
         * @param {wavesenterprise.AtomicInnerTransaction} message AtomicInnerTransaction
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AtomicInnerTransaction.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.version = 0;
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            if (message.genesisTransaction != null && message.hasOwnProperty("genesisTransaction")) {
                object.genesisTransaction = $root.wavesenterprise.GenesisTransaction.toObject(message.genesisTransaction, options);
                if (options.oneofs)
                    object.transaction = "genesisTransaction";
            }
            if (message.genesisPermitTransaction != null && message.hasOwnProperty("genesisPermitTransaction")) {
                object.genesisPermitTransaction = $root.wavesenterprise.GenesisPermitTransaction.toObject(message.genesisPermitTransaction, options);
                if (options.oneofs)
                    object.transaction = "genesisPermitTransaction";
            }
            if (message.genesisRegisterNodeTransaction != null && message.hasOwnProperty("genesisRegisterNodeTransaction")) {
                object.genesisRegisterNodeTransaction = $root.wavesenterprise.GenesisRegisterNodeTransaction.toObject(message.genesisRegisterNodeTransaction, options);
                if (options.oneofs)
                    object.transaction = "genesisRegisterNodeTransaction";
            }
            if (message.registerNodeTransaction != null && message.hasOwnProperty("registerNodeTransaction")) {
                object.registerNodeTransaction = $root.wavesenterprise.RegisterNodeTransaction.toObject(message.registerNodeTransaction, options);
                if (options.oneofs)
                    object.transaction = "registerNodeTransaction";
            }
            if (message.createAliasTransaction != null && message.hasOwnProperty("createAliasTransaction")) {
                object.createAliasTransaction = $root.wavesenterprise.CreateAliasTransaction.toObject(message.createAliasTransaction, options);
                if (options.oneofs)
                    object.transaction = "createAliasTransaction";
            }
            if (message.issueTransaction != null && message.hasOwnProperty("issueTransaction")) {
                object.issueTransaction = $root.wavesenterprise.IssueTransaction.toObject(message.issueTransaction, options);
                if (options.oneofs)
                    object.transaction = "issueTransaction";
            }
            if (message.reissueTransaction != null && message.hasOwnProperty("reissueTransaction")) {
                object.reissueTransaction = $root.wavesenterprise.ReissueTransaction.toObject(message.reissueTransaction, options);
                if (options.oneofs)
                    object.transaction = "reissueTransaction";
            }
            if (message.burnTransaction != null && message.hasOwnProperty("burnTransaction")) {
                object.burnTransaction = $root.wavesenterprise.BurnTransaction.toObject(message.burnTransaction, options);
                if (options.oneofs)
                    object.transaction = "burnTransaction";
            }
            if (message.leaseTransaction != null && message.hasOwnProperty("leaseTransaction")) {
                object.leaseTransaction = $root.wavesenterprise.LeaseTransaction.toObject(message.leaseTransaction, options);
                if (options.oneofs)
                    object.transaction = "leaseTransaction";
            }
            if (message.leaseCancelTransaction != null && message.hasOwnProperty("leaseCancelTransaction")) {
                object.leaseCancelTransaction = $root.wavesenterprise.LeaseCancelTransaction.toObject(message.leaseCancelTransaction, options);
                if (options.oneofs)
                    object.transaction = "leaseCancelTransaction";
            }
            if (message.sponsorFeeTransaction != null && message.hasOwnProperty("sponsorFeeTransaction")) {
                object.sponsorFeeTransaction = $root.wavesenterprise.SponsorFeeTransaction.toObject(message.sponsorFeeTransaction, options);
                if (options.oneofs)
                    object.transaction = "sponsorFeeTransaction";
            }
            if (message.setAssetScriptTransaction != null && message.hasOwnProperty("setAssetScriptTransaction")) {
                object.setAssetScriptTransaction = $root.wavesenterprise.SetAssetScriptTransaction.toObject(message.setAssetScriptTransaction, options);
                if (options.oneofs)
                    object.transaction = "setAssetScriptTransaction";
            }
            if (message.dataTransaction != null && message.hasOwnProperty("dataTransaction")) {
                object.dataTransaction = $root.wavesenterprise.DataTransaction.toObject(message.dataTransaction, options);
                if (options.oneofs)
                    object.transaction = "dataTransaction";
            }
            if (message.transferTransaction != null && message.hasOwnProperty("transferTransaction")) {
                object.transferTransaction = $root.wavesenterprise.TransferTransaction.toObject(message.transferTransaction, options);
                if (options.oneofs)
                    object.transaction = "transferTransaction";
            }
            if (message.massTransferTransaction != null && message.hasOwnProperty("massTransferTransaction")) {
                object.massTransferTransaction = $root.wavesenterprise.MassTransferTransaction.toObject(message.massTransferTransaction, options);
                if (options.oneofs)
                    object.transaction = "massTransferTransaction";
            }
            if (message.permitTransaction != null && message.hasOwnProperty("permitTransaction")) {
                object.permitTransaction = $root.wavesenterprise.PermitTransaction.toObject(message.permitTransaction, options);
                if (options.oneofs)
                    object.transaction = "permitTransaction";
            }
            if (message.createPolicyTransaction != null && message.hasOwnProperty("createPolicyTransaction")) {
                object.createPolicyTransaction = $root.wavesenterprise.CreatePolicyTransaction.toObject(message.createPolicyTransaction, options);
                if (options.oneofs)
                    object.transaction = "createPolicyTransaction";
            }
            if (message.updatePolicyTransaction != null && message.hasOwnProperty("updatePolicyTransaction")) {
                object.updatePolicyTransaction = $root.wavesenterprise.UpdatePolicyTransaction.toObject(message.updatePolicyTransaction, options);
                if (options.oneofs)
                    object.transaction = "updatePolicyTransaction";
            }
            if (message.policyDataHashTransaction != null && message.hasOwnProperty("policyDataHashTransaction")) {
                object.policyDataHashTransaction = $root.wavesenterprise.PolicyDataHashTransaction.toObject(message.policyDataHashTransaction, options);
                if (options.oneofs)
                    object.transaction = "policyDataHashTransaction";
            }
            if (message.createContractTransaction != null && message.hasOwnProperty("createContractTransaction")) {
                object.createContractTransaction = $root.wavesenterprise.CreateContractTransaction.toObject(message.createContractTransaction, options);
                if (options.oneofs)
                    object.transaction = "createContractTransaction";
            }
            if (message.callContractTransaction != null && message.hasOwnProperty("callContractTransaction")) {
                object.callContractTransaction = $root.wavesenterprise.CallContractTransaction.toObject(message.callContractTransaction, options);
                if (options.oneofs)
                    object.transaction = "callContractTransaction";
            }
            if (message.executedContractTransaction != null && message.hasOwnProperty("executedContractTransaction")) {
                object.executedContractTransaction = $root.wavesenterprise.ExecutedContractTransaction.toObject(message.executedContractTransaction, options);
                if (options.oneofs)
                    object.transaction = "executedContractTransaction";
            }
            if (message.disableContractTransaction != null && message.hasOwnProperty("disableContractTransaction")) {
                object.disableContractTransaction = $root.wavesenterprise.DisableContractTransaction.toObject(message.disableContractTransaction, options);
                if (options.oneofs)
                    object.transaction = "disableContractTransaction";
            }
            if (message.updateContractTransaction != null && message.hasOwnProperty("updateContractTransaction")) {
                object.updateContractTransaction = $root.wavesenterprise.UpdateContractTransaction.toObject(message.updateContractTransaction, options);
                if (options.oneofs)
                    object.transaction = "updateContractTransaction";
            }
            if (message.setScriptTransaction != null && message.hasOwnProperty("setScriptTransaction")) {
                object.setScriptTransaction = $root.wavesenterprise.SetScriptTransaction.toObject(message.setScriptTransaction, options);
                if (options.oneofs)
                    object.transaction = "setScriptTransaction";
            }
            return object;
        };

        /**
         * Converts this AtomicInnerTransaction to JSON.
         * @function toJSON
         * @memberof wavesenterprise.AtomicInnerTransaction
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AtomicInnerTransaction.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AtomicInnerTransaction;
    })();

    wavesenterprise.SubscribeOnRequest = (function() {

        /**
         * Properties of a SubscribeOnRequest.
         * @memberof wavesenterprise
         * @interface ISubscribeOnRequest
         * @property {wavesenterprise.IGenesisBlock|null} [genesisBlock] SubscribeOnRequest genesisBlock
         * @property {wavesenterprise.IBlockSignature|null} [blockSignature] SubscribeOnRequest blockSignature
         * @property {wavesenterprise.ICurrentEvent|null} [currentEvent] SubscribeOnRequest currentEvent
         * @property {Array.<wavesenterprise.IEventsFilter>|null} [eventsFilters] SubscribeOnRequest eventsFilters
         */

        /**
         * Constructs a new SubscribeOnRequest.
         * @memberof wavesenterprise
         * @classdesc Represents a SubscribeOnRequest.
         * @implements ISubscribeOnRequest
         * @constructor
         * @param {wavesenterprise.ISubscribeOnRequest=} [properties] Properties to set
         */
        function SubscribeOnRequest(properties) {
            this.eventsFilters = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SubscribeOnRequest genesisBlock.
         * @member {wavesenterprise.IGenesisBlock|null|undefined} genesisBlock
         * @memberof wavesenterprise.SubscribeOnRequest
         * @instance
         */
        SubscribeOnRequest.prototype.genesisBlock = null;

        /**
         * SubscribeOnRequest blockSignature.
         * @member {wavesenterprise.IBlockSignature|null|undefined} blockSignature
         * @memberof wavesenterprise.SubscribeOnRequest
         * @instance
         */
        SubscribeOnRequest.prototype.blockSignature = null;

        /**
         * SubscribeOnRequest currentEvent.
         * @member {wavesenterprise.ICurrentEvent|null|undefined} currentEvent
         * @memberof wavesenterprise.SubscribeOnRequest
         * @instance
         */
        SubscribeOnRequest.prototype.currentEvent = null;

        /**
         * SubscribeOnRequest eventsFilters.
         * @member {Array.<wavesenterprise.IEventsFilter>} eventsFilters
         * @memberof wavesenterprise.SubscribeOnRequest
         * @instance
         */
        SubscribeOnRequest.prototype.eventsFilters = $util.emptyArray;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * SubscribeOnRequest startFrom.
         * @member {"genesisBlock"|"blockSignature"|"currentEvent"|undefined} startFrom
         * @memberof wavesenterprise.SubscribeOnRequest
         * @instance
         */
        Object.defineProperty(SubscribeOnRequest.prototype, "startFrom", {
            get: $util.oneOfGetter($oneOfFields = ["genesisBlock", "blockSignature", "currentEvent"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new SubscribeOnRequest instance using the specified properties.
         * @function create
         * @memberof wavesenterprise.SubscribeOnRequest
         * @static
         * @param {wavesenterprise.ISubscribeOnRequest=} [properties] Properties to set
         * @returns {wavesenterprise.SubscribeOnRequest} SubscribeOnRequest instance
         */
        SubscribeOnRequest.create = function create(properties) {
            return new SubscribeOnRequest(properties);
        };

        /**
         * Encodes the specified SubscribeOnRequest message. Does not implicitly {@link wavesenterprise.SubscribeOnRequest.verify|verify} messages.
         * @function encode
         * @memberof wavesenterprise.SubscribeOnRequest
         * @static
         * @param {wavesenterprise.ISubscribeOnRequest} message SubscribeOnRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubscribeOnRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.eventsFilters != null && message.eventsFilters.length)
                for (var i = 0; i < message.eventsFilters.length; ++i)
                    $root.wavesenterprise.EventsFilter.encode(message.eventsFilters[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.genesisBlock != null && Object.hasOwnProperty.call(message, "genesisBlock"))
                $root.wavesenterprise.GenesisBlock.encode(message.genesisBlock, writer.uint32(/* id 101, wireType 2 =*/810).fork()).ldelim();
            if (message.blockSignature != null && Object.hasOwnProperty.call(message, "blockSignature"))
                $root.wavesenterprise.BlockSignature.encode(message.blockSignature, writer.uint32(/* id 102, wireType 2 =*/818).fork()).ldelim();
            if (message.currentEvent != null && Object.hasOwnProperty.call(message, "currentEvent"))
                $root.wavesenterprise.CurrentEvent.encode(message.currentEvent, writer.uint32(/* id 103, wireType 2 =*/826).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SubscribeOnRequest message, length delimited. Does not implicitly {@link wavesenterprise.SubscribeOnRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof wavesenterprise.SubscribeOnRequest
         * @static
         * @param {wavesenterprise.ISubscribeOnRequest} message SubscribeOnRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubscribeOnRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SubscribeOnRequest message from the specified reader or buffer.
         * @function decode
         * @memberof wavesenterprise.SubscribeOnRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {wavesenterprise.SubscribeOnRequest} SubscribeOnRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubscribeOnRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.wavesenterprise.SubscribeOnRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 101:
                    message.genesisBlock = $root.wavesenterprise.GenesisBlock.decode(reader, reader.uint32());
                    break;
                case 102:
                    message.blockSignature = $root.wavesenterprise.BlockSignature.decode(reader, reader.uint32());
                    break;
                case 103:
                    message.currentEvent = $root.wavesenterprise.CurrentEvent.decode(reader, reader.uint32());
                    break;
                case 1:
                    if (!(message.eventsFilters && message.eventsFilters.length))
                        message.eventsFilters = [];
                    message.eventsFilters.push($root.wavesenterprise.EventsFilter.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SubscribeOnRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof wavesenterprise.SubscribeOnRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {wavesenterprise.SubscribeOnRequest} SubscribeOnRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubscribeOnRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SubscribeOnRequest message.
         * @function verify
         * @memberof wavesenterprise.SubscribeOnRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SubscribeOnRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.genesisBlock != null && message.hasOwnProperty("genesisBlock")) {
                properties.startFrom = 1;
                {
                    var error = $root.wavesenterprise.GenesisBlock.verify(message.genesisBlock);
                    if (error)
                        return "genesisBlock." + error;
                }
            }
            if (message.blockSignature != null && message.hasOwnProperty("blockSignature")) {
                if (properties.startFrom === 1)
                    return "startFrom: multiple values";
                properties.startFrom = 1;
                {
                    var error = $root.wavesenterprise.BlockSignature.verify(message.blockSignature);
                    if (error)
                        return "blockSignature." + error;
                }
            }
            if (message.currentEvent != null && message.hasOwnProperty("currentEvent")) {
                if (properties.startFrom === 1)
                    return "startFrom: multiple values";
                properties.startFrom = 1;
                {
                    var error = $root.wavesenterprise.CurrentEvent.verify(message.currentEvent);
                    if (error)
                        return "currentEvent." + error;
                }
            }
            if (message.eventsFilters != null && message.hasOwnProperty("eventsFilters")) {
                if (!Array.isArray(message.eventsFilters))
                    return "eventsFilters: array expected";
                for (var i = 0; i < message.eventsFilters.length; ++i) {
                    var error = $root.wavesenterprise.EventsFilter.verify(message.eventsFilters[i]);
                    if (error)
                        return "eventsFilters." + error;
                }
            }
            return null;
        };

        /**
         * Creates a SubscribeOnRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof wavesenterprise.SubscribeOnRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {wavesenterprise.SubscribeOnRequest} SubscribeOnRequest
         */
        SubscribeOnRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.wavesenterprise.SubscribeOnRequest)
                return object;
            var message = new $root.wavesenterprise.SubscribeOnRequest();
            if (object.genesisBlock != null) {
                if (typeof object.genesisBlock !== "object")
                    throw TypeError(".wavesenterprise.SubscribeOnRequest.genesisBlock: object expected");
                message.genesisBlock = $root.wavesenterprise.GenesisBlock.fromObject(object.genesisBlock);
            }
            if (object.blockSignature != null) {
                if (typeof object.blockSignature !== "object")
                    throw TypeError(".wavesenterprise.SubscribeOnRequest.blockSignature: object expected");
                message.blockSignature = $root.wavesenterprise.BlockSignature.fromObject(object.blockSignature);
            }
            if (object.currentEvent != null) {
                if (typeof object.currentEvent !== "object")
                    throw TypeError(".wavesenterprise.SubscribeOnRequest.currentEvent: object expected");
                message.currentEvent = $root.wavesenterprise.CurrentEvent.fromObject(object.currentEvent);
            }
            if (object.eventsFilters) {
                if (!Array.isArray(object.eventsFilters))
                    throw TypeError(".wavesenterprise.SubscribeOnRequest.eventsFilters: array expected");
                message.eventsFilters = [];
                for (var i = 0; i < object.eventsFilters.length; ++i) {
                    if (typeof object.eventsFilters[i] !== "object")
                        throw TypeError(".wavesenterprise.SubscribeOnRequest.eventsFilters: object expected");
                    message.eventsFilters[i] = $root.wavesenterprise.EventsFilter.fromObject(object.eventsFilters[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a SubscribeOnRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof wavesenterprise.SubscribeOnRequest
         * @static
         * @param {wavesenterprise.SubscribeOnRequest} message SubscribeOnRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SubscribeOnRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.eventsFilters = [];
            if (message.eventsFilters && message.eventsFilters.length) {
                object.eventsFilters = [];
                for (var j = 0; j < message.eventsFilters.length; ++j)
                    object.eventsFilters[j] = $root.wavesenterprise.EventsFilter.toObject(message.eventsFilters[j], options);
            }
            if (message.genesisBlock != null && message.hasOwnProperty("genesisBlock")) {
                object.genesisBlock = $root.wavesenterprise.GenesisBlock.toObject(message.genesisBlock, options);
                if (options.oneofs)
                    object.startFrom = "genesisBlock";
            }
            if (message.blockSignature != null && message.hasOwnProperty("blockSignature")) {
                object.blockSignature = $root.wavesenterprise.BlockSignature.toObject(message.blockSignature, options);
                if (options.oneofs)
                    object.startFrom = "blockSignature";
            }
            if (message.currentEvent != null && message.hasOwnProperty("currentEvent")) {
                object.currentEvent = $root.wavesenterprise.CurrentEvent.toObject(message.currentEvent, options);
                if (options.oneofs)
                    object.startFrom = "currentEvent";
            }
            return object;
        };

        /**
         * Converts this SubscribeOnRequest to JSON.
         * @function toJSON
         * @memberof wavesenterprise.SubscribeOnRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SubscribeOnRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SubscribeOnRequest;
    })();

    wavesenterprise.GenesisBlock = (function() {

        /**
         * Properties of a GenesisBlock.
         * @memberof wavesenterprise
         * @interface IGenesisBlock
         */

        /**
         * Constructs a new GenesisBlock.
         * @memberof wavesenterprise
         * @classdesc Represents a GenesisBlock.
         * @implements IGenesisBlock
         * @constructor
         * @param {wavesenterprise.IGenesisBlock=} [properties] Properties to set
         */
        function GenesisBlock(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new GenesisBlock instance using the specified properties.
         * @function create
         * @memberof wavesenterprise.GenesisBlock
         * @static
         * @param {wavesenterprise.IGenesisBlock=} [properties] Properties to set
         * @returns {wavesenterprise.GenesisBlock} GenesisBlock instance
         */
        GenesisBlock.create = function create(properties) {
            return new GenesisBlock(properties);
        };

        /**
         * Encodes the specified GenesisBlock message. Does not implicitly {@link wavesenterprise.GenesisBlock.verify|verify} messages.
         * @function encode
         * @memberof wavesenterprise.GenesisBlock
         * @static
         * @param {wavesenterprise.IGenesisBlock} message GenesisBlock message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GenesisBlock.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified GenesisBlock message, length delimited. Does not implicitly {@link wavesenterprise.GenesisBlock.verify|verify} messages.
         * @function encodeDelimited
         * @memberof wavesenterprise.GenesisBlock
         * @static
         * @param {wavesenterprise.IGenesisBlock} message GenesisBlock message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GenesisBlock.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GenesisBlock message from the specified reader or buffer.
         * @function decode
         * @memberof wavesenterprise.GenesisBlock
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {wavesenterprise.GenesisBlock} GenesisBlock
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GenesisBlock.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.wavesenterprise.GenesisBlock();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GenesisBlock message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof wavesenterprise.GenesisBlock
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {wavesenterprise.GenesisBlock} GenesisBlock
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GenesisBlock.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GenesisBlock message.
         * @function verify
         * @memberof wavesenterprise.GenesisBlock
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GenesisBlock.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a GenesisBlock message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof wavesenterprise.GenesisBlock
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {wavesenterprise.GenesisBlock} GenesisBlock
         */
        GenesisBlock.fromObject = function fromObject(object) {
            if (object instanceof $root.wavesenterprise.GenesisBlock)
                return object;
            return new $root.wavesenterprise.GenesisBlock();
        };

        /**
         * Creates a plain object from a GenesisBlock message. Also converts values to other types if specified.
         * @function toObject
         * @memberof wavesenterprise.GenesisBlock
         * @static
         * @param {wavesenterprise.GenesisBlock} message GenesisBlock
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GenesisBlock.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this GenesisBlock to JSON.
         * @function toJSON
         * @memberof wavesenterprise.GenesisBlock
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GenesisBlock.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GenesisBlock;
    })();

    wavesenterprise.BlockSignature = (function() {

        /**
         * Properties of a BlockSignature.
         * @memberof wavesenterprise
         * @interface IBlockSignature
         * @property {google.protobuf.IBytesValue|null} [lastBlockSignature] BlockSignature lastBlockSignature
         */

        /**
         * Constructs a new BlockSignature.
         * @memberof wavesenterprise
         * @classdesc Represents a BlockSignature.
         * @implements IBlockSignature
         * @constructor
         * @param {wavesenterprise.IBlockSignature=} [properties] Properties to set
         */
        function BlockSignature(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BlockSignature lastBlockSignature.
         * @member {google.protobuf.IBytesValue|null|undefined} lastBlockSignature
         * @memberof wavesenterprise.BlockSignature
         * @instance
         */
        BlockSignature.prototype.lastBlockSignature = null;

        /**
         * Creates a new BlockSignature instance using the specified properties.
         * @function create
         * @memberof wavesenterprise.BlockSignature
         * @static
         * @param {wavesenterprise.IBlockSignature=} [properties] Properties to set
         * @returns {wavesenterprise.BlockSignature} BlockSignature instance
         */
        BlockSignature.create = function create(properties) {
            return new BlockSignature(properties);
        };

        /**
         * Encodes the specified BlockSignature message. Does not implicitly {@link wavesenterprise.BlockSignature.verify|verify} messages.
         * @function encode
         * @memberof wavesenterprise.BlockSignature
         * @static
         * @param {wavesenterprise.IBlockSignature} message BlockSignature message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BlockSignature.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.lastBlockSignature != null && Object.hasOwnProperty.call(message, "lastBlockSignature"))
                $root.google.protobuf.BytesValue.encode(message.lastBlockSignature, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified BlockSignature message, length delimited. Does not implicitly {@link wavesenterprise.BlockSignature.verify|verify} messages.
         * @function encodeDelimited
         * @memberof wavesenterprise.BlockSignature
         * @static
         * @param {wavesenterprise.IBlockSignature} message BlockSignature message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BlockSignature.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BlockSignature message from the specified reader or buffer.
         * @function decode
         * @memberof wavesenterprise.BlockSignature
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {wavesenterprise.BlockSignature} BlockSignature
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BlockSignature.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.wavesenterprise.BlockSignature();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.lastBlockSignature = $root.google.protobuf.BytesValue.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BlockSignature message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof wavesenterprise.BlockSignature
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {wavesenterprise.BlockSignature} BlockSignature
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BlockSignature.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BlockSignature message.
         * @function verify
         * @memberof wavesenterprise.BlockSignature
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BlockSignature.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.lastBlockSignature != null && message.hasOwnProperty("lastBlockSignature")) {
                var error = $root.google.protobuf.BytesValue.verify(message.lastBlockSignature);
                if (error)
                    return "lastBlockSignature." + error;
            }
            return null;
        };

        /**
         * Creates a BlockSignature message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof wavesenterprise.BlockSignature
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {wavesenterprise.BlockSignature} BlockSignature
         */
        BlockSignature.fromObject = function fromObject(object) {
            if (object instanceof $root.wavesenterprise.BlockSignature)
                return object;
            var message = new $root.wavesenterprise.BlockSignature();
            if (object.lastBlockSignature != null) {
                if (typeof object.lastBlockSignature !== "object")
                    throw TypeError(".wavesenterprise.BlockSignature.lastBlockSignature: object expected");
                message.lastBlockSignature = $root.google.protobuf.BytesValue.fromObject(object.lastBlockSignature);
            }
            return message;
        };

        /**
         * Creates a plain object from a BlockSignature message. Also converts values to other types if specified.
         * @function toObject
         * @memberof wavesenterprise.BlockSignature
         * @static
         * @param {wavesenterprise.BlockSignature} message BlockSignature
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BlockSignature.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.lastBlockSignature = null;
            if (message.lastBlockSignature != null && message.hasOwnProperty("lastBlockSignature"))
                object.lastBlockSignature = $root.google.protobuf.BytesValue.toObject(message.lastBlockSignature, options);
            return object;
        };

        /**
         * Converts this BlockSignature to JSON.
         * @function toJSON
         * @memberof wavesenterprise.BlockSignature
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BlockSignature.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BlockSignature;
    })();

    wavesenterprise.CurrentEvent = (function() {

        /**
         * Properties of a CurrentEvent.
         * @memberof wavesenterprise
         * @interface ICurrentEvent
         */

        /**
         * Constructs a new CurrentEvent.
         * @memberof wavesenterprise
         * @classdesc Represents a CurrentEvent.
         * @implements ICurrentEvent
         * @constructor
         * @param {wavesenterprise.ICurrentEvent=} [properties] Properties to set
         */
        function CurrentEvent(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new CurrentEvent instance using the specified properties.
         * @function create
         * @memberof wavesenterprise.CurrentEvent
         * @static
         * @param {wavesenterprise.ICurrentEvent=} [properties] Properties to set
         * @returns {wavesenterprise.CurrentEvent} CurrentEvent instance
         */
        CurrentEvent.create = function create(properties) {
            return new CurrentEvent(properties);
        };

        /**
         * Encodes the specified CurrentEvent message. Does not implicitly {@link wavesenterprise.CurrentEvent.verify|verify} messages.
         * @function encode
         * @memberof wavesenterprise.CurrentEvent
         * @static
         * @param {wavesenterprise.ICurrentEvent} message CurrentEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CurrentEvent.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified CurrentEvent message, length delimited. Does not implicitly {@link wavesenterprise.CurrentEvent.verify|verify} messages.
         * @function encodeDelimited
         * @memberof wavesenterprise.CurrentEvent
         * @static
         * @param {wavesenterprise.ICurrentEvent} message CurrentEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CurrentEvent.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CurrentEvent message from the specified reader or buffer.
         * @function decode
         * @memberof wavesenterprise.CurrentEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {wavesenterprise.CurrentEvent} CurrentEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CurrentEvent.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.wavesenterprise.CurrentEvent();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CurrentEvent message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof wavesenterprise.CurrentEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {wavesenterprise.CurrentEvent} CurrentEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CurrentEvent.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CurrentEvent message.
         * @function verify
         * @memberof wavesenterprise.CurrentEvent
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CurrentEvent.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a CurrentEvent message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof wavesenterprise.CurrentEvent
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {wavesenterprise.CurrentEvent} CurrentEvent
         */
        CurrentEvent.fromObject = function fromObject(object) {
            if (object instanceof $root.wavesenterprise.CurrentEvent)
                return object;
            return new $root.wavesenterprise.CurrentEvent();
        };

        /**
         * Creates a plain object from a CurrentEvent message. Also converts values to other types if specified.
         * @function toObject
         * @memberof wavesenterprise.CurrentEvent
         * @static
         * @param {wavesenterprise.CurrentEvent} message CurrentEvent
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CurrentEvent.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this CurrentEvent to JSON.
         * @function toJSON
         * @memberof wavesenterprise.CurrentEvent
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CurrentEvent.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CurrentEvent;
    })();

    wavesenterprise.EventsFilter = (function() {

        /**
         * Properties of an EventsFilter.
         * @memberof wavesenterprise
         * @interface IEventsFilter
         * @property {wavesenterprise.EventsFilter.IFilterIn|null} [filterIn] EventsFilter filterIn
         * @property {wavesenterprise.EventsFilter.IFilterOut|null} [filterOut] EventsFilter filterOut
         * @property {wavesenterprise.ITxTypeFilter|null} [txTypeFilter] EventsFilter txTypeFilter
         * @property {wavesenterprise.IContractIdFilter|null} [contractIdFilter] EventsFilter contractIdFilter
         */

        /**
         * Constructs a new EventsFilter.
         * @memberof wavesenterprise
         * @classdesc Represents an EventsFilter.
         * @implements IEventsFilter
         * @constructor
         * @param {wavesenterprise.IEventsFilter=} [properties] Properties to set
         */
        function EventsFilter(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EventsFilter filterIn.
         * @member {wavesenterprise.EventsFilter.IFilterIn|null|undefined} filterIn
         * @memberof wavesenterprise.EventsFilter
         * @instance
         */
        EventsFilter.prototype.filterIn = null;

        /**
         * EventsFilter filterOut.
         * @member {wavesenterprise.EventsFilter.IFilterOut|null|undefined} filterOut
         * @memberof wavesenterprise.EventsFilter
         * @instance
         */
        EventsFilter.prototype.filterOut = null;

        /**
         * EventsFilter txTypeFilter.
         * @member {wavesenterprise.ITxTypeFilter|null|undefined} txTypeFilter
         * @memberof wavesenterprise.EventsFilter
         * @instance
         */
        EventsFilter.prototype.txTypeFilter = null;

        /**
         * EventsFilter contractIdFilter.
         * @member {wavesenterprise.IContractIdFilter|null|undefined} contractIdFilter
         * @memberof wavesenterprise.EventsFilter
         * @instance
         */
        EventsFilter.prototype.contractIdFilter = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * EventsFilter filterType.
         * @member {"filterIn"|"filterOut"|undefined} filterType
         * @memberof wavesenterprise.EventsFilter
         * @instance
         */
        Object.defineProperty(EventsFilter.prototype, "filterType", {
            get: $util.oneOfGetter($oneOfFields = ["filterIn", "filterOut"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * EventsFilter eventsFilter.
         * @member {"txTypeFilter"|"contractIdFilter"|undefined} eventsFilter
         * @memberof wavesenterprise.EventsFilter
         * @instance
         */
        Object.defineProperty(EventsFilter.prototype, "eventsFilter", {
            get: $util.oneOfGetter($oneOfFields = ["txTypeFilter", "contractIdFilter"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new EventsFilter instance using the specified properties.
         * @function create
         * @memberof wavesenterprise.EventsFilter
         * @static
         * @param {wavesenterprise.IEventsFilter=} [properties] Properties to set
         * @returns {wavesenterprise.EventsFilter} EventsFilter instance
         */
        EventsFilter.create = function create(properties) {
            return new EventsFilter(properties);
        };

        /**
         * Encodes the specified EventsFilter message. Does not implicitly {@link wavesenterprise.EventsFilter.verify|verify} messages.
         * @function encode
         * @memberof wavesenterprise.EventsFilter
         * @static
         * @param {wavesenterprise.IEventsFilter} message EventsFilter message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EventsFilter.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.filterIn != null && Object.hasOwnProperty.call(message, "filterIn"))
                $root.wavesenterprise.EventsFilter.FilterIn.encode(message.filterIn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.filterOut != null && Object.hasOwnProperty.call(message, "filterOut"))
                $root.wavesenterprise.EventsFilter.FilterOut.encode(message.filterOut, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.txTypeFilter != null && Object.hasOwnProperty.call(message, "txTypeFilter"))
                $root.wavesenterprise.TxTypeFilter.encode(message.txTypeFilter, writer.uint32(/* id 101, wireType 2 =*/810).fork()).ldelim();
            if (message.contractIdFilter != null && Object.hasOwnProperty.call(message, "contractIdFilter"))
                $root.wavesenterprise.ContractIdFilter.encode(message.contractIdFilter, writer.uint32(/* id 102, wireType 2 =*/818).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified EventsFilter message, length delimited. Does not implicitly {@link wavesenterprise.EventsFilter.verify|verify} messages.
         * @function encodeDelimited
         * @memberof wavesenterprise.EventsFilter
         * @static
         * @param {wavesenterprise.IEventsFilter} message EventsFilter message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EventsFilter.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EventsFilter message from the specified reader or buffer.
         * @function decode
         * @memberof wavesenterprise.EventsFilter
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {wavesenterprise.EventsFilter} EventsFilter
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EventsFilter.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.wavesenterprise.EventsFilter();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.filterIn = $root.wavesenterprise.EventsFilter.FilterIn.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.filterOut = $root.wavesenterprise.EventsFilter.FilterOut.decode(reader, reader.uint32());
                    break;
                case 101:
                    message.txTypeFilter = $root.wavesenterprise.TxTypeFilter.decode(reader, reader.uint32());
                    break;
                case 102:
                    message.contractIdFilter = $root.wavesenterprise.ContractIdFilter.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an EventsFilter message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof wavesenterprise.EventsFilter
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {wavesenterprise.EventsFilter} EventsFilter
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EventsFilter.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EventsFilter message.
         * @function verify
         * @memberof wavesenterprise.EventsFilter
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EventsFilter.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.filterIn != null && message.hasOwnProperty("filterIn")) {
                properties.filterType = 1;
                {
                    var error = $root.wavesenterprise.EventsFilter.FilterIn.verify(message.filterIn);
                    if (error)
                        return "filterIn." + error;
                }
            }
            if (message.filterOut != null && message.hasOwnProperty("filterOut")) {
                if (properties.filterType === 1)
                    return "filterType: multiple values";
                properties.filterType = 1;
                {
                    var error = $root.wavesenterprise.EventsFilter.FilterOut.verify(message.filterOut);
                    if (error)
                        return "filterOut." + error;
                }
            }
            if (message.txTypeFilter != null && message.hasOwnProperty("txTypeFilter")) {
                properties.eventsFilter = 1;
                {
                    var error = $root.wavesenterprise.TxTypeFilter.verify(message.txTypeFilter);
                    if (error)
                        return "txTypeFilter." + error;
                }
            }
            if (message.contractIdFilter != null && message.hasOwnProperty("contractIdFilter")) {
                if (properties.eventsFilter === 1)
                    return "eventsFilter: multiple values";
                properties.eventsFilter = 1;
                {
                    var error = $root.wavesenterprise.ContractIdFilter.verify(message.contractIdFilter);
                    if (error)
                        return "contractIdFilter." + error;
                }
            }
            return null;
        };

        /**
         * Creates an EventsFilter message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof wavesenterprise.EventsFilter
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {wavesenterprise.EventsFilter} EventsFilter
         */
        EventsFilter.fromObject = function fromObject(object) {
            if (object instanceof $root.wavesenterprise.EventsFilter)
                return object;
            var message = new $root.wavesenterprise.EventsFilter();
            if (object.filterIn != null) {
                if (typeof object.filterIn !== "object")
                    throw TypeError(".wavesenterprise.EventsFilter.filterIn: object expected");
                message.filterIn = $root.wavesenterprise.EventsFilter.FilterIn.fromObject(object.filterIn);
            }
            if (object.filterOut != null) {
                if (typeof object.filterOut !== "object")
                    throw TypeError(".wavesenterprise.EventsFilter.filterOut: object expected");
                message.filterOut = $root.wavesenterprise.EventsFilter.FilterOut.fromObject(object.filterOut);
            }
            if (object.txTypeFilter != null) {
                if (typeof object.txTypeFilter !== "object")
                    throw TypeError(".wavesenterprise.EventsFilter.txTypeFilter: object expected");
                message.txTypeFilter = $root.wavesenterprise.TxTypeFilter.fromObject(object.txTypeFilter);
            }
            if (object.contractIdFilter != null) {
                if (typeof object.contractIdFilter !== "object")
                    throw TypeError(".wavesenterprise.EventsFilter.contractIdFilter: object expected");
                message.contractIdFilter = $root.wavesenterprise.ContractIdFilter.fromObject(object.contractIdFilter);
            }
            return message;
        };

        /**
         * Creates a plain object from an EventsFilter message. Also converts values to other types if specified.
         * @function toObject
         * @memberof wavesenterprise.EventsFilter
         * @static
         * @param {wavesenterprise.EventsFilter} message EventsFilter
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EventsFilter.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (message.filterIn != null && message.hasOwnProperty("filterIn")) {
                object.filterIn = $root.wavesenterprise.EventsFilter.FilterIn.toObject(message.filterIn, options);
                if (options.oneofs)
                    object.filterType = "filterIn";
            }
            if (message.filterOut != null && message.hasOwnProperty("filterOut")) {
                object.filterOut = $root.wavesenterprise.EventsFilter.FilterOut.toObject(message.filterOut, options);
                if (options.oneofs)
                    object.filterType = "filterOut";
            }
            if (message.txTypeFilter != null && message.hasOwnProperty("txTypeFilter")) {
                object.txTypeFilter = $root.wavesenterprise.TxTypeFilter.toObject(message.txTypeFilter, options);
                if (options.oneofs)
                    object.eventsFilter = "txTypeFilter";
            }
            if (message.contractIdFilter != null && message.hasOwnProperty("contractIdFilter")) {
                object.contractIdFilter = $root.wavesenterprise.ContractIdFilter.toObject(message.contractIdFilter, options);
                if (options.oneofs)
                    object.eventsFilter = "contractIdFilter";
            }
            return object;
        };

        /**
         * Converts this EventsFilter to JSON.
         * @function toJSON
         * @memberof wavesenterprise.EventsFilter
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EventsFilter.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        EventsFilter.FilterIn = (function() {

            /**
             * Properties of a FilterIn.
             * @memberof wavesenterprise.EventsFilter
             * @interface IFilterIn
             */

            /**
             * Constructs a new FilterIn.
             * @memberof wavesenterprise.EventsFilter
             * @classdesc Represents a FilterIn.
             * @implements IFilterIn
             * @constructor
             * @param {wavesenterprise.EventsFilter.IFilterIn=} [properties] Properties to set
             */
            function FilterIn(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new FilterIn instance using the specified properties.
             * @function create
             * @memberof wavesenterprise.EventsFilter.FilterIn
             * @static
             * @param {wavesenterprise.EventsFilter.IFilterIn=} [properties] Properties to set
             * @returns {wavesenterprise.EventsFilter.FilterIn} FilterIn instance
             */
            FilterIn.create = function create(properties) {
                return new FilterIn(properties);
            };

            /**
             * Encodes the specified FilterIn message. Does not implicitly {@link wavesenterprise.EventsFilter.FilterIn.verify|verify} messages.
             * @function encode
             * @memberof wavesenterprise.EventsFilter.FilterIn
             * @static
             * @param {wavesenterprise.EventsFilter.IFilterIn} message FilterIn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FilterIn.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified FilterIn message, length delimited. Does not implicitly {@link wavesenterprise.EventsFilter.FilterIn.verify|verify} messages.
             * @function encodeDelimited
             * @memberof wavesenterprise.EventsFilter.FilterIn
             * @static
             * @param {wavesenterprise.EventsFilter.IFilterIn} message FilterIn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FilterIn.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FilterIn message from the specified reader or buffer.
             * @function decode
             * @memberof wavesenterprise.EventsFilter.FilterIn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {wavesenterprise.EventsFilter.FilterIn} FilterIn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FilterIn.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.wavesenterprise.EventsFilter.FilterIn();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FilterIn message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof wavesenterprise.EventsFilter.FilterIn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {wavesenterprise.EventsFilter.FilterIn} FilterIn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FilterIn.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FilterIn message.
             * @function verify
             * @memberof wavesenterprise.EventsFilter.FilterIn
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FilterIn.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a FilterIn message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof wavesenterprise.EventsFilter.FilterIn
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {wavesenterprise.EventsFilter.FilterIn} FilterIn
             */
            FilterIn.fromObject = function fromObject(object) {
                if (object instanceof $root.wavesenterprise.EventsFilter.FilterIn)
                    return object;
                return new $root.wavesenterprise.EventsFilter.FilterIn();
            };

            /**
             * Creates a plain object from a FilterIn message. Also converts values to other types if specified.
             * @function toObject
             * @memberof wavesenterprise.EventsFilter.FilterIn
             * @static
             * @param {wavesenterprise.EventsFilter.FilterIn} message FilterIn
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FilterIn.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this FilterIn to JSON.
             * @function toJSON
             * @memberof wavesenterprise.EventsFilter.FilterIn
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FilterIn.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return FilterIn;
        })();

        EventsFilter.FilterOut = (function() {

            /**
             * Properties of a FilterOut.
             * @memberof wavesenterprise.EventsFilter
             * @interface IFilterOut
             */

            /**
             * Constructs a new FilterOut.
             * @memberof wavesenterprise.EventsFilter
             * @classdesc Represents a FilterOut.
             * @implements IFilterOut
             * @constructor
             * @param {wavesenterprise.EventsFilter.IFilterOut=} [properties] Properties to set
             */
            function FilterOut(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new FilterOut instance using the specified properties.
             * @function create
             * @memberof wavesenterprise.EventsFilter.FilterOut
             * @static
             * @param {wavesenterprise.EventsFilter.IFilterOut=} [properties] Properties to set
             * @returns {wavesenterprise.EventsFilter.FilterOut} FilterOut instance
             */
            FilterOut.create = function create(properties) {
                return new FilterOut(properties);
            };

            /**
             * Encodes the specified FilterOut message. Does not implicitly {@link wavesenterprise.EventsFilter.FilterOut.verify|verify} messages.
             * @function encode
             * @memberof wavesenterprise.EventsFilter.FilterOut
             * @static
             * @param {wavesenterprise.EventsFilter.IFilterOut} message FilterOut message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FilterOut.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified FilterOut message, length delimited. Does not implicitly {@link wavesenterprise.EventsFilter.FilterOut.verify|verify} messages.
             * @function encodeDelimited
             * @memberof wavesenterprise.EventsFilter.FilterOut
             * @static
             * @param {wavesenterprise.EventsFilter.IFilterOut} message FilterOut message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FilterOut.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FilterOut message from the specified reader or buffer.
             * @function decode
             * @memberof wavesenterprise.EventsFilter.FilterOut
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {wavesenterprise.EventsFilter.FilterOut} FilterOut
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FilterOut.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.wavesenterprise.EventsFilter.FilterOut();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FilterOut message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof wavesenterprise.EventsFilter.FilterOut
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {wavesenterprise.EventsFilter.FilterOut} FilterOut
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FilterOut.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FilterOut message.
             * @function verify
             * @memberof wavesenterprise.EventsFilter.FilterOut
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FilterOut.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a FilterOut message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof wavesenterprise.EventsFilter.FilterOut
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {wavesenterprise.EventsFilter.FilterOut} FilterOut
             */
            FilterOut.fromObject = function fromObject(object) {
                if (object instanceof $root.wavesenterprise.EventsFilter.FilterOut)
                    return object;
                return new $root.wavesenterprise.EventsFilter.FilterOut();
            };

            /**
             * Creates a plain object from a FilterOut message. Also converts values to other types if specified.
             * @function toObject
             * @memberof wavesenterprise.EventsFilter.FilterOut
             * @static
             * @param {wavesenterprise.EventsFilter.FilterOut} message FilterOut
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FilterOut.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this FilterOut to JSON.
             * @function toJSON
             * @memberof wavesenterprise.EventsFilter.FilterOut
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FilterOut.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return FilterOut;
        })();

        return EventsFilter;
    })();

    wavesenterprise.TxTypeFilter = (function() {

        /**
         * Properties of a TxTypeFilter.
         * @memberof wavesenterprise
         * @interface ITxTypeFilter
         * @property {Array.<number>|null} [txTypes] TxTypeFilter txTypes
         */

        /**
         * Constructs a new TxTypeFilter.
         * @memberof wavesenterprise
         * @classdesc Represents a TxTypeFilter.
         * @implements ITxTypeFilter
         * @constructor
         * @param {wavesenterprise.ITxTypeFilter=} [properties] Properties to set
         */
        function TxTypeFilter(properties) {
            this.txTypes = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TxTypeFilter txTypes.
         * @member {Array.<number>} txTypes
         * @memberof wavesenterprise.TxTypeFilter
         * @instance
         */
        TxTypeFilter.prototype.txTypes = $util.emptyArray;

        /**
         * Creates a new TxTypeFilter instance using the specified properties.
         * @function create
         * @memberof wavesenterprise.TxTypeFilter
         * @static
         * @param {wavesenterprise.ITxTypeFilter=} [properties] Properties to set
         * @returns {wavesenterprise.TxTypeFilter} TxTypeFilter instance
         */
        TxTypeFilter.create = function create(properties) {
            return new TxTypeFilter(properties);
        };

        /**
         * Encodes the specified TxTypeFilter message. Does not implicitly {@link wavesenterprise.TxTypeFilter.verify|verify} messages.
         * @function encode
         * @memberof wavesenterprise.TxTypeFilter
         * @static
         * @param {wavesenterprise.ITxTypeFilter} message TxTypeFilter message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TxTypeFilter.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.txTypes != null && message.txTypes.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (var i = 0; i < message.txTypes.length; ++i)
                    writer.int32(message.txTypes[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified TxTypeFilter message, length delimited. Does not implicitly {@link wavesenterprise.TxTypeFilter.verify|verify} messages.
         * @function encodeDelimited
         * @memberof wavesenterprise.TxTypeFilter
         * @static
         * @param {wavesenterprise.ITxTypeFilter} message TxTypeFilter message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TxTypeFilter.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TxTypeFilter message from the specified reader or buffer.
         * @function decode
         * @memberof wavesenterprise.TxTypeFilter
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {wavesenterprise.TxTypeFilter} TxTypeFilter
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TxTypeFilter.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.wavesenterprise.TxTypeFilter();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.txTypes && message.txTypes.length))
                        message.txTypes = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.txTypes.push(reader.int32());
                    } else
                        message.txTypes.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TxTypeFilter message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof wavesenterprise.TxTypeFilter
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {wavesenterprise.TxTypeFilter} TxTypeFilter
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TxTypeFilter.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TxTypeFilter message.
         * @function verify
         * @memberof wavesenterprise.TxTypeFilter
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TxTypeFilter.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.txTypes != null && message.hasOwnProperty("txTypes")) {
                if (!Array.isArray(message.txTypes))
                    return "txTypes: array expected";
                for (var i = 0; i < message.txTypes.length; ++i)
                    if (!$util.isInteger(message.txTypes[i]))
                        return "txTypes: integer[] expected";
            }
            return null;
        };

        /**
         * Creates a TxTypeFilter message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof wavesenterprise.TxTypeFilter
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {wavesenterprise.TxTypeFilter} TxTypeFilter
         */
        TxTypeFilter.fromObject = function fromObject(object) {
            if (object instanceof $root.wavesenterprise.TxTypeFilter)
                return object;
            var message = new $root.wavesenterprise.TxTypeFilter();
            if (object.txTypes) {
                if (!Array.isArray(object.txTypes))
                    throw TypeError(".wavesenterprise.TxTypeFilter.txTypes: array expected");
                message.txTypes = [];
                for (var i = 0; i < object.txTypes.length; ++i)
                    message.txTypes[i] = object.txTypes[i] | 0;
            }
            return message;
        };

        /**
         * Creates a plain object from a TxTypeFilter message. Also converts values to other types if specified.
         * @function toObject
         * @memberof wavesenterprise.TxTypeFilter
         * @static
         * @param {wavesenterprise.TxTypeFilter} message TxTypeFilter
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TxTypeFilter.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.txTypes = [];
            if (message.txTypes && message.txTypes.length) {
                object.txTypes = [];
                for (var j = 0; j < message.txTypes.length; ++j)
                    object.txTypes[j] = message.txTypes[j];
            }
            return object;
        };

        /**
         * Converts this TxTypeFilter to JSON.
         * @function toJSON
         * @memberof wavesenterprise.TxTypeFilter
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TxTypeFilter.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TxTypeFilter;
    })();

    wavesenterprise.ContractIdFilter = (function() {

        /**
         * Properties of a ContractIdFilter.
         * @memberof wavesenterprise
         * @interface IContractIdFilter
         * @property {Array.<Uint8Array>|null} [contractIds] ContractIdFilter contractIds
         */

        /**
         * Constructs a new ContractIdFilter.
         * @memberof wavesenterprise
         * @classdesc Represents a ContractIdFilter.
         * @implements IContractIdFilter
         * @constructor
         * @param {wavesenterprise.IContractIdFilter=} [properties] Properties to set
         */
        function ContractIdFilter(properties) {
            this.contractIds = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ContractIdFilter contractIds.
         * @member {Array.<Uint8Array>} contractIds
         * @memberof wavesenterprise.ContractIdFilter
         * @instance
         */
        ContractIdFilter.prototype.contractIds = $util.emptyArray;

        /**
         * Creates a new ContractIdFilter instance using the specified properties.
         * @function create
         * @memberof wavesenterprise.ContractIdFilter
         * @static
         * @param {wavesenterprise.IContractIdFilter=} [properties] Properties to set
         * @returns {wavesenterprise.ContractIdFilter} ContractIdFilter instance
         */
        ContractIdFilter.create = function create(properties) {
            return new ContractIdFilter(properties);
        };

        /**
         * Encodes the specified ContractIdFilter message. Does not implicitly {@link wavesenterprise.ContractIdFilter.verify|verify} messages.
         * @function encode
         * @memberof wavesenterprise.ContractIdFilter
         * @static
         * @param {wavesenterprise.IContractIdFilter} message ContractIdFilter message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContractIdFilter.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.contractIds != null && message.contractIds.length)
                for (var i = 0; i < message.contractIds.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.contractIds[i]);
            return writer;
        };

        /**
         * Encodes the specified ContractIdFilter message, length delimited. Does not implicitly {@link wavesenterprise.ContractIdFilter.verify|verify} messages.
         * @function encodeDelimited
         * @memberof wavesenterprise.ContractIdFilter
         * @static
         * @param {wavesenterprise.IContractIdFilter} message ContractIdFilter message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContractIdFilter.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ContractIdFilter message from the specified reader or buffer.
         * @function decode
         * @memberof wavesenterprise.ContractIdFilter
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {wavesenterprise.ContractIdFilter} ContractIdFilter
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContractIdFilter.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.wavesenterprise.ContractIdFilter();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.contractIds && message.contractIds.length))
                        message.contractIds = [];
                    message.contractIds.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ContractIdFilter message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof wavesenterprise.ContractIdFilter
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {wavesenterprise.ContractIdFilter} ContractIdFilter
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContractIdFilter.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ContractIdFilter message.
         * @function verify
         * @memberof wavesenterprise.ContractIdFilter
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ContractIdFilter.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.contractIds != null && message.hasOwnProperty("contractIds")) {
                if (!Array.isArray(message.contractIds))
                    return "contractIds: array expected";
                for (var i = 0; i < message.contractIds.length; ++i)
                    if (!(message.contractIds[i] && typeof message.contractIds[i].length === "number" || $util.isString(message.contractIds[i])))
                        return "contractIds: buffer[] expected";
            }
            return null;
        };

        /**
         * Creates a ContractIdFilter message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof wavesenterprise.ContractIdFilter
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {wavesenterprise.ContractIdFilter} ContractIdFilter
         */
        ContractIdFilter.fromObject = function fromObject(object) {
            if (object instanceof $root.wavesenterprise.ContractIdFilter)
                return object;
            var message = new $root.wavesenterprise.ContractIdFilter();
            if (object.contractIds) {
                if (!Array.isArray(object.contractIds))
                    throw TypeError(".wavesenterprise.ContractIdFilter.contractIds: array expected");
                message.contractIds = [];
                for (var i = 0; i < object.contractIds.length; ++i)
                    if (typeof object.contractIds[i] === "string")
                        $util.base64.decode(object.contractIds[i], message.contractIds[i] = $util.newBuffer($util.base64.length(object.contractIds[i])), 0);
                    else if (object.contractIds[i].length)
                        message.contractIds[i] = object.contractIds[i];
            }
            return message;
        };

        /**
         * Creates a plain object from a ContractIdFilter message. Also converts values to other types if specified.
         * @function toObject
         * @memberof wavesenterprise.ContractIdFilter
         * @static
         * @param {wavesenterprise.ContractIdFilter} message ContractIdFilter
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ContractIdFilter.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.contractIds = [];
            if (message.contractIds && message.contractIds.length) {
                object.contractIds = [];
                for (var j = 0; j < message.contractIds.length; ++j)
                    object.contractIds[j] = options.bytes === String ? $util.base64.encode(message.contractIds[j], 0, message.contractIds[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.contractIds[j]) : message.contractIds[j];
            }
            return object;
        };

        /**
         * Converts this ContractIdFilter to JSON.
         * @function toJSON
         * @memberof wavesenterprise.ContractIdFilter
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ContractIdFilter.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ContractIdFilter;
    })();

    wavesenterprise.ContractStatusService = (function() {

        /**
         * Constructs a new ContractStatusService service.
         * @memberof wavesenterprise
         * @classdesc Represents a ContractStatusService
         * @extends $protobuf.rpc.Service
         * @constructor
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         */
        function ContractStatusService(rpcImpl, requestDelimited, responseDelimited) {
            $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }

        (ContractStatusService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = ContractStatusService;

        /**
         * Creates new ContractStatusService service using the specified rpc implementation.
         * @function create
         * @memberof wavesenterprise.ContractStatusService
         * @static
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         * @returns {ContractStatusService} RPC service. Useful where requests and/or responses are streamed.
         */
        ContractStatusService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
            return new this(rpcImpl, requestDelimited, responseDelimited);
        };

        /**
         * Callback as used by {@link wavesenterprise.ContractStatusService#contractExecutionStatuses}.
         * @memberof wavesenterprise.ContractStatusService
         * @typedef ContractExecutionStatusesCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {wavesenterprise.ContractExecutionResponse} [response] ContractExecutionResponse
         */

        /**
         * Calls ContractExecutionStatuses.
         * @function contractExecutionStatuses
         * @memberof wavesenterprise.ContractStatusService
         * @instance
         * @param {wavesenterprise.IContractExecutionRequest} request ContractExecutionRequest message or plain object
         * @param {wavesenterprise.ContractStatusService.ContractExecutionStatusesCallback} callback Node-style callback called with the error, if any, and ContractExecutionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ContractStatusService.prototype.contractExecutionStatuses = function contractExecutionStatuses(request, callback) {
            return this.rpcCall(contractExecutionStatuses, $root.wavesenterprise.ContractExecutionRequest, $root.wavesenterprise.ContractExecutionResponse, request, callback);
        }, "name", { value: "ContractExecutionStatuses" });

        /**
         * Calls ContractExecutionStatuses.
         * @function contractExecutionStatuses
         * @memberof wavesenterprise.ContractStatusService
         * @instance
         * @param {wavesenterprise.IContractExecutionRequest} request ContractExecutionRequest message or plain object
         * @returns {Promise<wavesenterprise.ContractExecutionResponse>} Promise
         * @variation 2
         */

        return ContractStatusService;
    })();

    wavesenterprise.ContractExecutionRequest = (function() {

        /**
         * Properties of a ContractExecutionRequest.
         * @memberof wavesenterprise
         * @interface IContractExecutionRequest
         * @property {Uint8Array|null} [txId] ContractExecutionRequest txId
         */

        /**
         * Constructs a new ContractExecutionRequest.
         * @memberof wavesenterprise
         * @classdesc Represents a ContractExecutionRequest.
         * @implements IContractExecutionRequest
         * @constructor
         * @param {wavesenterprise.IContractExecutionRequest=} [properties] Properties to set
         */
        function ContractExecutionRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ContractExecutionRequest txId.
         * @member {Uint8Array} txId
         * @memberof wavesenterprise.ContractExecutionRequest
         * @instance
         */
        ContractExecutionRequest.prototype.txId = $util.newBuffer([]);

        /**
         * Creates a new ContractExecutionRequest instance using the specified properties.
         * @function create
         * @memberof wavesenterprise.ContractExecutionRequest
         * @static
         * @param {wavesenterprise.IContractExecutionRequest=} [properties] Properties to set
         * @returns {wavesenterprise.ContractExecutionRequest} ContractExecutionRequest instance
         */
        ContractExecutionRequest.create = function create(properties) {
            return new ContractExecutionRequest(properties);
        };

        /**
         * Encodes the specified ContractExecutionRequest message. Does not implicitly {@link wavesenterprise.ContractExecutionRequest.verify|verify} messages.
         * @function encode
         * @memberof wavesenterprise.ContractExecutionRequest
         * @static
         * @param {wavesenterprise.IContractExecutionRequest} message ContractExecutionRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContractExecutionRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.txId != null && Object.hasOwnProperty.call(message, "txId"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.txId);
            return writer;
        };

        /**
         * Encodes the specified ContractExecutionRequest message, length delimited. Does not implicitly {@link wavesenterprise.ContractExecutionRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof wavesenterprise.ContractExecutionRequest
         * @static
         * @param {wavesenterprise.IContractExecutionRequest} message ContractExecutionRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContractExecutionRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ContractExecutionRequest message from the specified reader or buffer.
         * @function decode
         * @memberof wavesenterprise.ContractExecutionRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {wavesenterprise.ContractExecutionRequest} ContractExecutionRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContractExecutionRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.wavesenterprise.ContractExecutionRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.txId = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ContractExecutionRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof wavesenterprise.ContractExecutionRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {wavesenterprise.ContractExecutionRequest} ContractExecutionRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContractExecutionRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ContractExecutionRequest message.
         * @function verify
         * @memberof wavesenterprise.ContractExecutionRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ContractExecutionRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.txId != null && message.hasOwnProperty("txId"))
                if (!(message.txId && typeof message.txId.length === "number" || $util.isString(message.txId)))
                    return "txId: buffer expected";
            return null;
        };

        /**
         * Creates a ContractExecutionRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof wavesenterprise.ContractExecutionRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {wavesenterprise.ContractExecutionRequest} ContractExecutionRequest
         */
        ContractExecutionRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.wavesenterprise.ContractExecutionRequest)
                return object;
            var message = new $root.wavesenterprise.ContractExecutionRequest();
            if (object.txId != null)
                if (typeof object.txId === "string")
                    $util.base64.decode(object.txId, message.txId = $util.newBuffer($util.base64.length(object.txId)), 0);
                else if (object.txId.length)
                    message.txId = object.txId;
            return message;
        };

        /**
         * Creates a plain object from a ContractExecutionRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof wavesenterprise.ContractExecutionRequest
         * @static
         * @param {wavesenterprise.ContractExecutionRequest} message ContractExecutionRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ContractExecutionRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.txId = "";
                else {
                    object.txId = [];
                    if (options.bytes !== Array)
                        object.txId = $util.newBuffer(object.txId);
                }
            if (message.txId != null && message.hasOwnProperty("txId"))
                object.txId = options.bytes === String ? $util.base64.encode(message.txId, 0, message.txId.length) : options.bytes === Array ? Array.prototype.slice.call(message.txId) : message.txId;
            return object;
        };

        /**
         * Converts this ContractExecutionRequest to JSON.
         * @function toJSON
         * @memberof wavesenterprise.ContractExecutionRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ContractExecutionRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ContractExecutionRequest;
    })();

    wavesenterprise.ContractExecutionResponse = (function() {

        /**
         * Properties of a ContractExecutionResponse.
         * @memberof wavesenterprise
         * @interface IContractExecutionResponse
         * @property {Uint8Array|null} [sender] ContractExecutionResponse sender
         * @property {Uint8Array|null} [txId] ContractExecutionResponse txId
         * @property {wavesenterprise.ContractExecutionResponse.Status|null} [status] ContractExecutionResponse status
         * @property {google.protobuf.IInt32Value|null} [code] ContractExecutionResponse code
         * @property {string|null} [message] ContractExecutionResponse message
         * @property {number|Long|null} [timestamp] ContractExecutionResponse timestamp
         * @property {Uint8Array|null} [signature] ContractExecutionResponse signature
         */

        /**
         * Constructs a new ContractExecutionResponse.
         * @memberof wavesenterprise
         * @classdesc Represents a ContractExecutionResponse.
         * @implements IContractExecutionResponse
         * @constructor
         * @param {wavesenterprise.IContractExecutionResponse=} [properties] Properties to set
         */
        function ContractExecutionResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ContractExecutionResponse sender.
         * @member {Uint8Array} sender
         * @memberof wavesenterprise.ContractExecutionResponse
         * @instance
         */
        ContractExecutionResponse.prototype.sender = $util.newBuffer([]);

        /**
         * ContractExecutionResponse txId.
         * @member {Uint8Array} txId
         * @memberof wavesenterprise.ContractExecutionResponse
         * @instance
         */
        ContractExecutionResponse.prototype.txId = $util.newBuffer([]);

        /**
         * ContractExecutionResponse status.
         * @member {wavesenterprise.ContractExecutionResponse.Status} status
         * @memberof wavesenterprise.ContractExecutionResponse
         * @instance
         */
        ContractExecutionResponse.prototype.status = 0;

        /**
         * ContractExecutionResponse code.
         * @member {google.protobuf.IInt32Value|null|undefined} code
         * @memberof wavesenterprise.ContractExecutionResponse
         * @instance
         */
        ContractExecutionResponse.prototype.code = null;

        /**
         * ContractExecutionResponse message.
         * @member {string} message
         * @memberof wavesenterprise.ContractExecutionResponse
         * @instance
         */
        ContractExecutionResponse.prototype.message = "";

        /**
         * ContractExecutionResponse timestamp.
         * @member {number|Long} timestamp
         * @memberof wavesenterprise.ContractExecutionResponse
         * @instance
         */
        ContractExecutionResponse.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ContractExecutionResponse signature.
         * @member {Uint8Array} signature
         * @memberof wavesenterprise.ContractExecutionResponse
         * @instance
         */
        ContractExecutionResponse.prototype.signature = $util.newBuffer([]);

        /**
         * Creates a new ContractExecutionResponse instance using the specified properties.
         * @function create
         * @memberof wavesenterprise.ContractExecutionResponse
         * @static
         * @param {wavesenterprise.IContractExecutionResponse=} [properties] Properties to set
         * @returns {wavesenterprise.ContractExecutionResponse} ContractExecutionResponse instance
         */
        ContractExecutionResponse.create = function create(properties) {
            return new ContractExecutionResponse(properties);
        };

        /**
         * Encodes the specified ContractExecutionResponse message. Does not implicitly {@link wavesenterprise.ContractExecutionResponse.verify|verify} messages.
         * @function encode
         * @memberof wavesenterprise.ContractExecutionResponse
         * @static
         * @param {wavesenterprise.IContractExecutionResponse} message ContractExecutionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContractExecutionResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.sender != null && Object.hasOwnProperty.call(message, "sender"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.sender);
            if (message.txId != null && Object.hasOwnProperty.call(message, "txId"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.txId);
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.status);
            if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                $root.google.protobuf.Int32Value.encode(message.code, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.message);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.timestamp);
            if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.signature);
            return writer;
        };

        /**
         * Encodes the specified ContractExecutionResponse message, length delimited. Does not implicitly {@link wavesenterprise.ContractExecutionResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof wavesenterprise.ContractExecutionResponse
         * @static
         * @param {wavesenterprise.IContractExecutionResponse} message ContractExecutionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContractExecutionResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ContractExecutionResponse message from the specified reader or buffer.
         * @function decode
         * @memberof wavesenterprise.ContractExecutionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {wavesenterprise.ContractExecutionResponse} ContractExecutionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContractExecutionResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.wavesenterprise.ContractExecutionResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.sender = reader.bytes();
                    break;
                case 2:
                    message.txId = reader.bytes();
                    break;
                case 3:
                    message.status = reader.int32();
                    break;
                case 4:
                    message.code = $root.google.protobuf.Int32Value.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.message = reader.string();
                    break;
                case 6:
                    message.timestamp = reader.int64();
                    break;
                case 7:
                    message.signature = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ContractExecutionResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof wavesenterprise.ContractExecutionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {wavesenterprise.ContractExecutionResponse} ContractExecutionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContractExecutionResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ContractExecutionResponse message.
         * @function verify
         * @memberof wavesenterprise.ContractExecutionResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ContractExecutionResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.sender != null && message.hasOwnProperty("sender"))
                if (!(message.sender && typeof message.sender.length === "number" || $util.isString(message.sender)))
                    return "sender: buffer expected";
            if (message.txId != null && message.hasOwnProperty("txId"))
                if (!(message.txId && typeof message.txId.length === "number" || $util.isString(message.txId)))
                    return "txId: buffer expected";
            if (message.status != null && message.hasOwnProperty("status"))
                switch (message.status) {
                default:
                    return "status: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.code != null && message.hasOwnProperty("code")) {
                var error = $root.google.protobuf.Int32Value.verify(message.code);
                if (error)
                    return "code." + error;
            }
            if (message.message != null && message.hasOwnProperty("message"))
                if (!$util.isString(message.message))
                    return "message: string expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            if (message.signature != null && message.hasOwnProperty("signature"))
                if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                    return "signature: buffer expected";
            return null;
        };

        /**
         * Creates a ContractExecutionResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof wavesenterprise.ContractExecutionResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {wavesenterprise.ContractExecutionResponse} ContractExecutionResponse
         */
        ContractExecutionResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.wavesenterprise.ContractExecutionResponse)
                return object;
            var message = new $root.wavesenterprise.ContractExecutionResponse();
            if (object.sender != null)
                if (typeof object.sender === "string")
                    $util.base64.decode(object.sender, message.sender = $util.newBuffer($util.base64.length(object.sender)), 0);
                else if (object.sender.length)
                    message.sender = object.sender;
            if (object.txId != null)
                if (typeof object.txId === "string")
                    $util.base64.decode(object.txId, message.txId = $util.newBuffer($util.base64.length(object.txId)), 0);
                else if (object.txId.length)
                    message.txId = object.txId;
            switch (object.status) {
            case "SUCCESS":
            case 0:
                message.status = 0;
                break;
            case "ERROR":
            case 1:
                message.status = 1;
                break;
            case "FAILURE":
            case 2:
                message.status = 2;
                break;
            }
            if (object.code != null) {
                if (typeof object.code !== "object")
                    throw TypeError(".wavesenterprise.ContractExecutionResponse.code: object expected");
                message.code = $root.google.protobuf.Int32Value.fromObject(object.code);
            }
            if (object.message != null)
                message.message = String(object.message);
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            if (object.signature != null)
                if (typeof object.signature === "string")
                    $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                else if (object.signature.length)
                    message.signature = object.signature;
            return message;
        };

        /**
         * Creates a plain object from a ContractExecutionResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof wavesenterprise.ContractExecutionResponse
         * @static
         * @param {wavesenterprise.ContractExecutionResponse} message ContractExecutionResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ContractExecutionResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.sender = "";
                else {
                    object.sender = [];
                    if (options.bytes !== Array)
                        object.sender = $util.newBuffer(object.sender);
                }
                if (options.bytes === String)
                    object.txId = "";
                else {
                    object.txId = [];
                    if (options.bytes !== Array)
                        object.txId = $util.newBuffer(object.txId);
                }
                object.status = options.enums === String ? "SUCCESS" : 0;
                object.code = null;
                object.message = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.signature = "";
                else {
                    object.signature = [];
                    if (options.bytes !== Array)
                        object.signature = $util.newBuffer(object.signature);
                }
            }
            if (message.sender != null && message.hasOwnProperty("sender"))
                object.sender = options.bytes === String ? $util.base64.encode(message.sender, 0, message.sender.length) : options.bytes === Array ? Array.prototype.slice.call(message.sender) : message.sender;
            if (message.txId != null && message.hasOwnProperty("txId"))
                object.txId = options.bytes === String ? $util.base64.encode(message.txId, 0, message.txId.length) : options.bytes === Array ? Array.prototype.slice.call(message.txId) : message.txId;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = options.enums === String ? $root.wavesenterprise.ContractExecutionResponse.Status[message.status] : message.status;
            if (message.code != null && message.hasOwnProperty("code"))
                object.code = $root.google.protobuf.Int32Value.toObject(message.code, options);
            if (message.message != null && message.hasOwnProperty("message"))
                object.message = message.message;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            if (message.signature != null && message.hasOwnProperty("signature"))
                object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
            return object;
        };

        /**
         * Converts this ContractExecutionResponse to JSON.
         * @function toJSON
         * @memberof wavesenterprise.ContractExecutionResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ContractExecutionResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Status enum.
         * @name wavesenterprise.ContractExecutionResponse.Status
         * @enum {number}
         * @property {number} SUCCESS=0 SUCCESS value
         * @property {number} ERROR=1 ERROR value
         * @property {number} FAILURE=2 FAILURE value
         */
        ContractExecutionResponse.Status = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "SUCCESS"] = 0;
            values[valuesById[1] = "ERROR"] = 1;
            values[valuesById[2] = "FAILURE"] = 2;
            return values;
        })();

        return ContractExecutionResponse;
    })();

    wavesenterprise.NodeInfoService = (function() {

        /**
         * Constructs a new NodeInfoService service.
         * @memberof wavesenterprise
         * @classdesc Represents a NodeInfoService
         * @extends $protobuf.rpc.Service
         * @constructor
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         */
        function NodeInfoService(rpcImpl, requestDelimited, responseDelimited) {
            $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }

        (NodeInfoService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = NodeInfoService;

        /**
         * Creates new NodeInfoService service using the specified rpc implementation.
         * @function create
         * @memberof wavesenterprise.NodeInfoService
         * @static
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         * @returns {NodeInfoService} RPC service. Useful where requests and/or responses are streamed.
         */
        NodeInfoService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
            return new this(rpcImpl, requestDelimited, responseDelimited);
        };

        /**
         * Callback as used by {@link wavesenterprise.NodeInfoService#nodeConfig}.
         * @memberof wavesenterprise.NodeInfoService
         * @typedef NodeConfigCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {wavesenterprise.NodeConfigResponse} [response] NodeConfigResponse
         */

        /**
         * Calls NodeConfig.
         * @function nodeConfig
         * @memberof wavesenterprise.NodeInfoService
         * @instance
         * @param {google.protobuf.IEmpty} request Empty message or plain object
         * @param {wavesenterprise.NodeInfoService.NodeConfigCallback} callback Node-style callback called with the error, if any, and NodeConfigResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(NodeInfoService.prototype.nodeConfig = function nodeConfig(request, callback) {
            return this.rpcCall(nodeConfig, $root.google.protobuf.Empty, $root.wavesenterprise.NodeConfigResponse, request, callback);
        }, "name", { value: "NodeConfig" });

        /**
         * Calls NodeConfig.
         * @function nodeConfig
         * @memberof wavesenterprise.NodeInfoService
         * @instance
         * @param {google.protobuf.IEmpty} request Empty message or plain object
         * @returns {Promise<wavesenterprise.NodeConfigResponse>} Promise
         * @variation 2
         */

        return NodeInfoService;
    })();

    wavesenterprise.NodeConfigResponse = (function() {

        /**
         * Properties of a NodeConfigResponse.
         * @memberof wavesenterprise
         * @interface INodeConfigResponse
         * @property {string|null} [version] NodeConfigResponse version
         * @property {wavesenterprise.CryptoType|null} [cryptoType] NodeConfigResponse cryptoType
         * @property {number|null} [chainId] NodeConfigResponse chainId
         * @property {wavesenterprise.ConsensusType|null} [consensus] NodeConfigResponse consensus
         * @property {Object.<string,number|Long>|null} [minimumFee] NodeConfigResponse minimumFee
         * @property {Object.<string,number|Long>|null} [additionalFee] NodeConfigResponse additionalFee
         * @property {number|null} [maxTransactionsInMicroBlock] NodeConfigResponse maxTransactionsInMicroBlock
         * @property {google.protobuf.IDuration|null} [minMicroBlockAge] NodeConfigResponse minMicroBlockAge
         * @property {google.protobuf.IDuration|null} [microBlockInterval] NodeConfigResponse microBlockInterval
         * @property {wavesenterprise.IPoaRoundInfo|null} [poaRoundInfo] NodeConfigResponse poaRoundInfo
         * @property {wavesenterprise.IPosRoundInfo|null} [posRoundInfo] NodeConfigResponse posRoundInfo
         */

        /**
         * Constructs a new NodeConfigResponse.
         * @memberof wavesenterprise
         * @classdesc Represents a NodeConfigResponse.
         * @implements INodeConfigResponse
         * @constructor
         * @param {wavesenterprise.INodeConfigResponse=} [properties] Properties to set
         */
        function NodeConfigResponse(properties) {
            this.minimumFee = {};
            this.additionalFee = {};
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * NodeConfigResponse version.
         * @member {string} version
         * @memberof wavesenterprise.NodeConfigResponse
         * @instance
         */
        NodeConfigResponse.prototype.version = "";

        /**
         * NodeConfigResponse cryptoType.
         * @member {wavesenterprise.CryptoType} cryptoType
         * @memberof wavesenterprise.NodeConfigResponse
         * @instance
         */
        NodeConfigResponse.prototype.cryptoType = 0;

        /**
         * NodeConfigResponse chainId.
         * @member {number} chainId
         * @memberof wavesenterprise.NodeConfigResponse
         * @instance
         */
        NodeConfigResponse.prototype.chainId = 0;

        /**
         * NodeConfigResponse consensus.
         * @member {wavesenterprise.ConsensusType} consensus
         * @memberof wavesenterprise.NodeConfigResponse
         * @instance
         */
        NodeConfigResponse.prototype.consensus = 0;

        /**
         * NodeConfigResponse minimumFee.
         * @member {Object.<string,number|Long>} minimumFee
         * @memberof wavesenterprise.NodeConfigResponse
         * @instance
         */
        NodeConfigResponse.prototype.minimumFee = $util.emptyObject;

        /**
         * NodeConfigResponse additionalFee.
         * @member {Object.<string,number|Long>} additionalFee
         * @memberof wavesenterprise.NodeConfigResponse
         * @instance
         */
        NodeConfigResponse.prototype.additionalFee = $util.emptyObject;

        /**
         * NodeConfigResponse maxTransactionsInMicroBlock.
         * @member {number} maxTransactionsInMicroBlock
         * @memberof wavesenterprise.NodeConfigResponse
         * @instance
         */
        NodeConfigResponse.prototype.maxTransactionsInMicroBlock = 0;

        /**
         * NodeConfigResponse minMicroBlockAge.
         * @member {google.protobuf.IDuration|null|undefined} minMicroBlockAge
         * @memberof wavesenterprise.NodeConfigResponse
         * @instance
         */
        NodeConfigResponse.prototype.minMicroBlockAge = null;

        /**
         * NodeConfigResponse microBlockInterval.
         * @member {google.protobuf.IDuration|null|undefined} microBlockInterval
         * @memberof wavesenterprise.NodeConfigResponse
         * @instance
         */
        NodeConfigResponse.prototype.microBlockInterval = null;

        /**
         * NodeConfigResponse poaRoundInfo.
         * @member {wavesenterprise.IPoaRoundInfo|null|undefined} poaRoundInfo
         * @memberof wavesenterprise.NodeConfigResponse
         * @instance
         */
        NodeConfigResponse.prototype.poaRoundInfo = null;

        /**
         * NodeConfigResponse posRoundInfo.
         * @member {wavesenterprise.IPosRoundInfo|null|undefined} posRoundInfo
         * @memberof wavesenterprise.NodeConfigResponse
         * @instance
         */
        NodeConfigResponse.prototype.posRoundInfo = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * NodeConfigResponse blockTiming.
         * @member {"poaRoundInfo"|"posRoundInfo"|undefined} blockTiming
         * @memberof wavesenterprise.NodeConfigResponse
         * @instance
         */
        Object.defineProperty(NodeConfigResponse.prototype, "blockTiming", {
            get: $util.oneOfGetter($oneOfFields = ["poaRoundInfo", "posRoundInfo"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new NodeConfigResponse instance using the specified properties.
         * @function create
         * @memberof wavesenterprise.NodeConfigResponse
         * @static
         * @param {wavesenterprise.INodeConfigResponse=} [properties] Properties to set
         * @returns {wavesenterprise.NodeConfigResponse} NodeConfigResponse instance
         */
        NodeConfigResponse.create = function create(properties) {
            return new NodeConfigResponse(properties);
        };

        /**
         * Encodes the specified NodeConfigResponse message. Does not implicitly {@link wavesenterprise.NodeConfigResponse.verify|verify} messages.
         * @function encode
         * @memberof wavesenterprise.NodeConfigResponse
         * @static
         * @param {wavesenterprise.INodeConfigResponse} message NodeConfigResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NodeConfigResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.version);
            if (message.cryptoType != null && Object.hasOwnProperty.call(message, "cryptoType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.cryptoType);
            if (message.chainId != null && Object.hasOwnProperty.call(message, "chainId"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.chainId);
            if (message.consensus != null && Object.hasOwnProperty.call(message, "consensus"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.consensus);
            if (message.minimumFee != null && Object.hasOwnProperty.call(message, "minimumFee"))
                for (var keys = Object.keys(message.minimumFee), i = 0; i < keys.length; ++i)
                    writer.uint32(/* id 5, wireType 2 =*/42).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 0 =*/16).int64(message.minimumFee[keys[i]]).ldelim();
            if (message.additionalFee != null && Object.hasOwnProperty.call(message, "additionalFee"))
                for (var keys = Object.keys(message.additionalFee), i = 0; i < keys.length; ++i)
                    writer.uint32(/* id 6, wireType 2 =*/50).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 0 =*/16).int64(message.additionalFee[keys[i]]).ldelim();
            if (message.maxTransactionsInMicroBlock != null && Object.hasOwnProperty.call(message, "maxTransactionsInMicroBlock"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.maxTransactionsInMicroBlock);
            if (message.minMicroBlockAge != null && Object.hasOwnProperty.call(message, "minMicroBlockAge"))
                $root.google.protobuf.Duration.encode(message.minMicroBlockAge, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.microBlockInterval != null && Object.hasOwnProperty.call(message, "microBlockInterval"))
                $root.google.protobuf.Duration.encode(message.microBlockInterval, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.poaRoundInfo != null && Object.hasOwnProperty.call(message, "poaRoundInfo"))
                $root.wavesenterprise.PoaRoundInfo.encode(message.poaRoundInfo, writer.uint32(/* id 101, wireType 2 =*/810).fork()).ldelim();
            if (message.posRoundInfo != null && Object.hasOwnProperty.call(message, "posRoundInfo"))
                $root.wavesenterprise.PosRoundInfo.encode(message.posRoundInfo, writer.uint32(/* id 102, wireType 2 =*/818).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified NodeConfigResponse message, length delimited. Does not implicitly {@link wavesenterprise.NodeConfigResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof wavesenterprise.NodeConfigResponse
         * @static
         * @param {wavesenterprise.INodeConfigResponse} message NodeConfigResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NodeConfigResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NodeConfigResponse message from the specified reader or buffer.
         * @function decode
         * @memberof wavesenterprise.NodeConfigResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {wavesenterprise.NodeConfigResponse} NodeConfigResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NodeConfigResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.wavesenterprise.NodeConfigResponse(), key, value;
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.version = reader.string();
                    break;
                case 2:
                    message.cryptoType = reader.int32();
                    break;
                case 3:
                    message.chainId = reader.int32();
                    break;
                case 4:
                    message.consensus = reader.int32();
                    break;
                case 5:
                    if (message.minimumFee === $util.emptyObject)
                        message.minimumFee = {};
                    var end2 = reader.uint32() + reader.pos;
                    key = "";
                    value = 0;
                    while (reader.pos < end2) {
                        var tag2 = reader.uint32();
                        switch (tag2 >>> 3) {
                        case 1:
                            key = reader.string();
                            break;
                        case 2:
                            value = reader.int64();
                            break;
                        default:
                            reader.skipType(tag2 & 7);
                            break;
                        }
                    }
                    message.minimumFee[key] = value;
                    break;
                case 6:
                    if (message.additionalFee === $util.emptyObject)
                        message.additionalFee = {};
                    var end2 = reader.uint32() + reader.pos;
                    key = "";
                    value = 0;
                    while (reader.pos < end2) {
                        var tag2 = reader.uint32();
                        switch (tag2 >>> 3) {
                        case 1:
                            key = reader.string();
                            break;
                        case 2:
                            value = reader.int64();
                            break;
                        default:
                            reader.skipType(tag2 & 7);
                            break;
                        }
                    }
                    message.additionalFee[key] = value;
                    break;
                case 7:
                    message.maxTransactionsInMicroBlock = reader.int32();
                    break;
                case 8:
                    message.minMicroBlockAge = $root.google.protobuf.Duration.decode(reader, reader.uint32());
                    break;
                case 9:
                    message.microBlockInterval = $root.google.protobuf.Duration.decode(reader, reader.uint32());
                    break;
                case 101:
                    message.poaRoundInfo = $root.wavesenterprise.PoaRoundInfo.decode(reader, reader.uint32());
                    break;
                case 102:
                    message.posRoundInfo = $root.wavesenterprise.PosRoundInfo.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NodeConfigResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof wavesenterprise.NodeConfigResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {wavesenterprise.NodeConfigResponse} NodeConfigResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NodeConfigResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NodeConfigResponse message.
         * @function verify
         * @memberof wavesenterprise.NodeConfigResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NodeConfigResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isString(message.version))
                    return "version: string expected";
            if (message.cryptoType != null && message.hasOwnProperty("cryptoType"))
                switch (message.cryptoType) {
                default:
                    return "cryptoType: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.chainId != null && message.hasOwnProperty("chainId"))
                if (!$util.isInteger(message.chainId))
                    return "chainId: integer expected";
            if (message.consensus != null && message.hasOwnProperty("consensus"))
                switch (message.consensus) {
                default:
                    return "consensus: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.minimumFee != null && message.hasOwnProperty("minimumFee")) {
                if (!$util.isObject(message.minimumFee))
                    return "minimumFee: object expected";
                var key = Object.keys(message.minimumFee);
                for (var i = 0; i < key.length; ++i)
                    if (!$util.isInteger(message.minimumFee[key[i]]) && !(message.minimumFee[key[i]] && $util.isInteger(message.minimumFee[key[i]].low) && $util.isInteger(message.minimumFee[key[i]].high)))
                        return "minimumFee: integer|Long{k:string} expected";
            }
            if (message.additionalFee != null && message.hasOwnProperty("additionalFee")) {
                if (!$util.isObject(message.additionalFee))
                    return "additionalFee: object expected";
                var key = Object.keys(message.additionalFee);
                for (var i = 0; i < key.length; ++i)
                    if (!$util.isInteger(message.additionalFee[key[i]]) && !(message.additionalFee[key[i]] && $util.isInteger(message.additionalFee[key[i]].low) && $util.isInteger(message.additionalFee[key[i]].high)))
                        return "additionalFee: integer|Long{k:string} expected";
            }
            if (message.maxTransactionsInMicroBlock != null && message.hasOwnProperty("maxTransactionsInMicroBlock"))
                if (!$util.isInteger(message.maxTransactionsInMicroBlock))
                    return "maxTransactionsInMicroBlock: integer expected";
            if (message.minMicroBlockAge != null && message.hasOwnProperty("minMicroBlockAge")) {
                var error = $root.google.protobuf.Duration.verify(message.minMicroBlockAge);
                if (error)
                    return "minMicroBlockAge." + error;
            }
            if (message.microBlockInterval != null && message.hasOwnProperty("microBlockInterval")) {
                var error = $root.google.protobuf.Duration.verify(message.microBlockInterval);
                if (error)
                    return "microBlockInterval." + error;
            }
            if (message.poaRoundInfo != null && message.hasOwnProperty("poaRoundInfo")) {
                properties.blockTiming = 1;
                {
                    var error = $root.wavesenterprise.PoaRoundInfo.verify(message.poaRoundInfo);
                    if (error)
                        return "poaRoundInfo." + error;
                }
            }
            if (message.posRoundInfo != null && message.hasOwnProperty("posRoundInfo")) {
                if (properties.blockTiming === 1)
                    return "blockTiming: multiple values";
                properties.blockTiming = 1;
                {
                    var error = $root.wavesenterprise.PosRoundInfo.verify(message.posRoundInfo);
                    if (error)
                        return "posRoundInfo." + error;
                }
            }
            return null;
        };

        /**
         * Creates a NodeConfigResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof wavesenterprise.NodeConfigResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {wavesenterprise.NodeConfigResponse} NodeConfigResponse
         */
        NodeConfigResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.wavesenterprise.NodeConfigResponse)
                return object;
            var message = new $root.wavesenterprise.NodeConfigResponse();
            if (object.version != null)
                message.version = String(object.version);
            switch (object.cryptoType) {
            case "UNKNOWN_CRYPTO_TYPE":
            case 0:
                message.cryptoType = 0;
                break;
            case "GOST":
            case 1:
                message.cryptoType = 1;
                break;
            case "CURVE_25519":
            case 2:
                message.cryptoType = 2;
                break;
            }
            if (object.chainId != null)
                message.chainId = object.chainId | 0;
            switch (object.consensus) {
            case "UNKNOWN_CONSENSUS_TYPE":
            case 0:
                message.consensus = 0;
                break;
            case "POA":
            case 1:
                message.consensus = 1;
                break;
            case "POS":
            case 2:
                message.consensus = 2;
                break;
            case "CFT":
            case 3:
                message.consensus = 3;
                break;
            }
            if (object.minimumFee) {
                if (typeof object.minimumFee !== "object")
                    throw TypeError(".wavesenterprise.NodeConfigResponse.minimumFee: object expected");
                message.minimumFee = {};
                for (var keys = Object.keys(object.minimumFee), i = 0; i < keys.length; ++i)
                    if ($util.Long)
                        (message.minimumFee[keys[i]] = $util.Long.fromValue(object.minimumFee[keys[i]])).unsigned = false;
                    else if (typeof object.minimumFee[keys[i]] === "string")
                        message.minimumFee[keys[i]] = parseInt(object.minimumFee[keys[i]], 10);
                    else if (typeof object.minimumFee[keys[i]] === "number")
                        message.minimumFee[keys[i]] = object.minimumFee[keys[i]];
                    else if (typeof object.minimumFee[keys[i]] === "object")
                        message.minimumFee[keys[i]] = new $util.LongBits(object.minimumFee[keys[i]].low >>> 0, object.minimumFee[keys[i]].high >>> 0).toNumber();
            }
            if (object.additionalFee) {
                if (typeof object.additionalFee !== "object")
                    throw TypeError(".wavesenterprise.NodeConfigResponse.additionalFee: object expected");
                message.additionalFee = {};
                for (var keys = Object.keys(object.additionalFee), i = 0; i < keys.length; ++i)
                    if ($util.Long)
                        (message.additionalFee[keys[i]] = $util.Long.fromValue(object.additionalFee[keys[i]])).unsigned = false;
                    else if (typeof object.additionalFee[keys[i]] === "string")
                        message.additionalFee[keys[i]] = parseInt(object.additionalFee[keys[i]], 10);
                    else if (typeof object.additionalFee[keys[i]] === "number")
                        message.additionalFee[keys[i]] = object.additionalFee[keys[i]];
                    else if (typeof object.additionalFee[keys[i]] === "object")
                        message.additionalFee[keys[i]] = new $util.LongBits(object.additionalFee[keys[i]].low >>> 0, object.additionalFee[keys[i]].high >>> 0).toNumber();
            }
            if (object.maxTransactionsInMicroBlock != null)
                message.maxTransactionsInMicroBlock = object.maxTransactionsInMicroBlock | 0;
            if (object.minMicroBlockAge != null) {
                if (typeof object.minMicroBlockAge !== "object")
                    throw TypeError(".wavesenterprise.NodeConfigResponse.minMicroBlockAge: object expected");
                message.minMicroBlockAge = $root.google.protobuf.Duration.fromObject(object.minMicroBlockAge);
            }
            if (object.microBlockInterval != null) {
                if (typeof object.microBlockInterval !== "object")
                    throw TypeError(".wavesenterprise.NodeConfigResponse.microBlockInterval: object expected");
                message.microBlockInterval = $root.google.protobuf.Duration.fromObject(object.microBlockInterval);
            }
            if (object.poaRoundInfo != null) {
                if (typeof object.poaRoundInfo !== "object")
                    throw TypeError(".wavesenterprise.NodeConfigResponse.poaRoundInfo: object expected");
                message.poaRoundInfo = $root.wavesenterprise.PoaRoundInfo.fromObject(object.poaRoundInfo);
            }
            if (object.posRoundInfo != null) {
                if (typeof object.posRoundInfo !== "object")
                    throw TypeError(".wavesenterprise.NodeConfigResponse.posRoundInfo: object expected");
                message.posRoundInfo = $root.wavesenterprise.PosRoundInfo.fromObject(object.posRoundInfo);
            }
            return message;
        };

        /**
         * Creates a plain object from a NodeConfigResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof wavesenterprise.NodeConfigResponse
         * @static
         * @param {wavesenterprise.NodeConfigResponse} message NodeConfigResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NodeConfigResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.objects || options.defaults) {
                object.minimumFee = {};
                object.additionalFee = {};
            }
            if (options.defaults) {
                object.version = "";
                object.cryptoType = options.enums === String ? "UNKNOWN_CRYPTO_TYPE" : 0;
                object.chainId = 0;
                object.consensus = options.enums === String ? "UNKNOWN_CONSENSUS_TYPE" : 0;
                object.maxTransactionsInMicroBlock = 0;
                object.minMicroBlockAge = null;
                object.microBlockInterval = null;
            }
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            if (message.cryptoType != null && message.hasOwnProperty("cryptoType"))
                object.cryptoType = options.enums === String ? $root.wavesenterprise.CryptoType[message.cryptoType] : message.cryptoType;
            if (message.chainId != null && message.hasOwnProperty("chainId"))
                object.chainId = message.chainId;
            if (message.consensus != null && message.hasOwnProperty("consensus"))
                object.consensus = options.enums === String ? $root.wavesenterprise.ConsensusType[message.consensus] : message.consensus;
            var keys2;
            if (message.minimumFee && (keys2 = Object.keys(message.minimumFee)).length) {
                object.minimumFee = {};
                for (var j = 0; j < keys2.length; ++j)
                    if (typeof message.minimumFee[keys2[j]] === "number")
                        object.minimumFee[keys2[j]] = options.longs === String ? String(message.minimumFee[keys2[j]]) : message.minimumFee[keys2[j]];
                    else
                        object.minimumFee[keys2[j]] = options.longs === String ? $util.Long.prototype.toString.call(message.minimumFee[keys2[j]]) : options.longs === Number ? new $util.LongBits(message.minimumFee[keys2[j]].low >>> 0, message.minimumFee[keys2[j]].high >>> 0).toNumber() : message.minimumFee[keys2[j]];
            }
            if (message.additionalFee && (keys2 = Object.keys(message.additionalFee)).length) {
                object.additionalFee = {};
                for (var j = 0; j < keys2.length; ++j)
                    if (typeof message.additionalFee[keys2[j]] === "number")
                        object.additionalFee[keys2[j]] = options.longs === String ? String(message.additionalFee[keys2[j]]) : message.additionalFee[keys2[j]];
                    else
                        object.additionalFee[keys2[j]] = options.longs === String ? $util.Long.prototype.toString.call(message.additionalFee[keys2[j]]) : options.longs === Number ? new $util.LongBits(message.additionalFee[keys2[j]].low >>> 0, message.additionalFee[keys2[j]].high >>> 0).toNumber() : message.additionalFee[keys2[j]];
            }
            if (message.maxTransactionsInMicroBlock != null && message.hasOwnProperty("maxTransactionsInMicroBlock"))
                object.maxTransactionsInMicroBlock = message.maxTransactionsInMicroBlock;
            if (message.minMicroBlockAge != null && message.hasOwnProperty("minMicroBlockAge"))
                object.minMicroBlockAge = $root.google.protobuf.Duration.toObject(message.minMicroBlockAge, options);
            if (message.microBlockInterval != null && message.hasOwnProperty("microBlockInterval"))
                object.microBlockInterval = $root.google.protobuf.Duration.toObject(message.microBlockInterval, options);
            if (message.poaRoundInfo != null && message.hasOwnProperty("poaRoundInfo")) {
                object.poaRoundInfo = $root.wavesenterprise.PoaRoundInfo.toObject(message.poaRoundInfo, options);
                if (options.oneofs)
                    object.blockTiming = "poaRoundInfo";
            }
            if (message.posRoundInfo != null && message.hasOwnProperty("posRoundInfo")) {
                object.posRoundInfo = $root.wavesenterprise.PosRoundInfo.toObject(message.posRoundInfo, options);
                if (options.oneofs)
                    object.blockTiming = "posRoundInfo";
            }
            return object;
        };

        /**
         * Converts this NodeConfigResponse to JSON.
         * @function toJSON
         * @memberof wavesenterprise.NodeConfigResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NodeConfigResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return NodeConfigResponse;
    })();

    wavesenterprise.PoaRoundInfo = (function() {

        /**
         * Properties of a PoaRoundInfo.
         * @memberof wavesenterprise
         * @interface IPoaRoundInfo
         * @property {google.protobuf.IDuration|null} [roundDuration] PoaRoundInfo roundDuration
         * @property {google.protobuf.IDuration|null} [syncDuration] PoaRoundInfo syncDuration
         */

        /**
         * Constructs a new PoaRoundInfo.
         * @memberof wavesenterprise
         * @classdesc Represents a PoaRoundInfo.
         * @implements IPoaRoundInfo
         * @constructor
         * @param {wavesenterprise.IPoaRoundInfo=} [properties] Properties to set
         */
        function PoaRoundInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PoaRoundInfo roundDuration.
         * @member {google.protobuf.IDuration|null|undefined} roundDuration
         * @memberof wavesenterprise.PoaRoundInfo
         * @instance
         */
        PoaRoundInfo.prototype.roundDuration = null;

        /**
         * PoaRoundInfo syncDuration.
         * @member {google.protobuf.IDuration|null|undefined} syncDuration
         * @memberof wavesenterprise.PoaRoundInfo
         * @instance
         */
        PoaRoundInfo.prototype.syncDuration = null;

        /**
         * Creates a new PoaRoundInfo instance using the specified properties.
         * @function create
         * @memberof wavesenterprise.PoaRoundInfo
         * @static
         * @param {wavesenterprise.IPoaRoundInfo=} [properties] Properties to set
         * @returns {wavesenterprise.PoaRoundInfo} PoaRoundInfo instance
         */
        PoaRoundInfo.create = function create(properties) {
            return new PoaRoundInfo(properties);
        };

        /**
         * Encodes the specified PoaRoundInfo message. Does not implicitly {@link wavesenterprise.PoaRoundInfo.verify|verify} messages.
         * @function encode
         * @memberof wavesenterprise.PoaRoundInfo
         * @static
         * @param {wavesenterprise.IPoaRoundInfo} message PoaRoundInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PoaRoundInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.roundDuration != null && Object.hasOwnProperty.call(message, "roundDuration"))
                $root.google.protobuf.Duration.encode(message.roundDuration, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.syncDuration != null && Object.hasOwnProperty.call(message, "syncDuration"))
                $root.google.protobuf.Duration.encode(message.syncDuration, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified PoaRoundInfo message, length delimited. Does not implicitly {@link wavesenterprise.PoaRoundInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof wavesenterprise.PoaRoundInfo
         * @static
         * @param {wavesenterprise.IPoaRoundInfo} message PoaRoundInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PoaRoundInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PoaRoundInfo message from the specified reader or buffer.
         * @function decode
         * @memberof wavesenterprise.PoaRoundInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {wavesenterprise.PoaRoundInfo} PoaRoundInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PoaRoundInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.wavesenterprise.PoaRoundInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.roundDuration = $root.google.protobuf.Duration.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.syncDuration = $root.google.protobuf.Duration.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PoaRoundInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof wavesenterprise.PoaRoundInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {wavesenterprise.PoaRoundInfo} PoaRoundInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PoaRoundInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PoaRoundInfo message.
         * @function verify
         * @memberof wavesenterprise.PoaRoundInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PoaRoundInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.roundDuration != null && message.hasOwnProperty("roundDuration")) {
                var error = $root.google.protobuf.Duration.verify(message.roundDuration);
                if (error)
                    return "roundDuration." + error;
            }
            if (message.syncDuration != null && message.hasOwnProperty("syncDuration")) {
                var error = $root.google.protobuf.Duration.verify(message.syncDuration);
                if (error)
                    return "syncDuration." + error;
            }
            return null;
        };

        /**
         * Creates a PoaRoundInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof wavesenterprise.PoaRoundInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {wavesenterprise.PoaRoundInfo} PoaRoundInfo
         */
        PoaRoundInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.wavesenterprise.PoaRoundInfo)
                return object;
            var message = new $root.wavesenterprise.PoaRoundInfo();
            if (object.roundDuration != null) {
                if (typeof object.roundDuration !== "object")
                    throw TypeError(".wavesenterprise.PoaRoundInfo.roundDuration: object expected");
                message.roundDuration = $root.google.protobuf.Duration.fromObject(object.roundDuration);
            }
            if (object.syncDuration != null) {
                if (typeof object.syncDuration !== "object")
                    throw TypeError(".wavesenterprise.PoaRoundInfo.syncDuration: object expected");
                message.syncDuration = $root.google.protobuf.Duration.fromObject(object.syncDuration);
            }
            return message;
        };

        /**
         * Creates a plain object from a PoaRoundInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof wavesenterprise.PoaRoundInfo
         * @static
         * @param {wavesenterprise.PoaRoundInfo} message PoaRoundInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PoaRoundInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.roundDuration = null;
                object.syncDuration = null;
            }
            if (message.roundDuration != null && message.hasOwnProperty("roundDuration"))
                object.roundDuration = $root.google.protobuf.Duration.toObject(message.roundDuration, options);
            if (message.syncDuration != null && message.hasOwnProperty("syncDuration"))
                object.syncDuration = $root.google.protobuf.Duration.toObject(message.syncDuration, options);
            return object;
        };

        /**
         * Converts this PoaRoundInfo to JSON.
         * @function toJSON
         * @memberof wavesenterprise.PoaRoundInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PoaRoundInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PoaRoundInfo;
    })();

    wavesenterprise.PosRoundInfo = (function() {

        /**
         * Properties of a PosRoundInfo.
         * @memberof wavesenterprise
         * @interface IPosRoundInfo
         * @property {google.protobuf.IDuration|null} [averageBlockDelay] PosRoundInfo averageBlockDelay
         */

        /**
         * Constructs a new PosRoundInfo.
         * @memberof wavesenterprise
         * @classdesc Represents a PosRoundInfo.
         * @implements IPosRoundInfo
         * @constructor
         * @param {wavesenterprise.IPosRoundInfo=} [properties] Properties to set
         */
        function PosRoundInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PosRoundInfo averageBlockDelay.
         * @member {google.protobuf.IDuration|null|undefined} averageBlockDelay
         * @memberof wavesenterprise.PosRoundInfo
         * @instance
         */
        PosRoundInfo.prototype.averageBlockDelay = null;

        /**
         * Creates a new PosRoundInfo instance using the specified properties.
         * @function create
         * @memberof wavesenterprise.PosRoundInfo
         * @static
         * @param {wavesenterprise.IPosRoundInfo=} [properties] Properties to set
         * @returns {wavesenterprise.PosRoundInfo} PosRoundInfo instance
         */
        PosRoundInfo.create = function create(properties) {
            return new PosRoundInfo(properties);
        };

        /**
         * Encodes the specified PosRoundInfo message. Does not implicitly {@link wavesenterprise.PosRoundInfo.verify|verify} messages.
         * @function encode
         * @memberof wavesenterprise.PosRoundInfo
         * @static
         * @param {wavesenterprise.IPosRoundInfo} message PosRoundInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PosRoundInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.averageBlockDelay != null && Object.hasOwnProperty.call(message, "averageBlockDelay"))
                $root.google.protobuf.Duration.encode(message.averageBlockDelay, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified PosRoundInfo message, length delimited. Does not implicitly {@link wavesenterprise.PosRoundInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof wavesenterprise.PosRoundInfo
         * @static
         * @param {wavesenterprise.IPosRoundInfo} message PosRoundInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PosRoundInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PosRoundInfo message from the specified reader or buffer.
         * @function decode
         * @memberof wavesenterprise.PosRoundInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {wavesenterprise.PosRoundInfo} PosRoundInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PosRoundInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.wavesenterprise.PosRoundInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.averageBlockDelay = $root.google.protobuf.Duration.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PosRoundInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof wavesenterprise.PosRoundInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {wavesenterprise.PosRoundInfo} PosRoundInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PosRoundInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PosRoundInfo message.
         * @function verify
         * @memberof wavesenterprise.PosRoundInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PosRoundInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.averageBlockDelay != null && message.hasOwnProperty("averageBlockDelay")) {
                var error = $root.google.protobuf.Duration.verify(message.averageBlockDelay);
                if (error)
                    return "averageBlockDelay." + error;
            }
            return null;
        };

        /**
         * Creates a PosRoundInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof wavesenterprise.PosRoundInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {wavesenterprise.PosRoundInfo} PosRoundInfo
         */
        PosRoundInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.wavesenterprise.PosRoundInfo)
                return object;
            var message = new $root.wavesenterprise.PosRoundInfo();
            if (object.averageBlockDelay != null) {
                if (typeof object.averageBlockDelay !== "object")
                    throw TypeError(".wavesenterprise.PosRoundInfo.averageBlockDelay: object expected");
                message.averageBlockDelay = $root.google.protobuf.Duration.fromObject(object.averageBlockDelay);
            }
            return message;
        };

        /**
         * Creates a plain object from a PosRoundInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof wavesenterprise.PosRoundInfo
         * @static
         * @param {wavesenterprise.PosRoundInfo} message PosRoundInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PosRoundInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.averageBlockDelay = null;
            if (message.averageBlockDelay != null && message.hasOwnProperty("averageBlockDelay"))
                object.averageBlockDelay = $root.google.protobuf.Duration.toObject(message.averageBlockDelay, options);
            return object;
        };

        /**
         * Converts this PosRoundInfo to JSON.
         * @function toJSON
         * @memberof wavesenterprise.PosRoundInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PosRoundInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PosRoundInfo;
    })();

    /**
     * CryptoAlgo enum.
     * @name wavesenterprise.CryptoAlgo
     * @enum {number}
     * @property {number} UNKNOWN_CRYPTO_ALGO=0 UNKNOWN_CRYPTO_ALGO value
     * @property {number} GOST_28147=1 GOST_28147 value
     * @property {number} GOST_3412_2015_K=2 GOST_3412_2015_K value
     * @property {number} AES=3 AES value
     */
    wavesenterprise.CryptoAlgo = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "UNKNOWN_CRYPTO_ALGO"] = 0;
        values[valuesById[1] = "GOST_28147"] = 1;
        values[valuesById[2] = "GOST_3412_2015_K"] = 2;
        values[valuesById[3] = "AES"] = 3;
        return values;
    })();

    /**
     * CryptoType enum.
     * @name wavesenterprise.CryptoType
     * @enum {number}
     * @property {number} UNKNOWN_CRYPTO_TYPE=0 UNKNOWN_CRYPTO_TYPE value
     * @property {number} GOST=1 GOST value
     * @property {number} CURVE_25519=2 CURVE_25519 value
     */
    wavesenterprise.CryptoType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "UNKNOWN_CRYPTO_TYPE"] = 0;
        values[valuesById[1] = "GOST"] = 1;
        values[valuesById[2] = "CURVE_25519"] = 2;
        return values;
    })();

    /**
     * ConsensusType enum.
     * @name wavesenterprise.ConsensusType
     * @enum {number}
     * @property {number} UNKNOWN_CONSENSUS_TYPE=0 UNKNOWN_CONSENSUS_TYPE value
     * @property {number} POA=1 POA value
     * @property {number} POS=2 POS value
     * @property {number} CFT=3 CFT value
     */
    wavesenterprise.ConsensusType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "UNKNOWN_CONSENSUS_TYPE"] = 0;
        values[valuesById[1] = "POA"] = 1;
        values[valuesById[2] = "POS"] = 2;
        values[valuesById[3] = "CFT"] = 3;
        return values;
    })();

    wavesenterprise.grpc = (function() {

        /**
         * Namespace grpc.
         * @memberof wavesenterprise
         * @namespace
         */
        var grpc = {};

        grpc.TransactionPublicService = (function() {

            /**
             * Constructs a new TransactionPublicService service.
             * @memberof wavesenterprise.grpc
             * @classdesc Represents a TransactionPublicService
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function TransactionPublicService(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (TransactionPublicService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = TransactionPublicService;

            /**
             * Creates new TransactionPublicService service using the specified rpc implementation.
             * @function create
             * @memberof wavesenterprise.grpc.TransactionPublicService
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {TransactionPublicService} RPC service. Useful where requests and/or responses are streamed.
             */
            TransactionPublicService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };

            /**
             * Callback as used by {@link wavesenterprise.grpc.TransactionPublicService#broadcast}.
             * @memberof wavesenterprise.grpc.TransactionPublicService
             * @typedef BroadcastCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {wavesenterprise.Transaction} [response] Transaction
             */

            /**
             * Calls Broadcast.
             * @function broadcast
             * @memberof wavesenterprise.grpc.TransactionPublicService
             * @instance
             * @param {wavesenterprise.ITransaction} request Transaction message or plain object
             * @param {wavesenterprise.grpc.TransactionPublicService.BroadcastCallback} callback Node-style callback called with the error, if any, and Transaction
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(TransactionPublicService.prototype.broadcast = function broadcast(request, callback) {
                return this.rpcCall(broadcast, $root.wavesenterprise.Transaction, $root.wavesenterprise.Transaction, request, callback);
            }, "name", { value: "Broadcast" });

            /**
             * Calls Broadcast.
             * @function broadcast
             * @memberof wavesenterprise.grpc.TransactionPublicService
             * @instance
             * @param {wavesenterprise.ITransaction} request Transaction message or plain object
             * @returns {Promise<wavesenterprise.Transaction>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link wavesenterprise.grpc.TransactionPublicService#utxInfo}.
             * @memberof wavesenterprise.grpc.TransactionPublicService
             * @typedef UtxInfoCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {wavesenterprise.grpc.UtxSize} [response] UtxSize
             */

            /**
             * Calls UtxInfo.
             * @function utxInfo
             * @memberof wavesenterprise.grpc.TransactionPublicService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @param {wavesenterprise.grpc.TransactionPublicService.UtxInfoCallback} callback Node-style callback called with the error, if any, and UtxSize
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(TransactionPublicService.prototype.utxInfo = function utxInfo(request, callback) {
                return this.rpcCall(utxInfo, $root.google.protobuf.Empty, $root.wavesenterprise.grpc.UtxSize, request, callback);
            }, "name", { value: "UtxInfo" });

            /**
             * Calls UtxInfo.
             * @function utxInfo
             * @memberof wavesenterprise.grpc.TransactionPublicService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @returns {Promise<wavesenterprise.grpc.UtxSize>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link wavesenterprise.grpc.TransactionPublicService#transactionInfo}.
             * @memberof wavesenterprise.grpc.TransactionPublicService
             * @typedef TransactionInfoCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {wavesenterprise.TransactionInfoResponse} [response] TransactionInfoResponse
             */

            /**
             * Calls TransactionInfo.
             * @function transactionInfo
             * @memberof wavesenterprise.grpc.TransactionPublicService
             * @instance
             * @param {wavesenterprise.ITransactionInfoRequest} request TransactionInfoRequest message or plain object
             * @param {wavesenterprise.grpc.TransactionPublicService.TransactionInfoCallback} callback Node-style callback called with the error, if any, and TransactionInfoResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(TransactionPublicService.prototype.transactionInfo = function transactionInfo(request, callback) {
                return this.rpcCall(transactionInfo, $root.wavesenterprise.TransactionInfoRequest, $root.wavesenterprise.TransactionInfoResponse, request, callback);
            }, "name", { value: "TransactionInfo" });

            /**
             * Calls TransactionInfo.
             * @function transactionInfo
             * @memberof wavesenterprise.grpc.TransactionPublicService
             * @instance
             * @param {wavesenterprise.ITransactionInfoRequest} request TransactionInfoRequest message or plain object
             * @returns {Promise<wavesenterprise.TransactionInfoResponse>} Promise
             * @variation 2
             */

            return TransactionPublicService;
        })();

        grpc.UtxSize = (function() {

            /**
             * Properties of an UtxSize.
             * @memberof wavesenterprise.grpc
             * @interface IUtxSize
             * @property {number|null} [size] UtxSize size
             * @property {number|Long|null} [sizeInBytes] UtxSize sizeInBytes
             */

            /**
             * Constructs a new UtxSize.
             * @memberof wavesenterprise.grpc
             * @classdesc Represents an UtxSize.
             * @implements IUtxSize
             * @constructor
             * @param {wavesenterprise.grpc.IUtxSize=} [properties] Properties to set
             */
            function UtxSize(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * UtxSize size.
             * @member {number} size
             * @memberof wavesenterprise.grpc.UtxSize
             * @instance
             */
            UtxSize.prototype.size = 0;

            /**
             * UtxSize sizeInBytes.
             * @member {number|Long} sizeInBytes
             * @memberof wavesenterprise.grpc.UtxSize
             * @instance
             */
            UtxSize.prototype.sizeInBytes = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new UtxSize instance using the specified properties.
             * @function create
             * @memberof wavesenterprise.grpc.UtxSize
             * @static
             * @param {wavesenterprise.grpc.IUtxSize=} [properties] Properties to set
             * @returns {wavesenterprise.grpc.UtxSize} UtxSize instance
             */
            UtxSize.create = function create(properties) {
                return new UtxSize(properties);
            };

            /**
             * Encodes the specified UtxSize message. Does not implicitly {@link wavesenterprise.grpc.UtxSize.verify|verify} messages.
             * @function encode
             * @memberof wavesenterprise.grpc.UtxSize
             * @static
             * @param {wavesenterprise.grpc.IUtxSize} message UtxSize message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UtxSize.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.size != null && Object.hasOwnProperty.call(message, "size"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.size);
                if (message.sizeInBytes != null && Object.hasOwnProperty.call(message, "sizeInBytes"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.sizeInBytes);
                return writer;
            };

            /**
             * Encodes the specified UtxSize message, length delimited. Does not implicitly {@link wavesenterprise.grpc.UtxSize.verify|verify} messages.
             * @function encodeDelimited
             * @memberof wavesenterprise.grpc.UtxSize
             * @static
             * @param {wavesenterprise.grpc.IUtxSize} message UtxSize message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UtxSize.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an UtxSize message from the specified reader or buffer.
             * @function decode
             * @memberof wavesenterprise.grpc.UtxSize
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {wavesenterprise.grpc.UtxSize} UtxSize
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UtxSize.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.wavesenterprise.grpc.UtxSize();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.size = reader.int32();
                        break;
                    case 2:
                        message.sizeInBytes = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an UtxSize message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof wavesenterprise.grpc.UtxSize
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {wavesenterprise.grpc.UtxSize} UtxSize
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UtxSize.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an UtxSize message.
             * @function verify
             * @memberof wavesenterprise.grpc.UtxSize
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UtxSize.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.size != null && message.hasOwnProperty("size"))
                    if (!$util.isInteger(message.size))
                        return "size: integer expected";
                if (message.sizeInBytes != null && message.hasOwnProperty("sizeInBytes"))
                    if (!$util.isInteger(message.sizeInBytes) && !(message.sizeInBytes && $util.isInteger(message.sizeInBytes.low) && $util.isInteger(message.sizeInBytes.high)))
                        return "sizeInBytes: integer|Long expected";
                return null;
            };

            /**
             * Creates an UtxSize message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof wavesenterprise.grpc.UtxSize
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {wavesenterprise.grpc.UtxSize} UtxSize
             */
            UtxSize.fromObject = function fromObject(object) {
                if (object instanceof $root.wavesenterprise.grpc.UtxSize)
                    return object;
                var message = new $root.wavesenterprise.grpc.UtxSize();
                if (object.size != null)
                    message.size = object.size | 0;
                if (object.sizeInBytes != null)
                    if ($util.Long)
                        (message.sizeInBytes = $util.Long.fromValue(object.sizeInBytes)).unsigned = false;
                    else if (typeof object.sizeInBytes === "string")
                        message.sizeInBytes = parseInt(object.sizeInBytes, 10);
                    else if (typeof object.sizeInBytes === "number")
                        message.sizeInBytes = object.sizeInBytes;
                    else if (typeof object.sizeInBytes === "object")
                        message.sizeInBytes = new $util.LongBits(object.sizeInBytes.low >>> 0, object.sizeInBytes.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from an UtxSize message. Also converts values to other types if specified.
             * @function toObject
             * @memberof wavesenterprise.grpc.UtxSize
             * @static
             * @param {wavesenterprise.grpc.UtxSize} message UtxSize
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UtxSize.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.size = 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.sizeInBytes = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.sizeInBytes = options.longs === String ? "0" : 0;
                }
                if (message.size != null && message.hasOwnProperty("size"))
                    object.size = message.size;
                if (message.sizeInBytes != null && message.hasOwnProperty("sizeInBytes"))
                    if (typeof message.sizeInBytes === "number")
                        object.sizeInBytes = options.longs === String ? String(message.sizeInBytes) : message.sizeInBytes;
                    else
                        object.sizeInBytes = options.longs === String ? $util.Long.prototype.toString.call(message.sizeInBytes) : options.longs === Number ? new $util.LongBits(message.sizeInBytes.low >>> 0, message.sizeInBytes.high >>> 0).toNumber() : message.sizeInBytes;
                return object;
            };

            /**
             * Converts this UtxSize to JSON.
             * @function toJSON
             * @memberof wavesenterprise.grpc.UtxSize
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UtxSize.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return UtxSize;
        })();

        return grpc;
    })();

    wavesenterprise.TransactionInfoRequest = (function() {

        /**
         * Properties of a TransactionInfoRequest.
         * @memberof wavesenterprise
         * @interface ITransactionInfoRequest
         * @property {string|null} [txId] TransactionInfoRequest txId
         */

        /**
         * Constructs a new TransactionInfoRequest.
         * @memberof wavesenterprise
         * @classdesc Represents a TransactionInfoRequest.
         * @implements ITransactionInfoRequest
         * @constructor
         * @param {wavesenterprise.ITransactionInfoRequest=} [properties] Properties to set
         */
        function TransactionInfoRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TransactionInfoRequest txId.
         * @member {string} txId
         * @memberof wavesenterprise.TransactionInfoRequest
         * @instance
         */
        TransactionInfoRequest.prototype.txId = "";

        /**
         * Creates a new TransactionInfoRequest instance using the specified properties.
         * @function create
         * @memberof wavesenterprise.TransactionInfoRequest
         * @static
         * @param {wavesenterprise.ITransactionInfoRequest=} [properties] Properties to set
         * @returns {wavesenterprise.TransactionInfoRequest} TransactionInfoRequest instance
         */
        TransactionInfoRequest.create = function create(properties) {
            return new TransactionInfoRequest(properties);
        };

        /**
         * Encodes the specified TransactionInfoRequest message. Does not implicitly {@link wavesenterprise.TransactionInfoRequest.verify|verify} messages.
         * @function encode
         * @memberof wavesenterprise.TransactionInfoRequest
         * @static
         * @param {wavesenterprise.ITransactionInfoRequest} message TransactionInfoRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransactionInfoRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.txId != null && Object.hasOwnProperty.call(message, "txId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.txId);
            return writer;
        };

        /**
         * Encodes the specified TransactionInfoRequest message, length delimited. Does not implicitly {@link wavesenterprise.TransactionInfoRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof wavesenterprise.TransactionInfoRequest
         * @static
         * @param {wavesenterprise.ITransactionInfoRequest} message TransactionInfoRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransactionInfoRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TransactionInfoRequest message from the specified reader or buffer.
         * @function decode
         * @memberof wavesenterprise.TransactionInfoRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {wavesenterprise.TransactionInfoRequest} TransactionInfoRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransactionInfoRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.wavesenterprise.TransactionInfoRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.txId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TransactionInfoRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof wavesenterprise.TransactionInfoRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {wavesenterprise.TransactionInfoRequest} TransactionInfoRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransactionInfoRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TransactionInfoRequest message.
         * @function verify
         * @memberof wavesenterprise.TransactionInfoRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TransactionInfoRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.txId != null && message.hasOwnProperty("txId"))
                if (!$util.isString(message.txId))
                    return "txId: string expected";
            return null;
        };

        /**
         * Creates a TransactionInfoRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof wavesenterprise.TransactionInfoRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {wavesenterprise.TransactionInfoRequest} TransactionInfoRequest
         */
        TransactionInfoRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.wavesenterprise.TransactionInfoRequest)
                return object;
            var message = new $root.wavesenterprise.TransactionInfoRequest();
            if (object.txId != null)
                message.txId = String(object.txId);
            return message;
        };

        /**
         * Creates a plain object from a TransactionInfoRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof wavesenterprise.TransactionInfoRequest
         * @static
         * @param {wavesenterprise.TransactionInfoRequest} message TransactionInfoRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TransactionInfoRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.txId = "";
            if (message.txId != null && message.hasOwnProperty("txId"))
                object.txId = message.txId;
            return object;
        };

        /**
         * Converts this TransactionInfoRequest to JSON.
         * @function toJSON
         * @memberof wavesenterprise.TransactionInfoRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TransactionInfoRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TransactionInfoRequest;
    })();

    wavesenterprise.TransactionInfoResponse = (function() {

        /**
         * Properties of a TransactionInfoResponse.
         * @memberof wavesenterprise
         * @interface ITransactionInfoResponse
         * @property {number|null} [height] TransactionInfoResponse height
         * @property {wavesenterprise.ITransaction|null} [transaction] TransactionInfoResponse transaction
         */

        /**
         * Constructs a new TransactionInfoResponse.
         * @memberof wavesenterprise
         * @classdesc Represents a TransactionInfoResponse.
         * @implements ITransactionInfoResponse
         * @constructor
         * @param {wavesenterprise.ITransactionInfoResponse=} [properties] Properties to set
         */
        function TransactionInfoResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TransactionInfoResponse height.
         * @member {number} height
         * @memberof wavesenterprise.TransactionInfoResponse
         * @instance
         */
        TransactionInfoResponse.prototype.height = 0;

        /**
         * TransactionInfoResponse transaction.
         * @member {wavesenterprise.ITransaction|null|undefined} transaction
         * @memberof wavesenterprise.TransactionInfoResponse
         * @instance
         */
        TransactionInfoResponse.prototype.transaction = null;

        /**
         * Creates a new TransactionInfoResponse instance using the specified properties.
         * @function create
         * @memberof wavesenterprise.TransactionInfoResponse
         * @static
         * @param {wavesenterprise.ITransactionInfoResponse=} [properties] Properties to set
         * @returns {wavesenterprise.TransactionInfoResponse} TransactionInfoResponse instance
         */
        TransactionInfoResponse.create = function create(properties) {
            return new TransactionInfoResponse(properties);
        };

        /**
         * Encodes the specified TransactionInfoResponse message. Does not implicitly {@link wavesenterprise.TransactionInfoResponse.verify|verify} messages.
         * @function encode
         * @memberof wavesenterprise.TransactionInfoResponse
         * @static
         * @param {wavesenterprise.ITransactionInfoResponse} message TransactionInfoResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransactionInfoResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.height != null && Object.hasOwnProperty.call(message, "height"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.height);
            if (message.transaction != null && Object.hasOwnProperty.call(message, "transaction"))
                $root.wavesenterprise.Transaction.encode(message.transaction, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified TransactionInfoResponse message, length delimited. Does not implicitly {@link wavesenterprise.TransactionInfoResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof wavesenterprise.TransactionInfoResponse
         * @static
         * @param {wavesenterprise.ITransactionInfoResponse} message TransactionInfoResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransactionInfoResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TransactionInfoResponse message from the specified reader or buffer.
         * @function decode
         * @memberof wavesenterprise.TransactionInfoResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {wavesenterprise.TransactionInfoResponse} TransactionInfoResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransactionInfoResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.wavesenterprise.TransactionInfoResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.height = reader.int32();
                    break;
                case 2:
                    message.transaction = $root.wavesenterprise.Transaction.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TransactionInfoResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof wavesenterprise.TransactionInfoResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {wavesenterprise.TransactionInfoResponse} TransactionInfoResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransactionInfoResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TransactionInfoResponse message.
         * @function verify
         * @memberof wavesenterprise.TransactionInfoResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TransactionInfoResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.height != null && message.hasOwnProperty("height"))
                if (!$util.isInteger(message.height))
                    return "height: integer expected";
            if (message.transaction != null && message.hasOwnProperty("transaction")) {
                var error = $root.wavesenterprise.Transaction.verify(message.transaction);
                if (error)
                    return "transaction." + error;
            }
            return null;
        };

        /**
         * Creates a TransactionInfoResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof wavesenterprise.TransactionInfoResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {wavesenterprise.TransactionInfoResponse} TransactionInfoResponse
         */
        TransactionInfoResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.wavesenterprise.TransactionInfoResponse)
                return object;
            var message = new $root.wavesenterprise.TransactionInfoResponse();
            if (object.height != null)
                message.height = object.height | 0;
            if (object.transaction != null) {
                if (typeof object.transaction !== "object")
                    throw TypeError(".wavesenterprise.TransactionInfoResponse.transaction: object expected");
                message.transaction = $root.wavesenterprise.Transaction.fromObject(object.transaction);
            }
            return message;
        };

        /**
         * Creates a plain object from a TransactionInfoResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof wavesenterprise.TransactionInfoResponse
         * @static
         * @param {wavesenterprise.TransactionInfoResponse} message TransactionInfoResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TransactionInfoResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.height = 0;
                object.transaction = null;
            }
            if (message.height != null && message.hasOwnProperty("height"))
                object.height = message.height;
            if (message.transaction != null && message.hasOwnProperty("transaction"))
                object.transaction = $root.wavesenterprise.Transaction.toObject(message.transaction, options);
            return object;
        };

        /**
         * Converts this TransactionInfoResponse to JSON.
         * @function toJSON
         * @memberof wavesenterprise.TransactionInfoResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TransactionInfoResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TransactionInfoResponse;
    })();

    return wavesenterprise;
})();

$root.google = (function() {

    /**
     * Namespace google.
     * @exports google
     * @namespace
     */
    var google = {};

    google.protobuf = (function() {

        /**
         * Namespace protobuf.
         * @memberof google
         * @namespace
         */
        var protobuf = {};

        protobuf.DoubleValue = (function() {

            /**
             * Properties of a DoubleValue.
             * @memberof google.protobuf
             * @interface IDoubleValue
             * @property {number|null} [value] DoubleValue value
             */

            /**
             * Constructs a new DoubleValue.
             * @memberof google.protobuf
             * @classdesc Represents a DoubleValue.
             * @implements IDoubleValue
             * @constructor
             * @param {google.protobuf.IDoubleValue=} [properties] Properties to set
             */
            function DoubleValue(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DoubleValue value.
             * @member {number} value
             * @memberof google.protobuf.DoubleValue
             * @instance
             */
            DoubleValue.prototype.value = 0;

            /**
             * Creates a new DoubleValue instance using the specified properties.
             * @function create
             * @memberof google.protobuf.DoubleValue
             * @static
             * @param {google.protobuf.IDoubleValue=} [properties] Properties to set
             * @returns {google.protobuf.DoubleValue} DoubleValue instance
             */
            DoubleValue.create = function create(properties) {
                return new DoubleValue(properties);
            };

            /**
             * Encodes the specified DoubleValue message. Does not implicitly {@link google.protobuf.DoubleValue.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.DoubleValue
             * @static
             * @param {google.protobuf.IDoubleValue} message DoubleValue message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DoubleValue.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 1, wireType 1 =*/9).double(message.value);
                return writer;
            };

            /**
             * Encodes the specified DoubleValue message, length delimited. Does not implicitly {@link google.protobuf.DoubleValue.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.DoubleValue
             * @static
             * @param {google.protobuf.IDoubleValue} message DoubleValue message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DoubleValue.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DoubleValue message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.DoubleValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.DoubleValue} DoubleValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DoubleValue.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DoubleValue();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.value = reader.double();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DoubleValue message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.DoubleValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.DoubleValue} DoubleValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DoubleValue.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DoubleValue message.
             * @function verify
             * @memberof google.protobuf.DoubleValue
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DoubleValue.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (typeof message.value !== "number")
                        return "value: number expected";
                return null;
            };

            /**
             * Creates a DoubleValue message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.DoubleValue
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.DoubleValue} DoubleValue
             */
            DoubleValue.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.DoubleValue)
                    return object;
                var message = new $root.google.protobuf.DoubleValue();
                if (object.value != null)
                    message.value = Number(object.value);
                return message;
            };

            /**
             * Creates a plain object from a DoubleValue message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.DoubleValue
             * @static
             * @param {google.protobuf.DoubleValue} message DoubleValue
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DoubleValue.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.value = 0;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.json && !isFinite(message.value) ? String(message.value) : message.value;
                return object;
            };

            /**
             * Converts this DoubleValue to JSON.
             * @function toJSON
             * @memberof google.protobuf.DoubleValue
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DoubleValue.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DoubleValue;
        })();

        protobuf.FloatValue = (function() {

            /**
             * Properties of a FloatValue.
             * @memberof google.protobuf
             * @interface IFloatValue
             * @property {number|null} [value] FloatValue value
             */

            /**
             * Constructs a new FloatValue.
             * @memberof google.protobuf
             * @classdesc Represents a FloatValue.
             * @implements IFloatValue
             * @constructor
             * @param {google.protobuf.IFloatValue=} [properties] Properties to set
             */
            function FloatValue(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FloatValue value.
             * @member {number} value
             * @memberof google.protobuf.FloatValue
             * @instance
             */
            FloatValue.prototype.value = 0;

            /**
             * Creates a new FloatValue instance using the specified properties.
             * @function create
             * @memberof google.protobuf.FloatValue
             * @static
             * @param {google.protobuf.IFloatValue=} [properties] Properties to set
             * @returns {google.protobuf.FloatValue} FloatValue instance
             */
            FloatValue.create = function create(properties) {
                return new FloatValue(properties);
            };

            /**
             * Encodes the specified FloatValue message. Does not implicitly {@link google.protobuf.FloatValue.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.FloatValue
             * @static
             * @param {google.protobuf.IFloatValue} message FloatValue message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FloatValue.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 1, wireType 5 =*/13).float(message.value);
                return writer;
            };

            /**
             * Encodes the specified FloatValue message, length delimited. Does not implicitly {@link google.protobuf.FloatValue.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.FloatValue
             * @static
             * @param {google.protobuf.IFloatValue} message FloatValue message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FloatValue.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FloatValue message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.FloatValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FloatValue} FloatValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FloatValue.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FloatValue();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.value = reader.float();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FloatValue message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.FloatValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.FloatValue} FloatValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FloatValue.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FloatValue message.
             * @function verify
             * @memberof google.protobuf.FloatValue
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FloatValue.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (typeof message.value !== "number")
                        return "value: number expected";
                return null;
            };

            /**
             * Creates a FloatValue message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.FloatValue
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FloatValue} FloatValue
             */
            FloatValue.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.FloatValue)
                    return object;
                var message = new $root.google.protobuf.FloatValue();
                if (object.value != null)
                    message.value = Number(object.value);
                return message;
            };

            /**
             * Creates a plain object from a FloatValue message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.FloatValue
             * @static
             * @param {google.protobuf.FloatValue} message FloatValue
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FloatValue.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.value = 0;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.json && !isFinite(message.value) ? String(message.value) : message.value;
                return object;
            };

            /**
             * Converts this FloatValue to JSON.
             * @function toJSON
             * @memberof google.protobuf.FloatValue
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FloatValue.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return FloatValue;
        })();

        protobuf.Int64Value = (function() {

            /**
             * Properties of an Int64Value.
             * @memberof google.protobuf
             * @interface IInt64Value
             * @property {number|Long|null} [value] Int64Value value
             */

            /**
             * Constructs a new Int64Value.
             * @memberof google.protobuf
             * @classdesc Represents an Int64Value.
             * @implements IInt64Value
             * @constructor
             * @param {google.protobuf.IInt64Value=} [properties] Properties to set
             */
            function Int64Value(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Int64Value value.
             * @member {number|Long} value
             * @memberof google.protobuf.Int64Value
             * @instance
             */
            Int64Value.prototype.value = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new Int64Value instance using the specified properties.
             * @function create
             * @memberof google.protobuf.Int64Value
             * @static
             * @param {google.protobuf.IInt64Value=} [properties] Properties to set
             * @returns {google.protobuf.Int64Value} Int64Value instance
             */
            Int64Value.create = function create(properties) {
                return new Int64Value(properties);
            };

            /**
             * Encodes the specified Int64Value message. Does not implicitly {@link google.protobuf.Int64Value.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.Int64Value
             * @static
             * @param {google.protobuf.IInt64Value} message Int64Value message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Int64Value.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.value);
                return writer;
            };

            /**
             * Encodes the specified Int64Value message, length delimited. Does not implicitly {@link google.protobuf.Int64Value.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.Int64Value
             * @static
             * @param {google.protobuf.IInt64Value} message Int64Value message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Int64Value.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Int64Value message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.Int64Value
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.Int64Value} Int64Value
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Int64Value.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Int64Value();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.value = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Int64Value message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.Int64Value
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.Int64Value} Int64Value
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Int64Value.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Int64Value message.
             * @function verify
             * @memberof google.protobuf.Int64Value
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Int64Value.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!$util.isInteger(message.value) && !(message.value && $util.isInteger(message.value.low) && $util.isInteger(message.value.high)))
                        return "value: integer|Long expected";
                return null;
            };

            /**
             * Creates an Int64Value message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.Int64Value
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Int64Value} Int64Value
             */
            Int64Value.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Int64Value)
                    return object;
                var message = new $root.google.protobuf.Int64Value();
                if (object.value != null)
                    if ($util.Long)
                        (message.value = $util.Long.fromValue(object.value)).unsigned = false;
                    else if (typeof object.value === "string")
                        message.value = parseInt(object.value, 10);
                    else if (typeof object.value === "number")
                        message.value = object.value;
                    else if (typeof object.value === "object")
                        message.value = new $util.LongBits(object.value.low >>> 0, object.value.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from an Int64Value message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.Int64Value
             * @static
             * @param {google.protobuf.Int64Value} message Int64Value
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Int64Value.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.value = options.longs === String ? "0" : 0;
                if (message.value != null && message.hasOwnProperty("value"))
                    if (typeof message.value === "number")
                        object.value = options.longs === String ? String(message.value) : message.value;
                    else
                        object.value = options.longs === String ? $util.Long.prototype.toString.call(message.value) : options.longs === Number ? new $util.LongBits(message.value.low >>> 0, message.value.high >>> 0).toNumber() : message.value;
                return object;
            };

            /**
             * Converts this Int64Value to JSON.
             * @function toJSON
             * @memberof google.protobuf.Int64Value
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Int64Value.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Int64Value;
        })();

        protobuf.UInt64Value = (function() {

            /**
             * Properties of a UInt64Value.
             * @memberof google.protobuf
             * @interface IUInt64Value
             * @property {number|Long|null} [value] UInt64Value value
             */

            /**
             * Constructs a new UInt64Value.
             * @memberof google.protobuf
             * @classdesc Represents a UInt64Value.
             * @implements IUInt64Value
             * @constructor
             * @param {google.protobuf.IUInt64Value=} [properties] Properties to set
             */
            function UInt64Value(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * UInt64Value value.
             * @member {number|Long} value
             * @memberof google.protobuf.UInt64Value
             * @instance
             */
            UInt64Value.prototype.value = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new UInt64Value instance using the specified properties.
             * @function create
             * @memberof google.protobuf.UInt64Value
             * @static
             * @param {google.protobuf.IUInt64Value=} [properties] Properties to set
             * @returns {google.protobuf.UInt64Value} UInt64Value instance
             */
            UInt64Value.create = function create(properties) {
                return new UInt64Value(properties);
            };

            /**
             * Encodes the specified UInt64Value message. Does not implicitly {@link google.protobuf.UInt64Value.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.UInt64Value
             * @static
             * @param {google.protobuf.IUInt64Value} message UInt64Value message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UInt64Value.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.value);
                return writer;
            };

            /**
             * Encodes the specified UInt64Value message, length delimited. Does not implicitly {@link google.protobuf.UInt64Value.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.UInt64Value
             * @static
             * @param {google.protobuf.IUInt64Value} message UInt64Value message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UInt64Value.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a UInt64Value message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.UInt64Value
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.UInt64Value} UInt64Value
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UInt64Value.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.UInt64Value();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.value = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a UInt64Value message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.UInt64Value
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.UInt64Value} UInt64Value
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UInt64Value.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a UInt64Value message.
             * @function verify
             * @memberof google.protobuf.UInt64Value
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UInt64Value.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!$util.isInteger(message.value) && !(message.value && $util.isInteger(message.value.low) && $util.isInteger(message.value.high)))
                        return "value: integer|Long expected";
                return null;
            };

            /**
             * Creates a UInt64Value message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.UInt64Value
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.UInt64Value} UInt64Value
             */
            UInt64Value.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.UInt64Value)
                    return object;
                var message = new $root.google.protobuf.UInt64Value();
                if (object.value != null)
                    if ($util.Long)
                        (message.value = $util.Long.fromValue(object.value)).unsigned = true;
                    else if (typeof object.value === "string")
                        message.value = parseInt(object.value, 10);
                    else if (typeof object.value === "number")
                        message.value = object.value;
                    else if (typeof object.value === "object")
                        message.value = new $util.LongBits(object.value.low >>> 0, object.value.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a UInt64Value message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.UInt64Value
             * @static
             * @param {google.protobuf.UInt64Value} message UInt64Value
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UInt64Value.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.value = options.longs === String ? "0" : 0;
                if (message.value != null && message.hasOwnProperty("value"))
                    if (typeof message.value === "number")
                        object.value = options.longs === String ? String(message.value) : message.value;
                    else
                        object.value = options.longs === String ? $util.Long.prototype.toString.call(message.value) : options.longs === Number ? new $util.LongBits(message.value.low >>> 0, message.value.high >>> 0).toNumber(true) : message.value;
                return object;
            };

            /**
             * Converts this UInt64Value to JSON.
             * @function toJSON
             * @memberof google.protobuf.UInt64Value
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UInt64Value.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return UInt64Value;
        })();

        protobuf.Int32Value = (function() {

            /**
             * Properties of an Int32Value.
             * @memberof google.protobuf
             * @interface IInt32Value
             * @property {number|null} [value] Int32Value value
             */

            /**
             * Constructs a new Int32Value.
             * @memberof google.protobuf
             * @classdesc Represents an Int32Value.
             * @implements IInt32Value
             * @constructor
             * @param {google.protobuf.IInt32Value=} [properties] Properties to set
             */
            function Int32Value(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Int32Value value.
             * @member {number} value
             * @memberof google.protobuf.Int32Value
             * @instance
             */
            Int32Value.prototype.value = 0;

            /**
             * Creates a new Int32Value instance using the specified properties.
             * @function create
             * @memberof google.protobuf.Int32Value
             * @static
             * @param {google.protobuf.IInt32Value=} [properties] Properties to set
             * @returns {google.protobuf.Int32Value} Int32Value instance
             */
            Int32Value.create = function create(properties) {
                return new Int32Value(properties);
            };

            /**
             * Encodes the specified Int32Value message. Does not implicitly {@link google.protobuf.Int32Value.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.Int32Value
             * @static
             * @param {google.protobuf.IInt32Value} message Int32Value message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Int32Value.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.value);
                return writer;
            };

            /**
             * Encodes the specified Int32Value message, length delimited. Does not implicitly {@link google.protobuf.Int32Value.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.Int32Value
             * @static
             * @param {google.protobuf.IInt32Value} message Int32Value message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Int32Value.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Int32Value message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.Int32Value
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.Int32Value} Int32Value
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Int32Value.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Int32Value();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.value = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Int32Value message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.Int32Value
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.Int32Value} Int32Value
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Int32Value.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Int32Value message.
             * @function verify
             * @memberof google.protobuf.Int32Value
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Int32Value.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!$util.isInteger(message.value))
                        return "value: integer expected";
                return null;
            };

            /**
             * Creates an Int32Value message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.Int32Value
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Int32Value} Int32Value
             */
            Int32Value.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Int32Value)
                    return object;
                var message = new $root.google.protobuf.Int32Value();
                if (object.value != null)
                    message.value = object.value | 0;
                return message;
            };

            /**
             * Creates a plain object from an Int32Value message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.Int32Value
             * @static
             * @param {google.protobuf.Int32Value} message Int32Value
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Int32Value.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.value = 0;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = message.value;
                return object;
            };

            /**
             * Converts this Int32Value to JSON.
             * @function toJSON
             * @memberof google.protobuf.Int32Value
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Int32Value.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Int32Value;
        })();

        protobuf.UInt32Value = (function() {

            /**
             * Properties of a UInt32Value.
             * @memberof google.protobuf
             * @interface IUInt32Value
             * @property {number|null} [value] UInt32Value value
             */

            /**
             * Constructs a new UInt32Value.
             * @memberof google.protobuf
             * @classdesc Represents a UInt32Value.
             * @implements IUInt32Value
             * @constructor
             * @param {google.protobuf.IUInt32Value=} [properties] Properties to set
             */
            function UInt32Value(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * UInt32Value value.
             * @member {number} value
             * @memberof google.protobuf.UInt32Value
             * @instance
             */
            UInt32Value.prototype.value = 0;

            /**
             * Creates a new UInt32Value instance using the specified properties.
             * @function create
             * @memberof google.protobuf.UInt32Value
             * @static
             * @param {google.protobuf.IUInt32Value=} [properties] Properties to set
             * @returns {google.protobuf.UInt32Value} UInt32Value instance
             */
            UInt32Value.create = function create(properties) {
                return new UInt32Value(properties);
            };

            /**
             * Encodes the specified UInt32Value message. Does not implicitly {@link google.protobuf.UInt32Value.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.UInt32Value
             * @static
             * @param {google.protobuf.IUInt32Value} message UInt32Value message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UInt32Value.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.value);
                return writer;
            };

            /**
             * Encodes the specified UInt32Value message, length delimited. Does not implicitly {@link google.protobuf.UInt32Value.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.UInt32Value
             * @static
             * @param {google.protobuf.IUInt32Value} message UInt32Value message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UInt32Value.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a UInt32Value message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.UInt32Value
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.UInt32Value} UInt32Value
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UInt32Value.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.UInt32Value();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.value = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a UInt32Value message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.UInt32Value
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.UInt32Value} UInt32Value
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UInt32Value.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a UInt32Value message.
             * @function verify
             * @memberof google.protobuf.UInt32Value
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UInt32Value.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!$util.isInteger(message.value))
                        return "value: integer expected";
                return null;
            };

            /**
             * Creates a UInt32Value message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.UInt32Value
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.UInt32Value} UInt32Value
             */
            UInt32Value.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.UInt32Value)
                    return object;
                var message = new $root.google.protobuf.UInt32Value();
                if (object.value != null)
                    message.value = object.value >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a UInt32Value message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.UInt32Value
             * @static
             * @param {google.protobuf.UInt32Value} message UInt32Value
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UInt32Value.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.value = 0;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = message.value;
                return object;
            };

            /**
             * Converts this UInt32Value to JSON.
             * @function toJSON
             * @memberof google.protobuf.UInt32Value
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UInt32Value.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return UInt32Value;
        })();

        protobuf.BoolValue = (function() {

            /**
             * Properties of a BoolValue.
             * @memberof google.protobuf
             * @interface IBoolValue
             * @property {boolean|null} [value] BoolValue value
             */

            /**
             * Constructs a new BoolValue.
             * @memberof google.protobuf
             * @classdesc Represents a BoolValue.
             * @implements IBoolValue
             * @constructor
             * @param {google.protobuf.IBoolValue=} [properties] Properties to set
             */
            function BoolValue(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BoolValue value.
             * @member {boolean} value
             * @memberof google.protobuf.BoolValue
             * @instance
             */
            BoolValue.prototype.value = false;

            /**
             * Creates a new BoolValue instance using the specified properties.
             * @function create
             * @memberof google.protobuf.BoolValue
             * @static
             * @param {google.protobuf.IBoolValue=} [properties] Properties to set
             * @returns {google.protobuf.BoolValue} BoolValue instance
             */
            BoolValue.create = function create(properties) {
                return new BoolValue(properties);
            };

            /**
             * Encodes the specified BoolValue message. Does not implicitly {@link google.protobuf.BoolValue.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.BoolValue
             * @static
             * @param {google.protobuf.IBoolValue} message BoolValue message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BoolValue.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.value);
                return writer;
            };

            /**
             * Encodes the specified BoolValue message, length delimited. Does not implicitly {@link google.protobuf.BoolValue.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.BoolValue
             * @static
             * @param {google.protobuf.IBoolValue} message BoolValue message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BoolValue.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BoolValue message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.BoolValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.BoolValue} BoolValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BoolValue.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.BoolValue();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.value = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BoolValue message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.BoolValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.BoolValue} BoolValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BoolValue.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BoolValue message.
             * @function verify
             * @memberof google.protobuf.BoolValue
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BoolValue.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (typeof message.value !== "boolean")
                        return "value: boolean expected";
                return null;
            };

            /**
             * Creates a BoolValue message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.BoolValue
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.BoolValue} BoolValue
             */
            BoolValue.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.BoolValue)
                    return object;
                var message = new $root.google.protobuf.BoolValue();
                if (object.value != null)
                    message.value = Boolean(object.value);
                return message;
            };

            /**
             * Creates a plain object from a BoolValue message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.BoolValue
             * @static
             * @param {google.protobuf.BoolValue} message BoolValue
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BoolValue.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.value = false;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = message.value;
                return object;
            };

            /**
             * Converts this BoolValue to JSON.
             * @function toJSON
             * @memberof google.protobuf.BoolValue
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BoolValue.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BoolValue;
        })();

        protobuf.StringValue = (function() {

            /**
             * Properties of a StringValue.
             * @memberof google.protobuf
             * @interface IStringValue
             * @property {string|null} [value] StringValue value
             */

            /**
             * Constructs a new StringValue.
             * @memberof google.protobuf
             * @classdesc Represents a StringValue.
             * @implements IStringValue
             * @constructor
             * @param {google.protobuf.IStringValue=} [properties] Properties to set
             */
            function StringValue(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * StringValue value.
             * @member {string} value
             * @memberof google.protobuf.StringValue
             * @instance
             */
            StringValue.prototype.value = "";

            /**
             * Creates a new StringValue instance using the specified properties.
             * @function create
             * @memberof google.protobuf.StringValue
             * @static
             * @param {google.protobuf.IStringValue=} [properties] Properties to set
             * @returns {google.protobuf.StringValue} StringValue instance
             */
            StringValue.create = function create(properties) {
                return new StringValue(properties);
            };

            /**
             * Encodes the specified StringValue message. Does not implicitly {@link google.protobuf.StringValue.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.StringValue
             * @static
             * @param {google.protobuf.IStringValue} message StringValue message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StringValue.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.value);
                return writer;
            };

            /**
             * Encodes the specified StringValue message, length delimited. Does not implicitly {@link google.protobuf.StringValue.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.StringValue
             * @static
             * @param {google.protobuf.IStringValue} message StringValue message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StringValue.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StringValue message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.StringValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.StringValue} StringValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StringValue.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.StringValue();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.value = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a StringValue message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.StringValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.StringValue} StringValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StringValue.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StringValue message.
             * @function verify
             * @memberof google.protobuf.StringValue
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StringValue.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!$util.isString(message.value))
                        return "value: string expected";
                return null;
            };

            /**
             * Creates a StringValue message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.StringValue
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.StringValue} StringValue
             */
            StringValue.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.StringValue)
                    return object;
                var message = new $root.google.protobuf.StringValue();
                if (object.value != null)
                    message.value = String(object.value);
                return message;
            };

            /**
             * Creates a plain object from a StringValue message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.StringValue
             * @static
             * @param {google.protobuf.StringValue} message StringValue
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StringValue.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.value = "";
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = message.value;
                return object;
            };

            /**
             * Converts this StringValue to JSON.
             * @function toJSON
             * @memberof google.protobuf.StringValue
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StringValue.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return StringValue;
        })();

        protobuf.BytesValue = (function() {

            /**
             * Properties of a BytesValue.
             * @memberof google.protobuf
             * @interface IBytesValue
             * @property {Uint8Array|null} [value] BytesValue value
             */

            /**
             * Constructs a new BytesValue.
             * @memberof google.protobuf
             * @classdesc Represents a BytesValue.
             * @implements IBytesValue
             * @constructor
             * @param {google.protobuf.IBytesValue=} [properties] Properties to set
             */
            function BytesValue(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BytesValue value.
             * @member {Uint8Array} value
             * @memberof google.protobuf.BytesValue
             * @instance
             */
            BytesValue.prototype.value = $util.newBuffer([]);

            /**
             * Creates a new BytesValue instance using the specified properties.
             * @function create
             * @memberof google.protobuf.BytesValue
             * @static
             * @param {google.protobuf.IBytesValue=} [properties] Properties to set
             * @returns {google.protobuf.BytesValue} BytesValue instance
             */
            BytesValue.create = function create(properties) {
                return new BytesValue(properties);
            };

            /**
             * Encodes the specified BytesValue message. Does not implicitly {@link google.protobuf.BytesValue.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.BytesValue
             * @static
             * @param {google.protobuf.IBytesValue} message BytesValue message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BytesValue.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.value);
                return writer;
            };

            /**
             * Encodes the specified BytesValue message, length delimited. Does not implicitly {@link google.protobuf.BytesValue.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.BytesValue
             * @static
             * @param {google.protobuf.IBytesValue} message BytesValue message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BytesValue.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BytesValue message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.BytesValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.BytesValue} BytesValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BytesValue.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.BytesValue();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.value = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BytesValue message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.BytesValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.BytesValue} BytesValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BytesValue.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BytesValue message.
             * @function verify
             * @memberof google.protobuf.BytesValue
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BytesValue.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                return null;
            };

            /**
             * Creates a BytesValue message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.BytesValue
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.BytesValue} BytesValue
             */
            BytesValue.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.BytesValue)
                    return object;
                var message = new $root.google.protobuf.BytesValue();
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                return message;
            };

            /**
             * Creates a plain object from a BytesValue message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.BytesValue
             * @static
             * @param {google.protobuf.BytesValue} message BytesValue
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BytesValue.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                return object;
            };

            /**
             * Converts this BytesValue to JSON.
             * @function toJSON
             * @memberof google.protobuf.BytesValue
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BytesValue.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BytesValue;
        })();

        protobuf.Duration = (function() {

            /**
             * Properties of a Duration.
             * @memberof google.protobuf
             * @interface IDuration
             * @property {number|Long|null} [seconds] Duration seconds
             * @property {number|null} [nanos] Duration nanos
             */

            /**
             * Constructs a new Duration.
             * @memberof google.protobuf
             * @classdesc Represents a Duration.
             * @implements IDuration
             * @constructor
             * @param {google.protobuf.IDuration=} [properties] Properties to set
             */
            function Duration(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Duration seconds.
             * @member {number|Long} seconds
             * @memberof google.protobuf.Duration
             * @instance
             */
            Duration.prototype.seconds = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Duration nanos.
             * @member {number} nanos
             * @memberof google.protobuf.Duration
             * @instance
             */
            Duration.prototype.nanos = 0;

            /**
             * Creates a new Duration instance using the specified properties.
             * @function create
             * @memberof google.protobuf.Duration
             * @static
             * @param {google.protobuf.IDuration=} [properties] Properties to set
             * @returns {google.protobuf.Duration} Duration instance
             */
            Duration.create = function create(properties) {
                return new Duration(properties);
            };

            /**
             * Encodes the specified Duration message. Does not implicitly {@link google.protobuf.Duration.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.Duration
             * @static
             * @param {google.protobuf.IDuration} message Duration message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Duration.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.seconds != null && Object.hasOwnProperty.call(message, "seconds"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.seconds);
                if (message.nanos != null && Object.hasOwnProperty.call(message, "nanos"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.nanos);
                return writer;
            };

            /**
             * Encodes the specified Duration message, length delimited. Does not implicitly {@link google.protobuf.Duration.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.Duration
             * @static
             * @param {google.protobuf.IDuration} message Duration message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Duration.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Duration message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.Duration
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.Duration} Duration
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Duration.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Duration();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.seconds = reader.int64();
                        break;
                    case 2:
                        message.nanos = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Duration message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.Duration
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.Duration} Duration
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Duration.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Duration message.
             * @function verify
             * @memberof google.protobuf.Duration
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Duration.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.seconds != null && message.hasOwnProperty("seconds"))
                    if (!$util.isInteger(message.seconds) && !(message.seconds && $util.isInteger(message.seconds.low) && $util.isInteger(message.seconds.high)))
                        return "seconds: integer|Long expected";
                if (message.nanos != null && message.hasOwnProperty("nanos"))
                    if (!$util.isInteger(message.nanos))
                        return "nanos: integer expected";
                return null;
            };

            /**
             * Creates a Duration message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.Duration
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Duration} Duration
             */
            Duration.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Duration)
                    return object;
                var message = new $root.google.protobuf.Duration();
                if (object.seconds != null)
                    if ($util.Long)
                        (message.seconds = $util.Long.fromValue(object.seconds)).unsigned = false;
                    else if (typeof object.seconds === "string")
                        message.seconds = parseInt(object.seconds, 10);
                    else if (typeof object.seconds === "number")
                        message.seconds = object.seconds;
                    else if (typeof object.seconds === "object")
                        message.seconds = new $util.LongBits(object.seconds.low >>> 0, object.seconds.high >>> 0).toNumber();
                if (object.nanos != null)
                    message.nanos = object.nanos | 0;
                return message;
            };

            /**
             * Creates a plain object from a Duration message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.Duration
             * @static
             * @param {google.protobuf.Duration} message Duration
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Duration.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.seconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.seconds = options.longs === String ? "0" : 0;
                    object.nanos = 0;
                }
                if (message.seconds != null && message.hasOwnProperty("seconds"))
                    if (typeof message.seconds === "number")
                        object.seconds = options.longs === String ? String(message.seconds) : message.seconds;
                    else
                        object.seconds = options.longs === String ? $util.Long.prototype.toString.call(message.seconds) : options.longs === Number ? new $util.LongBits(message.seconds.low >>> 0, message.seconds.high >>> 0).toNumber() : message.seconds;
                if (message.nanos != null && message.hasOwnProperty("nanos"))
                    object.nanos = message.nanos;
                return object;
            };

            /**
             * Converts this Duration to JSON.
             * @function toJSON
             * @memberof google.protobuf.Duration
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Duration.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Duration;
        })();

        protobuf.Empty = (function() {

            /**
             * Properties of an Empty.
             * @memberof google.protobuf
             * @interface IEmpty
             */

            /**
             * Constructs a new Empty.
             * @memberof google.protobuf
             * @classdesc Represents an Empty.
             * @implements IEmpty
             * @constructor
             * @param {google.protobuf.IEmpty=} [properties] Properties to set
             */
            function Empty(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new Empty instance using the specified properties.
             * @function create
             * @memberof google.protobuf.Empty
             * @static
             * @param {google.protobuf.IEmpty=} [properties] Properties to set
             * @returns {google.protobuf.Empty} Empty instance
             */
            Empty.create = function create(properties) {
                return new Empty(properties);
            };

            /**
             * Encodes the specified Empty message. Does not implicitly {@link google.protobuf.Empty.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.Empty
             * @static
             * @param {google.protobuf.IEmpty} message Empty message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Empty.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified Empty message, length delimited. Does not implicitly {@link google.protobuf.Empty.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.Empty
             * @static
             * @param {google.protobuf.IEmpty} message Empty message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Empty.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Empty message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.Empty
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.Empty} Empty
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Empty.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Empty();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Empty message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.Empty
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.Empty} Empty
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Empty.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Empty message.
             * @function verify
             * @memberof google.protobuf.Empty
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Empty.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates an Empty message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.Empty
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Empty} Empty
             */
            Empty.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Empty)
                    return object;
                return new $root.google.protobuf.Empty();
            };

            /**
             * Creates a plain object from an Empty message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.Empty
             * @static
             * @param {google.protobuf.Empty} message Empty
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Empty.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this Empty to JSON.
             * @function toJSON
             * @memberof google.protobuf.Empty
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Empty.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Empty;
        })();

        return protobuf;
    })();

    return google;
})();

module.exports = $root;
